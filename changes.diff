diff --git a/configure b/configure
index c215478..37c420b 100755
--- a/configure
+++ b/configure
@@ -2520,10 +2520,10 @@ SLIBPREF="lib"
 SLIBSUF=".so"
 SLIBNAME='$(SLIBPREF)$(FULLNAME)$(SLIBSUF)'
 SLIBNAME_WITH_VERSION='$(SLIBNAME).$(LIBVERSION)'
-SLIBNAME_WITH_MAJOR='$(SLIBNAME).$(LIBMAJOR)'
+SLIBNAME_WITH_MAJOR='$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)'
 LIB_INSTALL_EXTRA_CMD='$$(RANLIB) "$(LIBDIR)/$(LIBNAME)"'
-SLIB_INSTALL_NAME='$(SLIBNAME_WITH_VERSION)'
-SLIB_INSTALL_LINKS='$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)'
+SLIB_INSTALL_NAME='$(SLIBNAME_WITH_MAJOR)'
+SLIB_INSTALL_LINKS='$(SLIBNAME)'
 
 asflags_filter=echo
 cflags_filter=echo
diff --git a/doc/texi2pod.pl b/doc/texi2pod.pl
deleted file mode 100644
index f972671..0000000
--- a/doc/texi2pod.pl
+++ /dev/null
@@ -1,455 +0,0 @@
-#!/usr/bin/env perl
-
-#   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
-
-# This file is part of GNU CC.
-
-# GNU CC is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# GNU CC is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with GNU CC; see the file COPYING.  If not, write to
-# the Free Software Foundation, 51 Franklin Street, Fifth Floor,
-# Boston, MA 02110-1301 USA
-
-# This does trivial (and I mean _trivial_) conversion of Texinfo
-# markup to Perl POD format.  It's intended to be used to extract
-# something suitable for a manpage from a Texinfo document.
-
-use warnings;
-
-$output = 0;
-$skipping = 0;
-%chapters = ();
-@chapters_sequence = ();
-$chapter = "";
-@icstack = ();
-@endwstack = ();
-@skstack = ();
-@instack = ();
-$shift = "";
-%defs = ();
-$fnno = 1;
-$inf = "";
-@ibase = ();
-
-while ($_ = shift) {
-    if (/^-D(.*)$/) {
-        if ($1 ne "") {
-            $flag = $1;
-        } else {
-            $flag = shift;
-        }
-        $value = "";
-        ($flag, $value) = ($flag =~ /^([^=]+)(?:=(.+))?/);
-        die "no flag specified for -D\n"
-            unless $flag ne "";
-        die "flags may only contain letters, digits, hyphens, dashes and underscores\n"
-            unless $flag =~ /^[a-zA-Z0-9_-]+$/;
-        $defs{$flag} = $value;
-    } elsif (/^-I(.*)$/) {
-        push @ibase, $1 ne "" ? $1 : shift;
-    } elsif (/^-/) {
-        usage();
-    } else {
-        $in = $_, next unless defined $in;
-        $out = $_, next unless defined $out;
-        usage();
-    }
-}
-
-push @ibase, ".";
-
-if (defined $in) {
-    $inf = gensym();
-    open($inf, "<$in") or die "opening \"$in\": $!\n";
-    push @ibase, $1 if $in =~ m|^(.+)/[^/]+$|;
-} else {
-    $inf = \*STDIN;
-}
-
-if (defined $out) {
-    open(STDOUT, ">$out") or die "opening \"$out\": $!\n";
-}
-
-while(defined $inf) {
-INF: while(<$inf>) {
-    # Certain commands are discarded without further processing.
-    /^\@(?:
-         [a-z]+index            # @*index: useful only in complete manual
-         |need                  # @need: useful only in printed manual
-         |(?:end\s+)?group      # @group .. @end group: ditto
-         |page                  # @page: ditto
-         |node                  # @node: useful only in .info file
-         |(?:end\s+)?ifnottex   # @ifnottex .. @end ifnottex: use contents
-        )\b/x and next;
-
-    chomp;
-
-    # Look for filename and title markers.
-    /^\@setfilename\s+([^.]+)/ and $fn = $1, next;
-    /^\@settitle\s+([^.]+)/ and $tl = postprocess($1), next;
-
-    # Identify a man title but keep only the one we are interested in.
-    /^\@c\s+man\s+title\s+([A-Za-z0-9-]+)\s+(.+)/ and do {
-        if (exists $defs{$1}) {
-            $fn = $1;
-            $tl = postprocess($2);
-        }
-        next;
-    };
-
-    /^\@include\s+(.+)$/ and do {
-        push @instack, $inf;
-        $inf = gensym();
-
-        for (@ibase) {
-            open($inf, "<" . $_ . "/" . $1) and next INF;
-        }
-        die "cannot open $1: $!\n";
-    };
-
-    /^\@chapter\s+([A-Za-z ]+)/ and do {
-        # close old chapter
-        $chapters{$chapter_name} .= postprocess($chapter) if ($chapter_name);
-
-        # start new chapter
-        $chapter_name = $1, push (@chapters_sequence, $chapter_name) unless $skipping;
-        $chapters{$chapter_name} = "" unless exists $chapters{$chapter_name};
-        $chapter = "";
-        $output = 1;
-        next;
-    };
-
-    /^\@bye/ and do {
-        # close old chapter
-        $chapters{$chapter_name} .= postprocess($chapter) if ($chapter_name);
-        last INF;
-    };
-
-    # handle variables
-    /^\@set\s+([a-zA-Z0-9_-]+)\s*(.*)$/ and do {
-        $defs{$1} = $2;
-        next;
-    };
-    /^\@clear\s+([a-zA-Z0-9_-]+)/ and do {
-        delete $defs{$1};
-        next;
-    };
-
-    next unless $output;
-
-    # Discard comments.  (Can't do it above, because then we'd never see
-    # @c man lines.)
-    /^\@c\b/ and next;
-
-    # End-block handler goes up here because it needs to operate even
-    # if we are skipping.
-    /^\@end\s+([a-z]+)/ and do {
-        # Ignore @end foo, where foo is not an operation which may
-        # cause us to skip, if we are presently skipping.
-        my $ended = $1;
-        next if $skipping && $ended !~ /^(?:ifset|ifclear|ignore|menu|iftex|ifhtml|ifnothtml)$/;
-
-        die "\@end $ended without \@$ended at line $.\n" unless defined $endw;
-        die "\@$endw ended by \@end $ended at line $.\n" unless $ended eq $endw;
-
-        $endw = pop @endwstack;
-
-        if ($ended =~ /^(?:ifset|ifclear|ignore|menu|iftex|ifhtml|ifnothtml)$/) {
-            $skipping = pop @skstack;
-            next;
-        } elsif ($ended =~ /^(?:example|smallexample|display)$/) {
-            $shift = "";
-            $_ = "";        # need a paragraph break
-        } elsif ($ended =~ /^(?:itemize|enumerate|(?:multi|[fv])?table)$/) {
-            $_ = "\n=back\n";
-            $ic = pop @icstack;
-        } else {
-            die "unknown command \@end $ended at line $.\n";
-        }
-    };
-
-    # We must handle commands which can cause skipping even while we
-    # are skipping, otherwise we will not process nested conditionals
-    # correctly.
-    /^\@ifset\s+([a-zA-Z0-9_-]+)/ and do {
-        push @endwstack, $endw;
-        push @skstack, $skipping;
-        $endw = "ifset";
-        $skipping = 1 unless exists $defs{$1};
-        next;
-    };
-
-    /^\@ifclear\s+([a-zA-Z0-9_-]+)/ and do {
-        push @endwstack, $endw;
-        push @skstack, $skipping;
-        $endw = "ifclear";
-        $skipping = 1 if exists $defs{$1};
-        next;
-    };
-
-    /^\@(ignore|menu|iftex|ifhtml|ifnothtml)\b/ and do {
-        push @endwstack, $endw;
-        push @skstack, $skipping;
-        $endw = $1;
-        $skipping = $endw !~ /ifnothtml/;
-        next;
-    };
-
-    next if $skipping;
-
-    # Character entities.  First the ones that can be replaced by raw text
-    # or discarded outright:
-    s/\@copyright\{\}/(c)/g;
-    s/\@dots\{\}/.../g;
-    s/\@enddots\{\}/..../g;
-    s/\@([.!? ])/$1/g;
-    s/\@[:-]//g;
-    s/\@bullet(?:\{\})?/*/g;
-    s/\@TeX\{\}/TeX/g;
-    s/\@pounds\{\}/\#/g;
-    s/\@minus(?:\{\})?/-/g;
-
-    # Now the ones that have to be replaced by special escapes
-    # (which will be turned back into text by unmunge())
-    s/&/&amp;/g;
-    s/\@\{/&lbrace;/g;
-    s/\@\}/&rbrace;/g;
-    s/\@\@/&at;/g;
-
-    # Inside a verbatim block, handle @var specially.
-    if ($shift ne "") {
-        s/\@var\{([^\}]*)\}/<$1>/g;
-    }
-
-    # POD doesn't interpret E<> inside a verbatim block.
-    if ($shift eq "") {
-        s/</&lt;/g;
-        s/>/&gt;/g;
-    } else {
-        s/</&LT;/g;
-        s/>/&GT;/g;
-    }
-
-    # Single line command handlers.
-
-    /^\@(?:section|unnumbered|unnumberedsec|center|heading)\s+(.+)$/
-        and $_ = "\n=head2 $1\n";
-    /^\@(?:subsection|subheading)\s+(.+)$/
-        and $_ = "\n=head3 $1\n";
-    /^\@(?:subsubsection|subsubheading)\s+(.+)$/
-        and $_ = "\n=head4 $1\n";
-
-    # Block command handlers:
-    /^\@itemize\s*(\@[a-z]+|\*|-)?/ and do {
-        push @endwstack, $endw;
-        push @icstack, $ic;
-        $ic = $1 ? $1 : "*";
-        $_ = "\n=over 4\n";
-        $endw = "itemize";
-    };
-
-    /^\@enumerate(?:\s+([a-zA-Z0-9]+))?/ and do {
-        push @endwstack, $endw;
-        push @icstack, $ic;
-        if (defined $1) {
-            $ic = $1 . ".";
-        } else {
-            $ic = "1.";
-        }
-        $_ = "\n=over 4\n";
-        $endw = "enumerate";
-    };
-
-    /^\@((?:multi|[fv])?table)\s+(\@[a-z]+)/ and do {
-        push @endwstack, $endw;
-        push @icstack, $ic;
-        $endw = $1;
-        $ic = $2;
-        $ic =~ s/\@(?:samp|strong|key|gcctabopt|option|env|command)/B/;
-        $ic =~ s/\@(?:code|kbd)/C/;
-        $ic =~ s/\@(?:dfn|var|emph|cite|i)/I/;
-        $ic =~ s/\@(?:file)/F/;
-        $ic =~ s/\@(?:columnfractions)//;
-        $_ = "\n=over 4\n";
-    };
-
-    /^\@((?:small)?example|display)/ and do {
-        push @endwstack, $endw;
-        $endw = $1;
-        $shift = "\t";
-        $_ = "";        # need a paragraph break
-    };
-
-    /^\@item\s+(.*\S)\s*$/ and $endw eq "multitable" and do {
-        my $columns = $1;
-        $columns =~ s/\@tab/ : /;
-
-        $_ = "\n=item B&LT;". $columns ."&GT;\n";
-    };
-
-    /^\@tab\s+(.*\S)\s*$/ and $endw eq "multitable" and do {
-        my $columns = $1;
-        $columns =~ s/\@tab/ : /;
-
-        $_ = " : ". $columns;
-        $chapter =~ s/\n+\s+$//;
-    };
-
-    /^\@itemx?\s*(.+)?$/ and do {
-        if (defined $1) {
-            # Entity escapes prevent munging by the <> processing below.
-            $_ = "\n=item $ic\&LT;$1\&GT;\n";
-        } else {
-            $_ = "\n=item $ic\n";
-            $ic =~ y/A-Ya-y/B-Zb-z/;
-            $ic =~ s/(\d+)/$1 + 1/eg;
-        }
-    };
-
-    $chapter .= $shift.$_."\n";
-}
-# End of current file.
-close($inf);
-$inf = pop @instack;
-}
-
-die "No filename or title\n" unless defined $fn && defined $tl;
-
-$chapters{NAME} = "$fn \- $tl\n";
-$chapters{FOOTNOTES} .= "=back\n" if exists $chapters{FOOTNOTES};
-
-unshift @chapters_sequence, "NAME";
-for $chapter (@chapters_sequence) {
-    # always use utf8
-    print "=encoding utf8\n";
-    if (exists $chapters{$chapter}) {
-        $head = uc($chapter);
-        print "=head1 $head\n\n";
-        print scalar unmunge ($chapters{$chapter});
-        print "\n";
-    }
-}
-
-sub usage
-{
-    die "usage: $0 [-D toggle...] [infile [outfile]]\n";
-}
-
-sub postprocess
-{
-    local $_ = $_[0];
-
-    # @value{foo} is replaced by whatever 'foo' is defined as.
-    while (m/(\@value\{([a-zA-Z0-9_-]+)\})/g) {
-        if (! exists $defs{$2}) {
-            print STDERR "Option $2 not defined\n";
-            s/\Q$1\E//;
-        } else {
-            $value = $defs{$2};
-            s/\Q$1\E/$value/;
-        }
-    }
-
-    # Formatting commands.
-    # Temporary escape for @r.
-    s/\@r\{([^\}]*)\}/R<$1>/g;
-    s/\@(?:dfn|var|emph|cite|i)\{([^\}]*)\}/I<$1>/g;
-    s/\@(?:code|kbd)\{([^\}]*)\}/C<$1>/g;
-    s/\@(?:gccoptlist|samp|strong|key|option|env|command|b)\{([^\}]*)\}/B<$1>/g;
-    s/\@sc\{([^\}]*)\}/\U$1/g;
-    s/\@file\{([^\}]*)\}/F<$1>/g;
-    s/\@w\{([^\}]*)\}/S<$1>/g;
-    s/\@(?:dmn|math)\{([^\}]*)\}/$1/g;
-
-    # Cross references are thrown away, as are @noindent and @refill.
-    # (@noindent is impossible in .pod, and @refill is unnecessary.)
-    # @* is also impossible in .pod; we discard it and any newline that
-    # follows it.  Similarly, our macro @gol must be discarded.
-
-    s/\@anchor{(?:[^\}]*)\}//g;
-    s/\(?\@xref\{(?:[^\}]*)\}(?:[^.<]|(?:<[^<>]*>))*\.\)?//g;
-    s/\s+\(\@pxref\{(?:[^\}]*)\}\)//g;
-    s/;\s+\@pxref\{(?:[^\}]*)\}//g;
-    s/\@ref\{(?:[^,\}]*,)(?:[^,\}]*,)([^,\}]*).*\}/B<$1>/g;
-    s/\@ref\{([^\}]*)\}/B<$1>/g;
-    s/\@noindent\s*//g;
-    s/\@refill//g;
-    s/\@gol//g;
-    s/\@\*\s*\n?//g;
-
-    # @uref can take one, two, or three arguments, with different
-    # semantics each time.  @url and @email are just like @uref with
-    # one argument, for our purposes.
-    s/\@(?:uref|url|email)\{([^\},]*),?[^\}]*\}/&lt;B<$1>&gt;/g;
-    s/\@uref\{([^\},]*),([^\},]*)\}/$2 (C<$1>)/g;
-    s/\@uref\{([^\},]*),([^\},]*),([^\},]*)\}/$3/g;
-
-    # Turn B<blah I<blah> blah> into B<blah> I<blah> B<blah> to
-    # match Texinfo semantics of @emph inside @samp.  Also handle @r
-    # inside bold.
-    s/&LT;/</g;
-    s/&GT;/>/g;
-    1 while s/B<((?:[^<>]|I<[^<>]*>)*)R<([^>]*)>/B<$1>${2}B</g;
-    1 while (s/B<([^<>]*)I<([^>]+)>/B<$1>I<$2>B</g);
-    1 while (s/I<([^<>]*)B<([^>]+)>/I<$1>B<$2>I</g);
-    s/[BI]<>//g;
-    s/([BI])<(\s+)([^>]+)>/$2$1<$3>/g;
-    s/([BI])<([^>]+?)(\s+)>/$1<$2>$3/g;
-
-    # Extract footnotes.  This has to be done after all other
-    # processing because otherwise the regexp will choke on formatting
-    # inside @footnote.
-    while (/\@footnote/g) {
-        s/\@footnote\{([^\}]+)\}/[$fnno]/;
-        add_footnote($1, $fnno);
-        $fnno++;
-    }
-
-    return $_;
-}
-
-sub unmunge
-{
-    # Replace escaped symbols with their equivalents.
-    local $_ = $_[0];
-
-    s/&lt;/E<lt>/g;
-    s/&gt;/E<gt>/g;
-    s/&lbrace;/\{/g;
-    s/&rbrace;/\}/g;
-    s/&at;/\@/g;
-    s/&amp;/&/g;
-    return $_;
-}
-
-sub add_footnote
-{
-    unless (exists $chapters{FOOTNOTES}) {
-        $chapters{FOOTNOTES} = "\n=over 4\n\n";
-    }
-
-    $chapters{FOOTNOTES} .= "=item $fnno.\n\n"; $fnno++;
-    $chapters{FOOTNOTES} .= $_[0];
-    $chapters{FOOTNOTES} .= "\n\n";
-}
-
-# stolen from Symbol.pm
-{
-    my $genseq = 0;
-    sub gensym
-    {
-        my $name = "GEN" . $genseq++;
-        my $ref = \*{$name};
-        delete $::{$name};
-        return $ref;
-    }
-}
diff --git a/libavcodec/libutvideodec.cpp b/libavcodec/libutvideodec.cpp
deleted file mode 100644
index 60dbd15..0000000
--- a/libavcodec/libutvideodec.cpp
+++ /dev/null
@@ -1,212 +0,0 @@
-/*
- * Copyright (c) 2011 Derek Buitenhuis
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public
- * License as published by the Free Software Foundation;
- * version 2 of the License.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * Known FOURCCs:
- *     'ULY0' (YCbCr 4:2:0), 'ULY2' (YCbCr 4:2:2), 'ULRG' (RGB), 'ULRA' (RGBA),
- *     'ULH0' (YCbCr 4:2:0 BT.709), 'ULH2' (YCbCr 4:2:2 BT.709)
- */
-
-extern "C" {
-#include "avcodec.h"
-}
-
-#include "libutvideo.h"
-#include "get_bits.h"
-
-static av_cold int utvideo_decode_init(AVCodecContext *avctx)
-{
-    UtVideoContext *utv = (UtVideoContext *)avctx->priv_data;
-    UtVideoExtra info;
-    int format;
-    int begin_ret;
-
-    if (avctx->extradata_size != 4*4) {
-        av_log(avctx, AV_LOG_ERROR, "Extradata size mismatch.\n");
-        return -1;
-    }
-
-    /* Read extradata */
-    info.version = AV_RL32(avctx->extradata);
-    info.original_format = AV_RL32(avctx->extradata + 4);
-    info.frameinfo_size = AV_RL32(avctx->extradata + 8);
-    info.flags = AV_RL32(avctx->extradata + 12);
-
-    /* Pick format based on FOURCC */
-    switch (avctx->codec_tag) {
-#ifdef UTV_BT709
-    case MKTAG('U', 'L', 'H', '0'):
-        avctx->pix_fmt = AV_PIX_FMT_YUV420P;
-        avctx->colorspace = AVCOL_SPC_BT709;
-        format = UTVF_YV12;
-        break;
-    case MKTAG('U', 'L', 'H', '2'):
-        avctx->pix_fmt = AV_PIX_FMT_YUYV422;
-        avctx->colorspace = AVCOL_SPC_BT709;
-        format = UTVF_YUY2;
-        break;
-#endif
-    case MKTAG('U', 'L', 'Y', '0'):
-        avctx->pix_fmt = AV_PIX_FMT_YUV420P;
-        format = UTVF_YV12;
-        break;
-    case MKTAG('U', 'L', 'Y', '2'):
-        avctx->pix_fmt = AV_PIX_FMT_YUYV422;
-        format = UTVF_YUY2;
-        break;
-    case MKTAG('U', 'L', 'R', 'G'):
-        avctx->pix_fmt = AV_PIX_FMT_BGR24;
-        format = UTVF_NFCC_BGR_BU;
-        break;
-    case MKTAG('U', 'L', 'R', 'A'):
-        avctx->pix_fmt = AV_PIX_FMT_RGB32;
-        format = UTVF_NFCC_BGRA_BU;
-        break;
-    default:
-        av_log(avctx, AV_LOG_ERROR,
-              "Not a Ut Video FOURCC: %X\n", avctx->codec_tag);
-        return -1;
-    }
-
-    /* Only allocate the buffer once */
-    utv->buf_size = avpicture_get_size(avctx->pix_fmt, avctx->width, avctx->height);
-    utv->buffer = (uint8_t *)av_malloc(utv->buf_size * sizeof(uint8_t));
-
-    if (utv->buffer == NULL) {
-        av_log(avctx, AV_LOG_ERROR, "Unable to allocate output buffer.\n");
-        return -1;
-    }
-
-    /* Allocate the output frame */
-    avctx->coded_frame = av_frame_alloc();
-
-    /* Ut Video only supports 8-bit */
-    avctx->bits_per_raw_sample = 8;
-
-    /* Is it interlaced? */
-    avctx->coded_frame->interlaced_frame = info.flags & 0x800 ? 1 : 0;
-
-    /* Apparently Ut Video doesn't store this info... */
-    avctx->coded_frame->top_field_first = 1;
-
-    /*
-     * Create a Ut Video instance. Since the function wants
-     * an "interface name" string, pass it the name of the lib.
-     */
-    utv->codec = CCodec::CreateInstance(UNFCC(avctx->codec_tag), "libavcodec");
-
-    /* Initialize Decoding */
-    begin_ret = utv->codec->DecodeBegin(format, avctx->width, avctx->height,
-                            CBGROSSWIDTH_WINDOWS, &info, sizeof(UtVideoExtra));
-
-    /* Check to see if the decoder initlized properly */
-    if (begin_ret != 0) {
-        av_log(avctx, AV_LOG_ERROR,
-               "Could not initialize decoder: %d\n", begin_ret);
-        return -1;
-    }
-
-    return 0;
-}
-
-static int utvideo_decode_frame(AVCodecContext *avctx, void *data,
-                                int *got_frame, AVPacket *avpkt)
-{
-    UtVideoContext *utv = (UtVideoContext *)avctx->priv_data;
-    AVFrame *pic = avctx->coded_frame;
-    int w = avctx->width, h = avctx->height;
-
-    /* Set flags */
-    pic->reference = 0;
-    pic->pict_type = AV_PICTURE_TYPE_I;
-    pic->key_frame = 1;
-
-    /* Decode the frame */
-    utv->codec->DecodeFrame(utv->buffer, avpkt->data, true);
-
-    /* Set the output data depending on the colorspace */
-    switch (avctx->pix_fmt) {
-    case AV_PIX_FMT_YUV420P:
-        pic->linesize[0] = w;
-        pic->linesize[1] = pic->linesize[2] = w / 2;
-        pic->data[0] = utv->buffer;
-        pic->data[2] = utv->buffer + (w * h);
-        pic->data[1] = pic->data[2] + (w * h / 4);
-        break;
-    case AV_PIX_FMT_YUYV422:
-        pic->linesize[0] = w * 2;
-        pic->data[0] = utv->buffer;
-        break;
-    case AV_PIX_FMT_BGR24:
-    case AV_PIX_FMT_RGB32:
-        /* Make the linesize negative, since Ut Video uses bottom-up BGR */
-        pic->linesize[0] = -1 * w * (avctx->pix_fmt == AV_PIX_FMT_BGR24 ? 3 : 4);
-        pic->data[0] = utv->buffer + utv->buf_size + pic->linesize[0];
-        break;
-    }
-
-    *got_frame = 1;
-    av_frame_move_ref((AVFrame*)data, pic);
-
-    return avpkt->size;
-}
-
-static av_cold int utvideo_decode_close(AVCodecContext *avctx)
-{
-    UtVideoContext *utv = (UtVideoContext *)avctx->priv_data;
-
-    /* Free output */
-    av_frame_free(&avctx->coded_frame);
-    av_freep(&utv->buffer);
-
-    /* Finish decoding and clean up the instance */
-    utv->codec->DecodeEnd();
-    CCodec::DeleteInstance(utv->codec);
-
-    return 0;
-}
-
-AVCodec ff_libutvideo_decoder = {
-    "libutvideo",
-    NULL_IF_CONFIG_SMALL("Ut Video"),
-    AVMEDIA_TYPE_VIDEO,
-    AV_CODEC_ID_UTVIDEO,
-    0,    //capabilities
-    NULL, //supported_framerates
-    NULL, //pix_fmts
-    NULL, //supported_samplerates
-    NULL, //sample_fmts
-    NULL, //channel_layouts
-    0,    //max_lowres
-    NULL, //priv_class
-    NULL, //profiles
-    sizeof(UtVideoContext),
-    NULL, //next
-    NULL, //init_thread_copy
-    NULL, //update_thread_context
-    NULL, //defaults
-    NULL, //init_static_data
-    utvideo_decode_init,
-    NULL, //encode
-    NULL, //encode2
-    utvideo_decode_frame,
-    utvideo_decode_close,
-};
diff --git a/libavcodec/libutvideoenc.cpp b/libavcodec/libutvideoenc.cpp
deleted file mode 100644
index f0d5619..0000000
--- a/libavcodec/libutvideoenc.cpp
+++ /dev/null
@@ -1,246 +0,0 @@
-/*
- * Copyright (c) 2012 Derek Buitenhuis
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public
- * License as published by the Free Software Foundation;
- * version 2 of the License.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * Known FOURCCs:
- *     'ULY0' (YCbCr 4:2:0), 'ULY2' (YCbCr 4:2:2), 'ULRG' (RGB), 'ULRA' (RGBA),
- *     'ULH0' (YCbCr 4:2:0 BT.709), 'ULH2' (YCbCr 4:2:2 BT.709)
- */
-
-extern "C" {
-#include "libavutil/avassert.h"
-#include "avcodec.h"
-#include "internal.h"
-}
-
-#include "libutvideo.h"
-#include "put_bits.h"
-
-static av_cold int utvideo_encode_init(AVCodecContext *avctx)
-{
-    UtVideoContext *utv = (UtVideoContext *)avctx->priv_data;
-    UtVideoExtra *info;
-    uint32_t flags, in_format;
-
-    switch (avctx->pix_fmt) {
-    case AV_PIX_FMT_YUV420P:
-        in_format = UTVF_YV12;
-        avctx->bits_per_coded_sample = 12;
-        if (avctx->colorspace == AVCOL_SPC_BT709)
-            avctx->codec_tag = MKTAG('U', 'L', 'H', '0');
-        else
-            avctx->codec_tag = MKTAG('U', 'L', 'Y', '0');
-        break;
-    case AV_PIX_FMT_YUYV422:
-        in_format = UTVF_YUYV;
-        avctx->bits_per_coded_sample = 16;
-        if (avctx->colorspace == AVCOL_SPC_BT709)
-            avctx->codec_tag = MKTAG('U', 'L', 'H', '2');
-        else
-            avctx->codec_tag = MKTAG('U', 'L', 'Y', '2');
-        break;
-    case AV_PIX_FMT_BGR24:
-        in_format = UTVF_NFCC_BGR_BU;
-        avctx->bits_per_coded_sample = 24;
-        avctx->codec_tag = MKTAG('U', 'L', 'R', 'G');
-        break;
-    case AV_PIX_FMT_RGB32:
-        in_format = UTVF_NFCC_BGRA_BU;
-        avctx->bits_per_coded_sample = 32;
-        avctx->codec_tag = MKTAG('U', 'L', 'R', 'A');
-        break;
-    default:
-        return AVERROR(EINVAL);
-    }
-
-    /* Check before we alloc anything */
-    if (avctx->prediction_method != 0 && avctx->prediction_method != 2) {
-        av_log(avctx, AV_LOG_ERROR, "Invalid prediction method.\n");
-        return AVERROR(EINVAL);
-    }
-
-    flags = ((avctx->prediction_method + 1) << 8) | (avctx->thread_count - 1);
-
-    avctx->priv_data = utv;
-    avctx->coded_frame = av_frame_alloc();
-
-    /* Alloc extradata buffer */
-    info = (UtVideoExtra *)av_malloc(sizeof(*info));
-
-    if (info == NULL) {
-        av_log(avctx, AV_LOG_ERROR, "Could not allocate extradata buffer.\n");
-        return AVERROR(ENOMEM);
-    }
-
-    /*
-     * We use this buffer to hold the data that Ut Video returns,
-     * since we cannot decode planes separately with it.
-     */
-    utv->buf_size = avpicture_get_size(avctx->pix_fmt,
-                                       avctx->width, avctx->height);
-    utv->buffer = (uint8_t *)av_malloc(utv->buf_size);
-
-    if (utv->buffer == NULL) {
-        av_log(avctx, AV_LOG_ERROR, "Could not allocate output buffer.\n");
-        return AVERROR(ENOMEM);
-    }
-
-    /*
-     * Create a Ut Video instance. Since the function wants
-     * an "interface name" string, pass it the name of the lib.
-     */
-    utv->codec = CCodec::CreateInstance(UNFCC(avctx->codec_tag), "libavcodec");
-
-    /* Initialize encoder */
-    utv->codec->EncodeBegin(in_format, avctx->width, avctx->height,
-                            CBGROSSWIDTH_WINDOWS);
-
-    /* Get extradata from encoder */
-    avctx->extradata_size = utv->codec->EncodeGetExtraDataSize();
-    utv->codec->EncodeGetExtraData(info, avctx->extradata_size, in_format,
-                                   avctx->width, avctx->height,
-                                   CBGROSSWIDTH_WINDOWS);
-    avctx->extradata = (uint8_t *)info;
-
-    /* Set flags */
-    utv->codec->SetState(&flags, sizeof(flags));
-
-    return 0;
-}
-
-static int utvideo_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
-                                const AVFrame *pic, int *got_packet)
-{
-    UtVideoContext *utv = (UtVideoContext *)avctx->priv_data;
-    int w = avctx->width, h = avctx->height;
-    int ret, rgb_size, i;
-    bool keyframe;
-    uint8_t *y, *u, *v;
-    uint8_t *dst;
-
-    /* Alloc buffer */
-    if ((ret = ff_alloc_packet2(avctx, pkt, utv->buf_size)) < 0)
-        return ret;
-
-    dst = pkt->data;
-
-    /* Move input if needed data into Ut Video friendly buffer */
-    switch (avctx->pix_fmt) {
-    case AV_PIX_FMT_YUV420P:
-        y = utv->buffer;
-        u = y + w * h;
-        v = u + w * h / 4;
-        for (i = 0; i < h; i++) {
-            memcpy(y, pic->data[0] + i * pic->linesize[0], w);
-            y += w;
-        }
-        for (i = 0; i < h / 2; i++) {
-            memcpy(u, pic->data[2] + i * pic->linesize[2], w >> 1);
-            memcpy(v, pic->data[1] + i * pic->linesize[1], w >> 1);
-            u += w >> 1;
-            v += w >> 1;
-        }
-        break;
-    case AV_PIX_FMT_YUYV422:
-        for (i = 0; i < h; i++)
-            memcpy(utv->buffer + i * (w << 1),
-                   pic->data[0] + i * pic->linesize[0], w << 1);
-        break;
-    case AV_PIX_FMT_BGR24:
-    case AV_PIX_FMT_RGB32:
-        /* Ut Video takes bottom-up BGR */
-        rgb_size = avctx->pix_fmt == AV_PIX_FMT_BGR24 ? 3 : 4;
-        for (i = 0; i < h; i++)
-            memcpy(utv->buffer + (h - i - 1) * w * rgb_size,
-                   pic->data[0] + i * pic->linesize[0],
-                   w * rgb_size);
-        break;
-    default:
-        return AVERROR(EINVAL);
-    }
-
-    /* Encode frame */
-    pkt->size = utv->codec->EncodeFrame(dst, &keyframe, utv->buffer);
-
-    if (!pkt->size) {
-        av_log(avctx, AV_LOG_ERROR, "EncodeFrame failed!\n");
-        return AVERROR_INVALIDDATA;
-    }
-
-    /*
-     * Ut Video is intra-only and every frame is a keyframe,
-     * and the API always returns true. In case something
-     * durastic changes in the future, such as inter support,
-     * assert that this is true.
-     */
-    av_assert2(keyframe == true);
-    avctx->coded_frame->key_frame = 1;
-    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;
-
-    pkt->flags |= AV_PKT_FLAG_KEY;
-    *got_packet = 1;
-    return 0;
-}
-
-static av_cold int utvideo_encode_close(AVCodecContext *avctx)
-{
-    UtVideoContext *utv = (UtVideoContext *)avctx->priv_data;
-
-    av_freep(&avctx->coded_frame);
-    av_freep(&avctx->extradata);
-    av_freep(&utv->buffer);
-
-    utv->codec->EncodeEnd();
-    CCodec::DeleteInstance(utv->codec);
-
-    return 0;
-}
-
-AVCodec ff_libutvideo_encoder = {
-    "libutvideo",
-    NULL_IF_CONFIG_SMALL("Ut Video"),
-    AVMEDIA_TYPE_VIDEO,
-    AV_CODEC_ID_UTVIDEO,
-    CODEC_CAP_AUTO_THREADS | CODEC_CAP_LOSSLESS,
-    NULL, /* supported_framerates */
-    (const enum AVPixelFormat[]) {
-        AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUYV422, AV_PIX_FMT_BGR24,
-        AV_PIX_FMT_RGB32, AV_PIX_FMT_NONE
-    },
-    NULL, /* supported_samplerates */
-    NULL, /* sample_fmts */
-    NULL, /* channel_layouts */
-    0,    /* max_lowres */
-    NULL, /* priv_class */
-    NULL, /* profiles */
-    sizeof(UtVideoContext),
-    NULL, /* next */
-    NULL, /* init_thread_copy */
-    NULL, /* update_thread_context */
-    NULL, /* defaults */
-    NULL, /* init_static_data */
-    utvideo_encode_init,
-    NULL, /* encode */
-    utvideo_encode_frame,
-    NULL, /* decode */
-    utvideo_encode_close,
-    NULL, /* flush */
-};
diff --git a/libavcodec/x86/idct_mmx_xvid.c b/libavcodec/x86/idct_mmx_xvid.c
deleted file mode 100644
index 4cd6de1..0000000
--- a/libavcodec/x86/idct_mmx_xvid.c
+++ /dev/null
@@ -1,562 +0,0 @@
-/*
- * XVID MPEG-4 VIDEO CODEC
- * - MMX and XMM forward discrete cosine transform -
- *
- * Copyright(C) 2001 Peter Ross <pross@xvid.org>
- *
- * Originally provided by Intel at AP-922
- * http://developer.intel.com/vtune/cbts/strmsimd/922down.htm
- * (See more app notes at http://developer.intel.com/vtune/cbts/strmsimd/appnotes.htm)
- * but in a limited edition.
- * New macro implements a column part for precise iDCT
- * The routine precision now satisfies IEEE standard 1180-1990.
- *
- * Copyright(C) 2000-2001 Peter Gubanov <peter@elecard.net.ru>
- * Rounding trick Copyright(C) 2000 Michel Lespinasse <walken@zoy.org>
- *
- * http://www.elecard.com/peter/idct.html
- * http://www.linuxvideo.org/mpeg2dec/
- *
- * These examples contain code fragments for first stage iDCT 8x8
- * (for rows) and first stage DCT 8x8 (for columns)
- *
- * conversion to gcc syntax by Michael Niedermayer
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with FFmpeg; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include <inttypes.h>
-
-#include "config.h"
-#include "libavcodec/avcodec.h"
-#include "libavutil/mem.h"
-#include "dsputil_x86.h"
-#include "idct_xvid.h"
-
-#if HAVE_MMX_INLINE
-
-//=============================================================================
-// Macros and other preprocessor constants
-//=============================================================================
-
-#define BITS_INV_ACC    5                              // 4 or 5 for IEEE
-#define SHIFT_INV_ROW   (16 - BITS_INV_ACC) //11
-#define SHIFT_INV_COL   (1 + BITS_INV_ACC) //6
-#define RND_INV_ROW     (1024 * (6 - BITS_INV_ACC))
-#define RND_INV_COL     (16 * (BITS_INV_ACC - 3))
-#define RND_INV_CORR    (RND_INV_COL - 1)
-
-#define BITS_FRW_ACC    3                              // 2 or 3 for accuracy
-#define SHIFT_FRW_COL   BITS_FRW_ACC
-#define SHIFT_FRW_ROW   (BITS_FRW_ACC + 17)
-#define RND_FRW_ROW     (262144*(BITS_FRW_ACC - 1))
-
-
-//-----------------------------------------------------------------------------
-// Various memory constants (trigonometric values or rounding values)
-//-----------------------------------------------------------------------------
-
-
-DECLARE_ALIGNED(8, static const int16_t, tg_1_16)[4*4] = {
-  13036,13036,13036,13036,        // tg * (2<<16) + 0.5
-  27146,27146,27146,27146,        // tg * (2<<16) + 0.5
-  -21746,-21746,-21746,-21746,    // tg * (2<<16) + 0.5
-  23170,23170,23170,23170};       // cos * (2<<15) + 0.5
-
-DECLARE_ALIGNED(8, static const int32_t, rounder_0)[2*8] = {
-  65536,65536,
-  3597,3597,
-  2260,2260,
-  1203,1203,
-  0,0,
-  120,120,
-  512,512,
-  512,512};
-
-//-----------------------------------------------------------------------------
-//
-// The first stage iDCT 8x8 - inverse DCTs of rows
-//
-//-----------------------------------------------------------------------------
-// The 8-point inverse DCT direct algorithm
-//-----------------------------------------------------------------------------
-//
-// static const short w[32] = {
-//       FIX(cos_4_16),  FIX(cos_2_16),  FIX(cos_4_16),  FIX(cos_6_16),
-//       FIX(cos_4_16),  FIX(cos_6_16), -FIX(cos_4_16), -FIX(cos_2_16),
-//       FIX(cos_4_16), -FIX(cos_6_16), -FIX(cos_4_16),  FIX(cos_2_16),
-//       FIX(cos_4_16), -FIX(cos_2_16),  FIX(cos_4_16), -FIX(cos_6_16),
-//       FIX(cos_1_16),  FIX(cos_3_16),  FIX(cos_5_16),  FIX(cos_7_16),
-//       FIX(cos_3_16), -FIX(cos_7_16), -FIX(cos_1_16), -FIX(cos_5_16),
-//       FIX(cos_5_16), -FIX(cos_1_16),  FIX(cos_7_16),  FIX(cos_3_16),
-//       FIX(cos_7_16), -FIX(cos_5_16),  FIX(cos_3_16), -FIX(cos_1_16) };
-//
-// #define DCT_8_INV_ROW(x, y)
-// {
-//       int a0, a1, a2, a3, b0, b1, b2, b3;
-//
-//       a0 =x[0]*w[0]+x[2]*w[1]+x[4]*w[2]+x[6]*w[3];
-//       a1 =x[0]*w[4]+x[2]*w[5]+x[4]*w[6]+x[6]*w[7];
-//       a2 = x[0] * w[ 8] + x[2] * w[ 9] + x[4] * w[10] + x[6] * w[11];
-//       a3 = x[0] * w[12] + x[2] * w[13] + x[4] * w[14] + x[6] * w[15];
-//       b0 = x[1] * w[16] + x[3] * w[17] + x[5] * w[18] + x[7] * w[19];
-//       b1 = x[1] * w[20] + x[3] * w[21] + x[5] * w[22] + x[7] * w[23];
-//       b2 = x[1] * w[24] + x[3] * w[25] + x[5] * w[26] + x[7] * w[27];
-//       b3 = x[1] * w[28] + x[3] * w[29] + x[5] * w[30] + x[7] * w[31];
-//
-//       y[0] = SHIFT_ROUND ( a0 + b0 );
-//       y[1] = SHIFT_ROUND ( a1 + b1 );
-//       y[2] = SHIFT_ROUND ( a2 + b2 );
-//       y[3] = SHIFT_ROUND ( a3 + b3 );
-//       y[4] = SHIFT_ROUND ( a3 - b3 );
-//       y[5] = SHIFT_ROUND ( a2 - b2 );
-//       y[6] = SHIFT_ROUND ( a1 - b1 );
-//       y[7] = SHIFT_ROUND ( a0 - b0 );
-// }
-//
-//-----------------------------------------------------------------------------
-//
-// In this implementation the outputs of the iDCT-1D are multiplied
-//       for rows 0,4 - by cos_4_16,
-//       for rows 1,7 - by cos_1_16,
-//       for rows 2,6 - by cos_2_16,
-//       for rows 3,5 - by cos_3_16
-// and are shifted to the left for better accuracy
-//
-// For the constants used,
-//       FIX(float_const) = (short) (float_const * (1<<15) + 0.5)
-//
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// Tables for mmx processors
-//-----------------------------------------------------------------------------
-
-// Table for rows 0,4 - constants are multiplied by cos_4_16
-DECLARE_ALIGNED(8, static const int16_t, tab_i_04_mmx)[32*4] = {
-  16384,16384,16384,-16384,       // movq-> w06 w04 w02 w00
-  21407,8867,8867,-21407,         // w07 w05 w03 w01
-  16384,-16384,16384,16384,       // w14 w12 w10 w08
-  -8867,21407,-21407,-8867,       // w15 w13 w11 w09
-  22725,12873,19266,-22725,       // w22 w20 w18 w16
-  19266,4520,-4520,-12873,        // w23 w21 w19 w17
-  12873,4520,4520,19266,          // w30 w28 w26 w24
-  -22725,19266,-12873,-22725,     // w31 w29 w27 w25
-// Table for rows 1,7 - constants are multiplied by cos_1_16
-  22725,22725,22725,-22725,       // movq-> w06 w04 w02 w00
-  29692,12299,12299,-29692,       // w07 w05 w03 w01
-  22725,-22725,22725,22725,       // w14 w12 w10 w08
-  -12299,29692,-29692,-12299,     // w15 w13 w11 w09
-  31521,17855,26722,-31521,       // w22 w20 w18 w16
-  26722,6270,-6270,-17855,        // w23 w21 w19 w17
-  17855,6270,6270,26722,          // w30 w28 w26 w24
-  -31521,26722,-17855,-31521,     // w31 w29 w27 w25
-// Table for rows 2,6 - constants are multiplied by cos_2_16
-  21407,21407,21407,-21407,       // movq-> w06 w04 w02 w00
-  27969,11585,11585,-27969,       // w07 w05 w03 w01
-  21407,-21407,21407,21407,       // w14 w12 w10 w08
-  -11585,27969,-27969,-11585,     // w15 w13 w11 w09
-  29692,16819,25172,-29692,       // w22 w20 w18 w16
-  25172,5906,-5906,-16819,        // w23 w21 w19 w17
-  16819,5906,5906,25172,          // w30 w28 w26 w24
-  -29692,25172,-16819,-29692,     // w31 w29 w27 w25
-// Table for rows 3,5 - constants are multiplied by cos_3_16
-  19266,19266,19266,-19266,       // movq-> w06 w04 w02 w00
-  25172,10426,10426,-25172,       // w07 w05 w03 w01
-  19266,-19266,19266,19266,       // w14 w12 w10 w08
-  -10426,25172,-25172,-10426,     // w15 w13 w11 w09
-  26722,15137,22654,-26722,       // w22 w20 w18 w16
-  22654,5315,-5315,-15137,        // w23 w21 w19 w17
-  15137,5315,5315,22654,          // w30 w28 w26 w24
-  -26722,22654,-15137,-26722,     // w31 w29 w27 w25
-};
-//-----------------------------------------------------------------------------
-// Tables for xmm processors
-//-----------------------------------------------------------------------------
-
-// %3 for rows 0,4 - constants are multiplied by cos_4_16
-DECLARE_ALIGNED(8, static const int16_t, tab_i_04_xmm)[32*4] = {
-  16384,21407,16384,8867,      // movq-> w05 w04 w01 w00
-  16384,8867,-16384,-21407,    // w07 w06 w03 w02
-  16384,-8867,16384,-21407,    // w13 w12 w09 w08
-  -16384,21407,16384,-8867,    // w15 w14 w11 w10
-  22725,19266,19266,-4520,     // w21 w20 w17 w16
-  12873,4520,-22725,-12873,    // w23 w22 w19 w18
-  12873,-22725,4520,-12873,    // w29 w28 w25 w24
-  4520,19266,19266,-22725,     // w31 w30 w27 w26
-// %3 for rows 1,7 - constants are multiplied by cos_1_16
-  22725,29692,22725,12299,     // movq-> w05 w04 w01 w00
-  22725,12299,-22725,-29692,   // w07 w06 w03 w02
-  22725,-12299,22725,-29692,   // w13 w12 w09 w08
-  -22725,29692,22725,-12299,   // w15 w14 w11 w10
-  31521,26722,26722,-6270,     // w21 w20 w17 w16
-  17855,6270,-31521,-17855,    // w23 w22 w19 w18
-  17855,-31521,6270,-17855,    // w29 w28 w25 w24
-  6270,26722,26722,-31521,     // w31 w30 w27 w26
-// %3 for rows 2,6 - constants are multiplied by cos_2_16
-  21407,27969,21407,11585,     // movq-> w05 w04 w01 w00
-  21407,11585,-21407,-27969,   // w07 w06 w03 w02
-  21407,-11585,21407,-27969,   // w13 w12 w09 w08
-  -21407,27969,21407,-11585,   // w15 w14 w11 w10
-  29692,25172,25172,-5906,     // w21 w20 w17 w16
-  16819,5906,-29692,-16819,    // w23 w22 w19 w18
-  16819,-29692,5906,-16819,    // w29 w28 w25 w24
-  5906,25172,25172,-29692,     // w31 w30 w27 w26
-// %3 for rows 3,5 - constants are multiplied by cos_3_16
-  19266,25172,19266,10426,     // movq-> w05 w04 w01 w00
-  19266,10426,-19266,-25172,   // w07 w06 w03 w02
-  19266,-10426,19266,-25172,   // w13 w12 w09 w08
-  -19266,25172,19266,-10426,   // w15 w14 w11 w10
-  26722,22654,22654,-5315,     // w21 w20 w17 w16
-  15137,5315,-26722,-15137,    // w23 w22 w19 w18
-  15137,-26722,5315,-15137,    // w29 w28 w25 w24
-  5315,22654,22654,-26722,     // w31 w30 w27 w26
-};
-//=============================================================================
-// Helper macros for the code
-//=============================================================================
-
-//-----------------------------------------------------------------------------
-// DCT_8_INV_ROW_MMX( INP, OUT, TABLE, ROUNDER
-//-----------------------------------------------------------------------------
-
-#define DCT_8_INV_ROW_MMX(A1,A2,A3,A4)\
-  "movq " #A1 ",%%mm0              \n\t"/* 0 ; x3 x2 x1 x0*/\
-  "movq 8+" #A1 ",%%mm1            \n\t"/* 1 ; x7 x6 x5 x4*/\
-  "movq %%mm0,%%mm2            \n\t"/* 2  ; x3 x2 x1 x0*/\
-  "movq " #A3 ",%%mm3              \n\t"/* 3 ; w06 w04 w02 w00*/\
-  "punpcklwd %%mm1,%%mm0       \n\t"/* x5 x1 x4 x0*/\
-  "movq %%mm0,%%mm5            \n\t"/* 5 ; x5 x1 x4 x0*/\
-  "punpckldq %%mm0,%%mm0       \n\t"/* x4 x0 x4 x0*/\
-  "movq 8+" #A3 ",%%mm4            \n\t"/* 4 ; w07 w05 w03 w01*/\
-  "punpckhwd %%mm1,%%mm2       \n\t"/* 1 ; x7 x3 x6 x2*/\
-  "pmaddwd %%mm0,%%mm3         \n\t"/* x4*w06+x0*w04 x4*w02+x0*w00*/\
-  "movq %%mm2,%%mm6            \n\t"/* 6 ; x7 x3 x6 x2*/\
-  "movq 32+" #A3 ",%%mm1           \n\t"/* 1 ; w22 w20 w18 w16*/\
-  "punpckldq %%mm2,%%mm2       \n\t"/* x6 x2 x6 x2*/\
-  "pmaddwd %%mm2,%%mm4         \n\t"/* x6*w07+x2*w05 x6*w03+x2*w01*/\
-  "punpckhdq %%mm5,%%mm5       \n\t"/* x5 x1 x5 x1*/\
-  "pmaddwd 16+" #A3 ",%%mm0        \n\t"/* x4*w14+x0*w12 x4*w10+x0*w08*/\
-  "punpckhdq %%mm6,%%mm6       \n\t"/* x7 x3 x7 x3*/\
-  "movq 40+" #A3 ",%%mm7           \n\t"/* 7 ; w23 w21 w19 w17*/\
-  "pmaddwd %%mm5,%%mm1         \n\t"/* x5*w22+x1*w20 x5*w18+x1*w16*/\
-  "paddd " #A4 ",%%mm3             \n\t"/* +%4*/\
-  "pmaddwd %%mm6,%%mm7         \n\t"/* x7*w23+x3*w21 x7*w19+x3*w17*/\
-  "pmaddwd 24+" #A3 ",%%mm2        \n\t"/* x6*w15+x2*w13 x6*w11+x2*w09*/\
-  "paddd %%mm4,%%mm3           \n\t"/* 4 ; a1=sum(even1) a0=sum(even0)*/\
-  "pmaddwd 48+" #A3 ",%%mm5        \n\t"/* x5*w30+x1*w28 x5*w26+x1*w24*/\
-  "movq %%mm3,%%mm4            \n\t"/* 4 ; a1 a0*/\
-  "pmaddwd 56+" #A3 ",%%mm6        \n\t"/* x7*w31+x3*w29 x7*w27+x3*w25*/\
-  "paddd %%mm7,%%mm1           \n\t"/* 7 ; b1=sum(odd1) b0=sum(odd0)*/\
-  "paddd " #A4 ",%%mm0             \n\t"/* +%4*/\
-  "psubd %%mm1,%%mm3           \n\t"/* a1-b1 a0-b0*/\
-  "psrad $11,%%mm3 \n\t"/* y6=a1-b1 y7=a0-b0*/\
-  "paddd %%mm4,%%mm1           \n\t"/* 4 ; a1+b1 a0+b0*/\
-  "paddd %%mm2,%%mm0           \n\t"/* 2 ; a3=sum(even3) a2=sum(even2)*/\
-  "psrad $11,%%mm1 \n\t"/* y1=a1+b1 y0=a0+b0*/\
-  "paddd %%mm6,%%mm5           \n\t"/* 6 ; b3=sum(odd3) b2=sum(odd2)*/\
-  "movq %%mm0,%%mm4            \n\t"/* 4 ; a3 a2*/\
-  "paddd %%mm5,%%mm0           \n\t"/* a3+b3 a2+b2*/\
-  "psubd %%mm5,%%mm4           \n\t"/* 5 ; a3-b3 a2-b2*/\
-  "psrad $11,%%mm0 \n\t"/* y3=a3+b3 y2=a2+b2*/\
-  "psrad $11,%%mm4 \n\t"/* y4=a3-b3 y5=a2-b2*/\
-  "packssdw %%mm0,%%mm1        \n\t"/* 0 ; y3 y2 y1 y0*/\
-  "packssdw %%mm3,%%mm4        \n\t"/* 3 ; y6 y7 y4 y5*/\
-  "movq %%mm4,%%mm7            \n\t"/* 7 ; y6 y7 y4 y5*/\
-  "psrld $16,%%mm4            \n\t"/* 0 y6 0 y4*/\
-  "pslld $16,%%mm7            \n\t"/* y7 0 y5 0*/\
-  "movq %%mm1," #A2 "              \n\t"/* 1 ; save y3 y2 y1 y0*/\
-  "por %%mm4,%%mm7             \n\t"/* 4 ; y7 y6 y5 y4*/\
-  "movq %%mm7,8            +" #A2 "\n\t"/* 7 ; save y7 y6 y5 y4*/\
-
-
-//-----------------------------------------------------------------------------
-// DCT_8_INV_ROW_XMM( INP, OUT, TABLE, ROUNDER
-//-----------------------------------------------------------------------------
-
-#define DCT_8_INV_ROW_XMM(A1,A2,A3,A4)\
-  "movq " #A1 ",%%mm0                  \n\t"/* 0     ; x3 x2 x1 x0*/\
-  "movq 8+" #A1 ",%%mm1                \n\t"/* 1     ; x7 x6 x5 x4*/\
-  "movq %%mm0,%%mm2                \n\t"/* 2     ; x3 x2 x1 x0*/\
-  "movq " #A3 ",%%mm3                  \n\t"/* 3     ; w05 w04 w01 w00*/\
-  "pshufw $0x88,%%mm0,%%mm0        \n\t"/* x2 x0 x2 x0*/\
-  "movq 8+" #A3 ",%%mm4                \n\t"/* 4     ; w07 w06 w03 w02*/\
-  "movq %%mm1,%%mm5                \n\t"/* 5     ; x7 x6 x5 x4*/\
-  "pmaddwd %%mm0,%%mm3             \n\t"/* x2*w05+x0*w04 x2*w01+x0*w00*/\
-  "movq 32+" #A3 ",%%mm6               \n\t"/* 6     ; w21 w20 w17 w16*/\
-  "pshufw $0x88,%%mm1,%%mm1        \n\t"/* x6 x4 x6 x4*/\
-  "pmaddwd %%mm1,%%mm4             \n\t"/* x6*w07+x4*w06 x6*w03+x4*w02*/\
-  "movq 40+" #A3 ",%%mm7               \n\t"/* 7    ; w23 w22 w19 w18*/\
-  "pshufw $0xdd,%%mm2,%%mm2        \n\t"/* x3 x1 x3 x1*/\
-  "pmaddwd %%mm2,%%mm6             \n\t"/* x3*w21+x1*w20 x3*w17+x1*w16*/\
-  "pshufw $0xdd,%%mm5,%%mm5        \n\t"/* x7 x5 x7 x5*/\
-  "pmaddwd %%mm5,%%mm7             \n\t"/* x7*w23+x5*w22 x7*w19+x5*w18*/\
-  "paddd " #A4 ",%%mm3                 \n\t"/* +%4*/\
-  "pmaddwd 16+" #A3 ",%%mm0            \n\t"/* x2*w13+x0*w12 x2*w09+x0*w08*/\
-  "paddd %%mm4,%%mm3               \n\t"/* 4     ; a1=sum(even1) a0=sum(even0)*/\
-  "pmaddwd 24+" #A3 ",%%mm1            \n\t"/* x6*w15+x4*w14 x6*w11+x4*w10*/\
-  "movq %%mm3,%%mm4                \n\t"/* 4     ; a1 a0*/\
-  "pmaddwd 48+" #A3 ",%%mm2            \n\t"/* x3*w29+x1*w28 x3*w25+x1*w24*/\
-  "paddd %%mm7,%%mm6               \n\t"/* 7     ; b1=sum(odd1) b0=sum(odd0)*/\
-  "pmaddwd 56+" #A3 ",%%mm5            \n\t"/* x7*w31+x5*w30 x7*w27+x5*w26*/\
-  "paddd %%mm6,%%mm3               \n\t"/* a1+b1 a0+b0*/\
-  "paddd " #A4 ",%%mm0                 \n\t"/* +%4*/\
-  "psrad $11,%%mm3     \n\t"/* y1=a1+b1 y0=a0+b0*/\
-  "paddd %%mm1,%%mm0               \n\t"/* 1     ; a3=sum(even3) a2=sum(even2)*/\
-  "psubd %%mm6,%%mm4               \n\t"/* 6     ; a1-b1 a0-b0*/\
-  "movq %%mm0,%%mm7                \n\t"/* 7     ; a3 a2*/\
-  "paddd %%mm5,%%mm2               \n\t"/* 5     ; b3=sum(odd3) b2=sum(odd2)*/\
-  "paddd %%mm2,%%mm0               \n\t"/* a3+b3 a2+b2*/\
-  "psrad $11,%%mm4     \n\t"/* y6=a1-b1 y7=a0-b0*/\
-  "psubd %%mm2,%%mm7               \n\t"/* 2     ; a3-b3 a2-b2*/\
-  "psrad $11,%%mm0     \n\t"/* y3=a3+b3 y2=a2+b2*/\
-  "psrad $11,%%mm7     \n\t"/* y4=a3-b3 y5=a2-b2*/\
-  "packssdw %%mm0,%%mm3            \n\t"/* 0     ; y3 y2 y1 y0*/\
-  "packssdw %%mm4,%%mm7            \n\t"/* 4     ; y6 y7 y4 y5*/\
-  "movq %%mm3, " #A2 "                  \n\t"/* 3     ; save y3 y2 y1 y0*/\
-  "pshufw $0xb1,%%mm7,%%mm7        \n\t"/* y7 y6 y5 y4*/\
-  "movq %%mm7,8                +" #A2 "\n\t"/* 7     ; save y7 y6 y5 y4*/\
-
-
-//-----------------------------------------------------------------------------
-//
-// The first stage DCT 8x8 - forward DCTs of columns
-//
-// The %2puts are multiplied
-// for rows 0,4 - on cos_4_16,
-// for rows 1,7 - on cos_1_16,
-// for rows 2,6 - on cos_2_16,
-// for rows 3,5 - on cos_3_16
-// and are shifted to the left for rise of accuracy
-//
-//-----------------------------------------------------------------------------
-//
-// The 8-point scaled forward DCT algorithm (26a8m)
-//
-//-----------------------------------------------------------------------------
-//
-// #define DCT_8_FRW_COL(x, y)
-//{
-// short t0, t1, t2, t3, t4, t5, t6, t7;
-// short tp03, tm03, tp12, tm12, tp65, tm65;
-// short tp465, tm465, tp765, tm765;
-//
-// t0 = LEFT_SHIFT ( x[0] + x[7] );
-// t1 = LEFT_SHIFT ( x[1] + x[6] );
-// t2 = LEFT_SHIFT ( x[2] + x[5] );
-// t3 = LEFT_SHIFT ( x[3] + x[4] );
-// t4 = LEFT_SHIFT ( x[3] - x[4] );
-// t5 = LEFT_SHIFT ( x[2] - x[5] );
-// t6 = LEFT_SHIFT ( x[1] - x[6] );
-// t7 = LEFT_SHIFT ( x[0] - x[7] );
-//
-// tp03 = t0 + t3;
-// tm03 = t0 - t3;
-// tp12 = t1 + t2;
-// tm12 = t1 - t2;
-//
-// y[0] = tp03 + tp12;
-// y[4] = tp03 - tp12;
-//
-// y[2] = tm03 + tm12 * tg_2_16;
-// y[6] = tm03 * tg_2_16 - tm12;
-//
-// tp65 =(t6 +t5 )*cos_4_16;
-// tm65 =(t6 -t5 )*cos_4_16;
-//
-// tp765 = t7 + tp65;
-// tm765 = t7 - tp65;
-// tp465 = t4 + tm65;
-// tm465 = t4 - tm65;
-//
-// y[1] = tp765 + tp465 * tg_1_16;
-// y[7] = tp765 * tg_1_16 - tp465;
-// y[5] = tm765 * tg_3_16 + tm465;
-// y[3] = tm765 - tm465 * tg_3_16;
-//}
-//
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// DCT_8_INV_COL_4  INP,OUT
-//-----------------------------------------------------------------------------
-
-#define DCT_8_INV_COL(A1,A2)\
-  "movq 2*8(%3),%%mm0\n\t"\
-  "movq 16*3+" #A1 ",%%mm3\n\t"\
-  "movq %%mm0,%%mm1            \n\t"/* tg_3_16*/\
-  "movq 16*5+" #A1 ",%%mm5\n\t"\
-  "pmulhw %%mm3,%%mm0          \n\t"/* x3*(tg_3_16-1)*/\
-  "movq (%3),%%mm4\n\t"\
-  "pmulhw %%mm5,%%mm1          \n\t"/* x5*(tg_3_16-1)*/\
-  "movq 16*7+" #A1 ",%%mm7\n\t"\
-  "movq %%mm4,%%mm2            \n\t"/* tg_1_16*/\
-  "movq 16*1+" #A1 ",%%mm6\n\t"\
-  "pmulhw %%mm7,%%mm4          \n\t"/* x7*tg_1_16*/\
-  "paddsw %%mm3,%%mm0          \n\t"/* x3*tg_3_16*/\
-  "pmulhw %%mm6,%%mm2          \n\t"/* x1*tg_1_16*/\
-  "paddsw %%mm3,%%mm1          \n\t"/* x3+x5*(tg_3_16-1)*/\
-  "psubsw %%mm5,%%mm0          \n\t"/* x3*tg_3_16-x5 = tm35*/\
-  "movq 3*8(%3),%%mm3\n\t"\
-  "paddsw %%mm5,%%mm1          \n\t"/* x3+x5*tg_3_16 = tp35*/\
-  "paddsw %%mm6,%%mm4          \n\t"/* x1+tg_1_16*x7 = tp17*/\
-  "psubsw %%mm7,%%mm2          \n\t"/* x1*tg_1_16-x7 = tm17*/\
-  "movq %%mm4,%%mm5            \n\t"/* tp17*/\
-  "movq %%mm2,%%mm6            \n\t"/* tm17*/\
-  "paddsw %%mm1,%%mm5          \n\t"/* tp17+tp35 = b0*/\
-  "psubsw %%mm0,%%mm6          \n\t"/* tm17-tm35 = b3*/\
-  "psubsw %%mm1,%%mm4          \n\t"/* tp17-tp35 = t1*/\
-  "paddsw %%mm0,%%mm2          \n\t"/* tm17+tm35 = t2*/\
-  "movq 1*8(%3),%%mm7\n\t"\
-  "movq %%mm4,%%mm1            \n\t"/* t1*/\
-  "movq %%mm5,3*16         +" #A2 "\n\t"/* save b0*/\
-  "paddsw %%mm2,%%mm1          \n\t"/* t1+t2*/\
-  "movq %%mm6,5*16         +" #A2 "\n\t"/* save b3*/\
-  "psubsw %%mm2,%%mm4          \n\t"/* t1-t2*/\
-  "movq 2*16+" #A1 ",%%mm5\n\t"\
-  "movq %%mm7,%%mm0            \n\t"/* tg_2_16*/\
-  "movq 6*16+" #A1 ",%%mm6\n\t"\
-  "pmulhw %%mm5,%%mm0          \n\t"/* x2*tg_2_16*/\
-  "pmulhw %%mm6,%%mm7          \n\t"/* x6*tg_2_16*/\
-  "pmulhw %%mm3,%%mm1          \n\t"/* ocos_4_16*(t1+t2) = b1/2*/\
-  "movq 0*16+" #A1 ",%%mm2\n\t"\
-  "pmulhw %%mm3,%%mm4          \n\t"/* ocos_4_16*(t1-t2) = b2/2*/\
-  "psubsw %%mm6,%%mm0          \n\t"/* t2*tg_2_16-x6 = tm26*/\
-  "movq %%mm2,%%mm3            \n\t"/* x0*/\
-  "movq 4*16+" #A1 ",%%mm6\n\t"\
-  "paddsw %%mm5,%%mm7          \n\t"/* x2+x6*tg_2_16 = tp26*/\
-  "paddsw %%mm6,%%mm2          \n\t"/* x0+x4 = tp04*/\
-  "psubsw %%mm6,%%mm3          \n\t"/* x0-x4 = tm04*/\
-  "movq %%mm2,%%mm5            \n\t"/* tp04*/\
-  "movq %%mm3,%%mm6            \n\t"/* tm04*/\
-  "psubsw %%mm7,%%mm2          \n\t"/* tp04-tp26 = a3*/\
-  "paddsw %%mm0,%%mm3          \n\t"/* tm04+tm26 = a1*/\
-  "paddsw %%mm1,%%mm1          \n\t"/* b1*/\
-  "paddsw %%mm4,%%mm4          \n\t"/* b2*/\
-  "paddsw %%mm7,%%mm5          \n\t"/* tp04+tp26 = a0*/\
-  "psubsw %%mm0,%%mm6          \n\t"/* tm04-tm26 = a2*/\
-  "movq %%mm3,%%mm7            \n\t"/* a1*/\
-  "movq %%mm6,%%mm0            \n\t"/* a2*/\
-  "paddsw %%mm1,%%mm3          \n\t"/* a1+b1*/\
-  "paddsw %%mm4,%%mm6          \n\t"/* a2+b2*/\
-  "psraw $6,%%mm3 \n\t"/* dst1*/\
-  "psubsw %%mm1,%%mm7          \n\t"/* a1-b1*/\
-  "psraw $6,%%mm6 \n\t"/* dst2*/\
-  "psubsw %%mm4,%%mm0          \n\t"/* a2-b2*/\
-  "movq 3*16+" #A2 ",%%mm1         \n\t"/* load b0*/\
-  "psraw $6,%%mm7 \n\t"/* dst6*/\
-  "movq %%mm5,%%mm4            \n\t"/* a0*/\
-  "psraw $6,%%mm0 \n\t"/* dst5*/\
-  "movq %%mm3,1*16+" #A2 "\n\t"\
-  "paddsw %%mm1,%%mm5          \n\t"/* a0+b0*/\
-  "movq %%mm6,2*16+" #A2 "\n\t"\
-  "psubsw %%mm1,%%mm4          \n\t"/* a0-b0*/\
-  "movq 5*16+" #A2 ",%%mm3         \n\t"/* load b3*/\
-  "psraw $6,%%mm5 \n\t"/* dst0*/\
-  "movq %%mm2,%%mm6            \n\t"/* a3*/\
-  "psraw $6,%%mm4 \n\t"/* dst7*/\
-  "movq %%mm0,5*16+" #A2 "\n\t"\
-  "paddsw %%mm3,%%mm2          \n\t"/* a3+b3*/\
-  "movq %%mm7,6*16+" #A2 "\n\t"\
-  "psubsw %%mm3,%%mm6          \n\t"/* a3-b3*/\
-  "movq %%mm5,0*16+" #A2 "\n\t"\
-  "psraw $6,%%mm2 \n\t"/* dst3*/\
-  "movq %%mm4,7*16+" #A2 "\n\t"\
-  "psraw $6,%%mm6 \n\t"/* dst4*/\
-  "movq %%mm2,3*16+" #A2 "\n\t"\
-  "movq %%mm6,4*16+" #A2 "\n\t"
-
-//=============================================================================
-// Code
-//=============================================================================
-
-//-----------------------------------------------------------------------------
-// void idct_mmx(uint16_t block[64]);
-//-----------------------------------------------------------------------------
-
-
-void ff_idct_xvid_mmx(short *block){
-__asm__ volatile(
-            //# Process each row
-    DCT_8_INV_ROW_MMX(0*16(%0), 0*16(%0), 64*0(%2), 8*0(%1))
-    DCT_8_INV_ROW_MMX(1*16(%0), 1*16(%0), 64*1(%2), 8*1(%1))
-    DCT_8_INV_ROW_MMX(2*16(%0), 2*16(%0), 64*2(%2), 8*2(%1))
-    DCT_8_INV_ROW_MMX(3*16(%0), 3*16(%0), 64*3(%2), 8*3(%1))
-    DCT_8_INV_ROW_MMX(4*16(%0), 4*16(%0), 64*0(%2), 8*4(%1))
-    DCT_8_INV_ROW_MMX(5*16(%0), 5*16(%0), 64*3(%2), 8*5(%1))
-    DCT_8_INV_ROW_MMX(6*16(%0), 6*16(%0), 64*2(%2), 8*6(%1))
-    DCT_8_INV_ROW_MMX(7*16(%0), 7*16(%0), 64*1(%2), 8*7(%1))
-
-            //# Process the columns (4 at a time)
-    DCT_8_INV_COL(0(%0), 0(%0))
-    DCT_8_INV_COL(8(%0), 8(%0))
-    :: "r"(block), "r"(rounder_0), "r"(tab_i_04_mmx), "r"(tg_1_16));
-}
-
-void ff_idct_xvid_mmx_put(uint8_t *dest, int line_size, int16_t *block)
-{
-    ff_idct_xvid_mmx(block);
-    ff_put_pixels_clamped_mmx(block, dest, line_size);
-}
-
-void ff_idct_xvid_mmx_add(uint8_t *dest, int line_size, int16_t *block)
-{
-    ff_idct_xvid_mmx(block);
-    ff_add_pixels_clamped_mmx(block, dest, line_size);
-}
-
-#endif /* HAVE_MMX_INLINE */
-
-#if HAVE_MMXEXT_INLINE
-
-//-----------------------------------------------------------------------------
-// void idct_xmm(uint16_t block[64]);
-//-----------------------------------------------------------------------------
-
-
-void ff_idct_xvid_mmxext(short *block)
-{
-__asm__ volatile(
-            //# Process each row
-    DCT_8_INV_ROW_XMM(0*16(%0), 0*16(%0), 64*0(%2), 8*0(%1))
-    DCT_8_INV_ROW_XMM(1*16(%0), 1*16(%0), 64*1(%2), 8*1(%1))
-    DCT_8_INV_ROW_XMM(2*16(%0), 2*16(%0), 64*2(%2), 8*2(%1))
-    DCT_8_INV_ROW_XMM(3*16(%0), 3*16(%0), 64*3(%2), 8*3(%1))
-    DCT_8_INV_ROW_XMM(4*16(%0), 4*16(%0), 64*0(%2), 8*4(%1))
-    DCT_8_INV_ROW_XMM(5*16(%0), 5*16(%0), 64*3(%2), 8*5(%1))
-    DCT_8_INV_ROW_XMM(6*16(%0), 6*16(%0), 64*2(%2), 8*6(%1))
-    DCT_8_INV_ROW_XMM(7*16(%0), 7*16(%0), 64*1(%2), 8*7(%1))
-
-            //# Process the columns (4 at a time)
-    DCT_8_INV_COL(0(%0), 0(%0))
-    DCT_8_INV_COL(8(%0), 8(%0))
-    :: "r"(block), "r"(rounder_0), "r"(tab_i_04_xmm), "r"(tg_1_16));
-}
-
-void ff_idct_xvid_mmxext_put(uint8_t *dest, int line_size, int16_t *block)
-{
-    ff_idct_xvid_mmxext(block);
-    ff_put_pixels_clamped_mmx(block, dest, line_size);
-}
-
-void ff_idct_xvid_mmxext_add(uint8_t *dest, int line_size, int16_t *block)
-{
-    ff_idct_xvid_mmxext(block);
-    ff_add_pixels_clamped_mmx(block, dest, line_size);
-}
-
-#endif /* HAVE_MMXEXT_INLINE */
diff --git a/libavdevice/x11grab.c b/libavdevice/x11grab.c
deleted file mode 100644
index d38c55d..0000000
--- a/libavdevice/x11grab.c
+++ /dev/null
@@ -1,649 +0,0 @@
-/*
- * X11 video grab interface
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg integration:
- * Copyright (C) 2006 Clemens Fruhwirth <clemens@endorphin.org>
- *                    Edouard Gomez <ed.gomez@free.fr>
- *
- * This file contains code from grab.c:
- * Copyright (c) 2000-2001 Fabrice Bellard
- *
- * This file contains code from the xvidcap project:
- * Copyright (C) 1997-1998 Rasca, Berlin
- *               2003-2004 Karl H. Beckers, Frankfurt
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * X11 frame device demuxer
- * @author Clemens Fruhwirth <clemens@endorphin.org>
- * @author Edouard Gomez <ed.gomez@free.fr>
- */
-
-#include "config.h"
-#include "libavformat/internal.h"
-#include "libavutil/log.h"
-#include "libavutil/opt.h"
-#include "libavutil/parseutils.h"
-#include "libavutil/time.h"
-#include <time.h>
-#include <X11/cursorfont.h>
-#include <X11/X.h>
-#include <X11/Xlib.h>
-#include <X11/Xlibint.h>
-#include <X11/Xproto.h>
-#include <X11/Xutil.h>
-#include <sys/shm.h>
-#include <X11/extensions/shape.h>
-#include <X11/extensions/XShm.h>
-#include <X11/extensions/Xfixes.h>
-#include "avdevice.h"
-
-/**
- * X11 Device Demuxer context
- */
-struct x11grab {
-    const AVClass *class;    /**< Class for private options. */
-    int frame_size;          /**< Size in bytes of a grabbed frame */
-    AVRational time_base;    /**< Time base */
-    int64_t time_frame;      /**< Current time */
-
-    int width;               /**< Width of the grab frame */
-    int height;              /**< Height of the grab frame */
-    int x_off;               /**< Horizontal top-left corner coordinate */
-    int y_off;               /**< Vertical top-left corner coordinate */
-
-    Display *dpy;            /**< X11 display from which x11grab grabs frames */
-    XImage *image;           /**< X11 image holding the grab */
-    int use_shm;             /**< !0 when using XShm extension */
-    XShmSegmentInfo shminfo; /**< When using XShm, keeps track of XShm infos */
-    int  draw_mouse;         /**< Set by a private option. */
-    int  follow_mouse;       /**< Set by a private option. */
-    int  show_region;        /**< set by a private option. */
-    AVRational framerate;         /**< Set by a private option. */
-    int palette_changed;
-    uint32_t palette[256];
-
-    Cursor c;
-    Window region_win;       /**< This is used by show_region option. */
-};
-
-#define REGION_WIN_BORDER 3
-/**
- * Draw grabbing region window
- *
- * @param s x11grab context
- */
-static void
-x11grab_draw_region_win(struct x11grab *s)
-{
-    Display *dpy = s->dpy;
-    int screen;
-    Window win = s->region_win;
-    GC gc;
-
-    screen = DefaultScreen(dpy);
-    gc = XCreateGC(dpy, win, 0, 0);
-    XSetForeground(dpy, gc, WhitePixel(dpy, screen));
-    XSetBackground(dpy, gc, BlackPixel(dpy, screen));
-    XSetLineAttributes(dpy, gc, REGION_WIN_BORDER, LineDoubleDash, 0, 0);
-    XDrawRectangle(dpy, win, gc,
-                   1, 1,
-                   (s->width  + REGION_WIN_BORDER * 2) - 1 * 2 - 1,
-                   (s->height + REGION_WIN_BORDER * 2) - 1 * 2 - 1);
-    XFreeGC(dpy, gc);
-}
-
-/**
- * Initialize grabbing region window
- *
- * @param s x11grab context
- */
-static void
-x11grab_region_win_init(struct x11grab *s)
-{
-    Display *dpy = s->dpy;
-    int screen;
-    XSetWindowAttributes attribs;
-    XRectangle rect;
-
-    screen = DefaultScreen(dpy);
-    attribs.override_redirect = True;
-    s->region_win = XCreateWindow(dpy, RootWindow(dpy, screen),
-                                  s->x_off  - REGION_WIN_BORDER,
-                                  s->y_off  - REGION_WIN_BORDER,
-                                  s->width  + REGION_WIN_BORDER * 2,
-                                  s->height + REGION_WIN_BORDER * 2,
-                                  0, CopyFromParent,
-                                  InputOutput, CopyFromParent,
-                                  CWOverrideRedirect, &attribs);
-    rect.x = 0;
-    rect.y = 0;
-    rect.width  = s->width;
-    rect.height = s->height;
-    XShapeCombineRectangles(dpy, s->region_win,
-                            ShapeBounding, REGION_WIN_BORDER, REGION_WIN_BORDER,
-                            &rect, 1, ShapeSubtract, 0);
-    XMapWindow(dpy, s->region_win);
-    XSelectInput(dpy, s->region_win, ExposureMask | StructureNotifyMask);
-    x11grab_draw_region_win(s);
-}
-
-/**
- * Initialize the x11 grab device demuxer (public device demuxer API).
- *
- * @param s1 Context from avformat core
- * @return <ul>
- *          <li>AVERROR(ENOMEM) no memory left</li>
- *          <li>AVERROR(EIO) other failure case</li>
- *          <li>0 success</li>
- *         </ul>
- */
-static int
-x11grab_read_header(AVFormatContext *s1)
-{
-    struct x11grab *x11grab = s1->priv_data;
-    Display *dpy;
-    AVStream *st = NULL;
-    enum AVPixelFormat input_pixfmt;
-    XImage *image;
-    int x_off = 0;
-    int y_off = 0;
-    int screen;
-    int use_shm;
-    char *dpyname, *offset;
-    int ret = 0;
-    Colormap color_map;
-    XColor color[256];
-    int i;
-
-    dpyname = av_strdup(s1->filename);
-    if (!dpyname)
-        goto out;
-
-    offset = strchr(dpyname, '+');
-    if (offset) {
-        sscanf(offset, "%d,%d", &x_off, &y_off);
-        if (strstr(offset, "nomouse")) {
-            av_log(s1, AV_LOG_WARNING,
-                   "'nomouse' specification in argument is deprecated: "
-                   "use 'draw_mouse' option with value 0 instead\n");
-            x11grab->draw_mouse = 0;
-        }
-        *offset= 0;
-    }
-
-    av_log(s1, AV_LOG_INFO, "device: %s -> display: %s x: %d y: %d width: %d height: %d\n",
-           s1->filename, dpyname, x_off, y_off, x11grab->width, x11grab->height);
-
-    dpy = XOpenDisplay(dpyname);
-    av_freep(&dpyname);
-    if(!dpy) {
-        av_log(s1, AV_LOG_ERROR, "Could not open X display.\n");
-        ret = AVERROR(EIO);
-        goto out;
-    }
-
-    st = avformat_new_stream(s1, NULL);
-    if (!st) {
-        ret = AVERROR(ENOMEM);
-        goto out;
-    }
-    avpriv_set_pts_info(st, 64, 1, 1000000); /* 64 bits pts in us */
-
-    screen = DefaultScreen(dpy);
-
-    if (x11grab->follow_mouse) {
-        int screen_w, screen_h;
-        Window w;
-
-        screen_w = DisplayWidth(dpy, screen);
-        screen_h = DisplayHeight(dpy, screen);
-        XQueryPointer(dpy, RootWindow(dpy, screen), &w, &w, &x_off, &y_off, &ret, &ret, &ret);
-        x_off -= x11grab->width / 2;
-        y_off -= x11grab->height / 2;
-        x_off = FFMIN(FFMAX(x_off, 0), screen_w - x11grab->width);
-        y_off = FFMIN(FFMAX(y_off, 0), screen_h - x11grab->height);
-        av_log(s1, AV_LOG_INFO, "followmouse is enabled, resetting grabbing region to x: %d y: %d\n", x_off, y_off);
-    }
-
-    use_shm = XShmQueryExtension(dpy);
-    av_log(s1, AV_LOG_INFO, "shared memory extension%s found\n", use_shm ? "" : " not");
-
-    if(use_shm) {
-        int scr = XDefaultScreen(dpy);
-        image = XShmCreateImage(dpy,
-                                DefaultVisual(dpy, scr),
-                                DefaultDepth(dpy, scr),
-                                ZPixmap,
-                                NULL,
-                                &x11grab->shminfo,
-                                x11grab->width, x11grab->height);
-        x11grab->shminfo.shmid = shmget(IPC_PRIVATE,
-                                        image->bytes_per_line * image->height,
-                                        IPC_CREAT|0777);
-        if (x11grab->shminfo.shmid == -1) {
-            av_log(s1, AV_LOG_ERROR, "Fatal: Can't get shared memory!\n");
-            ret = AVERROR(ENOMEM);
-            goto out;
-        }
-        x11grab->shminfo.shmaddr = image->data = shmat(x11grab->shminfo.shmid, 0, 0);
-        x11grab->shminfo.readOnly = False;
-
-        if (!XShmAttach(dpy, &x11grab->shminfo)) {
-            av_log(s1, AV_LOG_ERROR, "Fatal: Failed to attach shared memory!\n");
-            /* needs some better error subroutine :) */
-            ret = AVERROR(EIO);
-            goto out;
-        }
-    } else {
-        image = XGetImage(dpy, RootWindow(dpy, screen),
-                          x_off,y_off,
-                          x11grab->width, x11grab->height,
-                          AllPlanes, ZPixmap);
-    }
-
-    switch (image->bits_per_pixel) {
-    case 8:
-        av_log (s1, AV_LOG_DEBUG, "8 bit palette\n");
-        input_pixfmt = AV_PIX_FMT_PAL8;
-        color_map = DefaultColormap(dpy, screen);
-        for (i = 0; i < 256; ++i)
-            color[i].pixel = i;
-        XQueryColors(dpy, color_map, color, 256);
-        for (i = 0; i < 256; ++i)
-            x11grab->palette[i] = (color[i].red   & 0xFF00) << 8 |
-                                  (color[i].green & 0xFF00)      |
-                                  (color[i].blue  & 0xFF00) >> 8;
-        x11grab->palette_changed = 1;
-        break;
-    case 16:
-        if (       image->red_mask   == 0xf800 &&
-                   image->green_mask == 0x07e0 &&
-                   image->blue_mask  == 0x001f ) {
-            av_log (s1, AV_LOG_DEBUG, "16 bit RGB565\n");
-            input_pixfmt = AV_PIX_FMT_RGB565;
-        } else if (image->red_mask   == 0x7c00 &&
-                   image->green_mask == 0x03e0 &&
-                   image->blue_mask  == 0x001f ) {
-            av_log(s1, AV_LOG_DEBUG, "16 bit RGB555\n");
-            input_pixfmt = AV_PIX_FMT_RGB555;
-        } else {
-            av_log(s1, AV_LOG_ERROR, "RGB ordering at image depth %i not supported ... aborting\n", image->bits_per_pixel);
-            av_log(s1, AV_LOG_ERROR, "color masks: r 0x%.6lx g 0x%.6lx b 0x%.6lx\n", image->red_mask, image->green_mask, image->blue_mask);
-            ret = AVERROR(EIO);
-            goto out;
-        }
-        break;
-    case 24:
-        if (        image->red_mask   == 0xff0000 &&
-                    image->green_mask == 0x00ff00 &&
-                    image->blue_mask  == 0x0000ff ) {
-            input_pixfmt = AV_PIX_FMT_BGR24;
-        } else if ( image->red_mask   == 0x0000ff &&
-                    image->green_mask == 0x00ff00 &&
-                    image->blue_mask  == 0xff0000 ) {
-            input_pixfmt = AV_PIX_FMT_RGB24;
-        } else {
-            av_log(s1, AV_LOG_ERROR,"rgb ordering at image depth %i not supported ... aborting\n", image->bits_per_pixel);
-            av_log(s1, AV_LOG_ERROR, "color masks: r 0x%.6lx g 0x%.6lx b 0x%.6lx\n", image->red_mask, image->green_mask, image->blue_mask);
-            ret = AVERROR(EIO);
-            goto out;
-        }
-        break;
-    case 32:
-        input_pixfmt = AV_PIX_FMT_0RGB32;
-        break;
-    default:
-        av_log(s1, AV_LOG_ERROR, "image depth %i not supported ... aborting\n", image->bits_per_pixel);
-        ret = AVERROR(EINVAL);
-        goto out;
-    }
-
-    x11grab->frame_size = x11grab->width * x11grab->height * image->bits_per_pixel/8;
-    x11grab->dpy = dpy;
-    x11grab->time_base  = av_inv_q(x11grab->framerate);
-    x11grab->time_frame = av_gettime() / av_q2d(x11grab->time_base);
-    x11grab->x_off = x_off;
-    x11grab->y_off = y_off;
-    x11grab->image = image;
-    x11grab->use_shm = use_shm;
-
-    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;
-    st->codec->codec_id = AV_CODEC_ID_RAWVIDEO;
-    st->codec->width  = x11grab->width;
-    st->codec->height = x11grab->height;
-    st->codec->pix_fmt = input_pixfmt;
-    st->codec->time_base = x11grab->time_base;
-    st->codec->bit_rate = x11grab->frame_size * 1/av_q2d(x11grab->time_base) * 8;
-
-out:
-    av_free(dpyname);
-    return ret;
-}
-
-/**
- * Paint a mouse pointer in an X11 image.
- *
- * @param image image to paint the mouse pointer to
- * @param s context used to retrieve original grabbing rectangle
- *          coordinates
- */
-static void
-paint_mouse_pointer(XImage *image, struct x11grab *s)
-{
-    int x_off = s->x_off;
-    int y_off = s->y_off;
-    int width = s->width;
-    int height = s->height;
-    Display *dpy = s->dpy;
-    XFixesCursorImage *xcim;
-    int x, y;
-    int line, column;
-    int to_line, to_column;
-    int pixstride = image->bits_per_pixel >> 3;
-    /* Warning: in its insanity, xlib provides unsigned image data through a
-     * char* pointer, so we have to make it uint8_t to make things not break.
-     * Anyone who performs further investigation of the xlib API likely risks
-     * permanent brain damage. */
-    uint8_t *pix = image->data;
-    Window w;
-    XSetWindowAttributes attr;
-
-    /* Code doesn't currently support 16-bit or PAL8 */
-    if (image->bits_per_pixel != 24 && image->bits_per_pixel != 32)
-        return;
-
-    if(!s->c)
-        s->c = XCreateFontCursor(dpy, XC_left_ptr);
-    w = DefaultRootWindow(dpy);
-    attr.cursor = s->c;
-    XChangeWindowAttributes(dpy, w, CWCursor, &attr);
-
-    xcim = XFixesGetCursorImage(dpy);
-
-    x = xcim->x - xcim->xhot;
-    y = xcim->y - xcim->yhot;
-
-    to_line = FFMIN((y + xcim->height), (height + y_off));
-    to_column = FFMIN((x + xcim->width), (width + x_off));
-
-    for (line = FFMAX(y, y_off); line < to_line; line++) {
-        for (column = FFMAX(x, x_off); column < to_column; column++) {
-            int  xcim_addr = (line - y) * xcim->width + column - x;
-            int image_addr = ((line - y_off) * width + column - x_off) * pixstride;
-            int r = (uint8_t)(xcim->pixels[xcim_addr] >>  0);
-            int g = (uint8_t)(xcim->pixels[xcim_addr] >>  8);
-            int b = (uint8_t)(xcim->pixels[xcim_addr] >> 16);
-            int a = (uint8_t)(xcim->pixels[xcim_addr] >> 24);
-
-            if (a == 255) {
-                pix[image_addr+0] = r;
-                pix[image_addr+1] = g;
-                pix[image_addr+2] = b;
-            } else if (a) {
-                /* pixel values from XFixesGetCursorImage come premultiplied by alpha */
-                pix[image_addr+0] = r + (pix[image_addr+0]*(255-a) + 255/2) / 255;
-                pix[image_addr+1] = g + (pix[image_addr+1]*(255-a) + 255/2) / 255;
-                pix[image_addr+2] = b + (pix[image_addr+2]*(255-a) + 255/2) / 255;
-            }
-        }
-    }
-
-    XFree(xcim);
-    xcim = NULL;
-}
-
-
-/**
- * Read new data in the image structure.
- *
- * @param dpy X11 display to grab from
- * @param d
- * @param image Image where the grab will be put
- * @param x Top-Left grabbing rectangle horizontal coordinate
- * @param y Top-Left grabbing rectangle vertical coordinate
- * @return 0 if error, !0 if successful
- */
-static int
-xget_zpixmap(Display *dpy, Drawable d, XImage *image, int x, int y)
-{
-    xGetImageReply rep;
-    xGetImageReq *req;
-    long nbytes;
-
-    if (!image) {
-        return 0;
-    }
-
-    LockDisplay(dpy);
-    GetReq(GetImage, req);
-
-    /* First set up the standard stuff in the request */
-    req->drawable = d;
-    req->x = x;
-    req->y = y;
-    req->width = image->width;
-    req->height = image->height;
-    req->planeMask = (unsigned int)AllPlanes;
-    req->format = ZPixmap;
-
-    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse) || !rep.length) {
-        UnlockDisplay(dpy);
-        SyncHandle();
-        return 0;
-    }
-
-    nbytes = (long)rep.length << 2;
-    _XReadPad(dpy, image->data, nbytes);
-
-    UnlockDisplay(dpy);
-    SyncHandle();
-    return 1;
-}
-
-/**
- * Grab a frame from x11 (public device demuxer API).
- *
- * @param s1 Context from avformat core
- * @param pkt Packet holding the brabbed frame
- * @return frame size in bytes
- */
-static int
-x11grab_read_packet(AVFormatContext *s1, AVPacket *pkt)
-{
-    struct x11grab *s = s1->priv_data;
-    Display *dpy = s->dpy;
-    XImage *image = s->image;
-    int x_off = s->x_off;
-    int y_off = s->y_off;
-
-    int screen;
-    Window root;
-    int follow_mouse = s->follow_mouse;
-
-    int64_t curtime, delay;
-    struct timespec ts;
-
-    /* Calculate the time of the next frame */
-    s->time_frame += INT64_C(1000000);
-
-    /* wait based on the frame rate */
-    for(;;) {
-        curtime = av_gettime();
-        delay = s->time_frame * av_q2d(s->time_base) - curtime;
-        if (delay <= 0) {
-            if (delay < INT64_C(-1000000) * av_q2d(s->time_base)) {
-                s->time_frame += INT64_C(1000000);
-            }
-            break;
-        }
-        ts.tv_sec = delay / 1000000;
-        ts.tv_nsec = (delay % 1000000) * 1000;
-        nanosleep(&ts, NULL);
-    }
-
-    av_init_packet(pkt);
-    pkt->data = image->data;
-    pkt->size = s->frame_size;
-    pkt->pts = curtime;
-    if (s->palette_changed) {
-        uint8_t *pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE,
-                                               AVPALETTE_SIZE);
-        if (!pal) {
-            av_log(s, AV_LOG_ERROR, "Cannot append palette to packet\n");
-        } else {
-            memcpy(pal, s->palette, AVPALETTE_SIZE);
-            s->palette_changed = 0;
-        }
-    }
-
-    screen = DefaultScreen(dpy);
-    root = RootWindow(dpy, screen);
-    if (follow_mouse) {
-        int screen_w, screen_h;
-        int pointer_x, pointer_y, _;
-        Window w;
-
-        screen_w = DisplayWidth(dpy, screen);
-        screen_h = DisplayHeight(dpy, screen);
-        XQueryPointer(dpy, root, &w, &w, &pointer_x, &pointer_y, &_, &_, &_);
-        if (follow_mouse == -1) {
-            // follow the mouse, put it at center of grabbing region
-            x_off += pointer_x - s->width  / 2 - x_off;
-            y_off += pointer_y - s->height / 2 - y_off;
-        } else {
-            // follow the mouse, but only move the grabbing region when mouse
-            // reaches within certain pixels to the edge.
-            if (pointer_x > x_off + s->width - follow_mouse) {
-                x_off += pointer_x - (x_off + s->width - follow_mouse);
-            } else if (pointer_x < x_off + follow_mouse)
-                x_off -= (x_off + follow_mouse) - pointer_x;
-            if (pointer_y > y_off + s->height - follow_mouse) {
-                y_off += pointer_y - (y_off + s->height - follow_mouse);
-            } else if (pointer_y < y_off + follow_mouse)
-                y_off -= (y_off + follow_mouse) - pointer_y;
-        }
-        // adjust grabbing region position if it goes out of screen.
-        s->x_off = x_off = FFMIN(FFMAX(x_off, 0), screen_w - s->width);
-        s->y_off = y_off = FFMIN(FFMAX(y_off, 0), screen_h - s->height);
-
-        if (s->show_region && s->region_win)
-            XMoveWindow(dpy, s->region_win,
-                        s->x_off - REGION_WIN_BORDER,
-                        s->y_off - REGION_WIN_BORDER);
-    }
-
-    if (s->show_region) {
-        if (s->region_win) {
-            XEvent evt;
-            // clean up the events, and do the initinal draw or redraw.
-            for (evt.type = NoEventMask; XCheckMaskEvent(dpy, ExposureMask | StructureNotifyMask, &evt); );
-            if (evt.type)
-                x11grab_draw_region_win(s);
-        } else {
-            x11grab_region_win_init(s);
-        }
-    }
-
-    if(s->use_shm) {
-        if (!XShmGetImage(dpy, root, image, x_off, y_off, AllPlanes)) {
-            av_log (s1, AV_LOG_INFO, "XShmGetImage() failed\n");
-        }
-    } else {
-        if (!xget_zpixmap(dpy, root, image, x_off, y_off)) {
-            av_log (s1, AV_LOG_INFO, "XGetZPixmap() failed\n");
-        }
-    }
-
-    if (s->draw_mouse) {
-        paint_mouse_pointer(image, s);
-    }
-
-    return s->frame_size;
-}
-
-/**
- * Close x11 frame grabber (public device demuxer API).
- *
- * @param s1 Context from avformat core
- * @return 0 success, !0 failure
- */
-static int
-x11grab_read_close(AVFormatContext *s1)
-{
-    struct x11grab *x11grab = s1->priv_data;
-
-    /* Detach cleanly from shared mem */
-    if (x11grab->use_shm) {
-        XShmDetach(x11grab->dpy, &x11grab->shminfo);
-        shmdt(x11grab->shminfo.shmaddr);
-        shmctl(x11grab->shminfo.shmid, IPC_RMID, NULL);
-    }
-
-    /* Destroy X11 image */
-    if (x11grab->image) {
-        XDestroyImage(x11grab->image);
-        x11grab->image = NULL;
-    }
-
-    if (x11grab->region_win) {
-        XDestroyWindow(x11grab->dpy, x11grab->region_win);
-    }
-
-    /* Free X11 display */
-    XCloseDisplay(x11grab->dpy);
-    return 0;
-}
-
-#define OFFSET(x) offsetof(struct x11grab, x)
-#define DEC AV_OPT_FLAG_DECODING_PARAM
-static const AVOption options[] = {
-    { "draw_mouse", "draw the mouse pointer", OFFSET(draw_mouse), AV_OPT_TYPE_INT, {.i64 = 1}, 0, 1, DEC },
-
-    { "follow_mouse", "move the grabbing region when the mouse pointer reaches within specified amount of pixels to the edge of region",
-      OFFSET(follow_mouse), AV_OPT_TYPE_INT, {.i64 = 0}, -1, INT_MAX, DEC, "follow_mouse" },
-    { "centered",     "keep the mouse pointer at the center of grabbing region when following",
-      0, AV_OPT_TYPE_CONST, {.i64 = -1}, INT_MIN, INT_MAX, DEC, "follow_mouse" },
-
-    { "framerate",  "set video frame rate",      OFFSET(framerate),   AV_OPT_TYPE_VIDEO_RATE, {.str = "ntsc"}, 0, 0, DEC },
-    { "show_region", "show the grabbing region", OFFSET(show_region), AV_OPT_TYPE_INT,        {.i64 = 0}, 0, 1, DEC },
-    { "video_size",  "set video frame size",     OFFSET(width),       AV_OPT_TYPE_IMAGE_SIZE, {.str = "vga"}, 0, 0, DEC },
-    { NULL },
-};
-
-static const AVClass x11_class = {
-    .class_name = "X11grab indev",
-    .item_name  = av_default_item_name,
-    .option     = options,
-    .version    = LIBAVUTIL_VERSION_INT,
-    .category   = AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT,
-};
-
-/** x11 grabber device demuxer declaration */
-AVInputFormat ff_x11grab_demuxer = {
-    .name           = "x11grab",
-    .long_name      = NULL_IF_CONFIG_SMALL("X11grab"),
-    .priv_data_size = sizeof(struct x11grab),
-    .read_header    = x11grab_read_header,
-    .read_packet    = x11grab_read_packet,
-    .read_close     = x11grab_read_close,
-    .flags          = AVFMT_NOFILE,
-    .priv_class     = &x11_class,
-};
diff --git a/libavfilter/f_ebur128.c b/libavfilter/f_ebur128.c
deleted file mode 100644
index 2e510db..0000000
--- a/libavfilter/f_ebur128.c
+++ /dev/null
@@ -1,941 +0,0 @@
-/*
- * Copyright (c) 2012 Clment Bsch
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with FFmpeg; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-/**
- * @file
- * EBU R.128 implementation
- * @see http://tech.ebu.ch/loudness
- * @see https://www.youtube.com/watch?v=iuEtQqC-Sqo "EBU R128 Introduction - Florian Camerer"
- * @todo implement start/stop/reset through filter command injection
- * @todo support other frequencies to avoid resampling
- */
-
-#include <math.h>
-
-#include "libavutil/avassert.h"
-#include "libavutil/avstring.h"
-#include "libavutil/channel_layout.h"
-#include "libavutil/dict.h"
-#include "libavutil/xga_font_data.h"
-#include "libavutil/opt.h"
-#include "libavutil/timestamp.h"
-#include "libswresample/swresample.h"
-#include "audio.h"
-#include "avfilter.h"
-#include "formats.h"
-#include "internal.h"
-
-#define MAX_CHANNELS 63
-
-/* pre-filter coefficients */
-#define PRE_B0  1.53512485958697
-#define PRE_B1 -2.69169618940638
-#define PRE_B2  1.19839281085285
-#define PRE_A1 -1.69065929318241
-#define PRE_A2  0.73248077421585
-
-/* RLB-filter coefficients */
-#define RLB_B0  1.0
-#define RLB_B1 -2.0
-#define RLB_B2  1.0
-#define RLB_A1 -1.99004745483398
-#define RLB_A2  0.99007225036621
-
-#define ABS_THRES    -70            ///< silence gate: we discard anything below this absolute (LUFS) threshold
-#define ABS_UP_THRES  10            ///< upper loud limit to consider (ABS_THRES being the minimum)
-#define HIST_GRAIN   100            ///< defines histogram precision
-#define HIST_SIZE  ((ABS_UP_THRES - ABS_THRES) * HIST_GRAIN + 1)
-
-/**
- * A histogram is an array of HIST_SIZE hist_entry storing all the energies
- * recorded (with an accuracy of 1/HIST_GRAIN) of the loudnesses from ABS_THRES
- * (at 0) to ABS_UP_THRES (at HIST_SIZE-1).
- * This fixed-size system avoids the need of a list of energies growing
- * infinitely over the time and is thus more scalable.
- */
-struct hist_entry {
-    int count;                      ///< how many times the corresponding value occurred
-    double energy;                  ///< E = 10^((L + 0.691) / 10)
-    double loudness;                ///< L = -0.691 + 10 * log10(E)
-};
-
-struct integrator {
-    double *cache[MAX_CHANNELS];    ///< window of filtered samples (N ms)
-    int cache_pos;                  ///< focus on the last added bin in the cache array
-    double sum[MAX_CHANNELS];       ///< sum of the last N ms filtered samples (cache content)
-    int filled;                     ///< 1 if the cache is completely filled, 0 otherwise
-    double rel_threshold;           ///< relative threshold
-    double sum_kept_powers;         ///< sum of the powers (weighted sums) above absolute threshold
-    int nb_kept_powers;             ///< number of sum above absolute threshold
-    struct hist_entry *histogram;   ///< histogram of the powers, used to compute LRA and I
-};
-
-struct rect { int x, y, w, h; };
-
-typedef struct {
-    const AVClass *class;           ///< AVClass context for log and options purpose
-
-    /* peak metering */
-    int peak_mode;                  ///< enabled peak modes
-    double *true_peaks;             ///< true peaks per channel
-    double *sample_peaks;           ///< sample peaks per channel
-    double *true_peaks_per_frame;   ///< true peaks in a frame per channel
-#if CONFIG_SWRESAMPLE
-    SwrContext *swr_ctx;            ///< over-sampling context for true peak metering
-    double *swr_buf;                ///< resampled audio data for true peak metering
-    int swr_linesize;
-#endif
-
-    /* video  */
-    int do_video;                   ///< 1 if video output enabled, 0 otherwise
-    int w, h;                       ///< size of the video output
-    struct rect text;               ///< rectangle for the LU legend on the left
-    struct rect graph;              ///< rectangle for the main graph in the center
-    struct rect gauge;              ///< rectangle for the gauge on the right
-    AVFrame *outpicref;             ///< output picture reference, updated regularly
-    int meter;                      ///< select a EBU mode between +9 and +18
-    int scale_range;                ///< the range of LU values according to the meter
-    int y_zero_lu;                  ///< the y value (pixel position) for 0 LU
-    int *y_line_ref;                ///< y reference values for drawing the LU lines in the graph and the gauge
-
-    /* audio */
-    int nb_channels;                ///< number of channels in the input
-    double *ch_weighting;           ///< channel weighting mapping
-    int sample_count;               ///< sample count used for refresh frequency, reset at refresh
-
-    /* Filter caches.
-     * The mult by 3 in the following is for X[i], X[i-1] and X[i-2] */
-    double x[MAX_CHANNELS * 3];     ///< 3 input samples cache for each channel
-    double y[MAX_CHANNELS * 3];     ///< 3 pre-filter samples cache for each channel
-    double z[MAX_CHANNELS * 3];     ///< 3 RLB-filter samples cache for each channel
-
-#define I400_BINS  (48000 * 4 / 10)
-#define I3000_BINS (48000 * 3)
-    struct integrator i400;         ///< 400ms integrator, used for Momentary loudness  (M), and Integrated loudness (I)
-    struct integrator i3000;        ///<    3s integrator, used for Short term loudness (S), and Loudness Range      (LRA)
-
-    /* I and LRA specific */
-    double integrated_loudness;     ///< integrated loudness in LUFS (I)
-    double loudness_range;          ///< loudness range in LU (LRA)
-    double lra_low, lra_high;       ///< low and high LRA values
-
-    /* misc */
-    int loglevel;                   ///< log level for frame logging
-    int metadata;                   ///< whether or not to inject loudness results in frames
-} EBUR128Context;
-
-enum {
-    PEAK_MODE_NONE          = 0,
-    PEAK_MODE_SAMPLES_PEAKS = 1<<1,
-    PEAK_MODE_TRUE_PEAKS    = 1<<2,
-};
-
-#define OFFSET(x) offsetof(EBUR128Context, x)
-#define A AV_OPT_FLAG_AUDIO_PARAM
-#define V AV_OPT_FLAG_VIDEO_PARAM
-#define F AV_OPT_FLAG_FILTERING_PARAM
-static const AVOption ebur128_options[] = {
-    { "video", "set video output", OFFSET(do_video), AV_OPT_TYPE_INT, {.i64 = 0}, 0, 1, V|F },
-    { "size",  "set video size",   OFFSET(w), AV_OPT_TYPE_IMAGE_SIZE, {.str = "640x480"}, 0, 0, V|F },
-    { "meter", "set scale meter (+9 to +18)",  OFFSET(meter), AV_OPT_TYPE_INT, {.i64 = 9}, 9, 18, V|F },
-    { "framelog", "force frame logging level", OFFSET(loglevel), AV_OPT_TYPE_INT, {.i64 = -1},   INT_MIN, INT_MAX, A|V|F, "level" },
-        { "info",    "information logging level", 0, AV_OPT_TYPE_CONST, {.i64 = AV_LOG_INFO},    INT_MIN, INT_MAX, A|V|F, "level" },
-        { "verbose", "verbose logging level",     0, AV_OPT_TYPE_CONST, {.i64 = AV_LOG_VERBOSE}, INT_MIN, INT_MAX, A|V|F, "level" },
-    { "metadata", "inject metadata in the filtergraph", OFFSET(metadata), AV_OPT_TYPE_INT, {.i64 = 0}, 0, 1, A|V|F },
-    { "peak", "set peak mode", OFFSET(peak_mode), AV_OPT_TYPE_FLAGS, {.i64 = PEAK_MODE_NONE}, 0, INT_MAX, A|F, "mode" },
-        { "none",   "disable any peak mode",   0, AV_OPT_TYPE_CONST, {.i64 = PEAK_MODE_NONE},          INT_MIN, INT_MAX, A|F, "mode" },
-        { "sample", "enable peak-sample mode", 0, AV_OPT_TYPE_CONST, {.i64 = PEAK_MODE_SAMPLES_PEAKS}, INT_MIN, INT_MAX, A|F, "mode" },
-        { "true",   "enable true-peak mode",   0, AV_OPT_TYPE_CONST, {.i64 = PEAK_MODE_TRUE_PEAKS},    INT_MIN, INT_MAX, A|F, "mode" },
-    { NULL },
-};
-
-AVFILTER_DEFINE_CLASS(ebur128);
-
-static const uint8_t graph_colors[] = {
-    0xdd, 0x66, 0x66,   // value above 0LU non reached
-    0x66, 0x66, 0xdd,   // value below 0LU non reached
-    0x96, 0x33, 0x33,   // value above 0LU reached
-    0x33, 0x33, 0x96,   // value below 0LU reached
-    0xdd, 0x96, 0x96,   // value above 0LU line non reached
-    0x96, 0x96, 0xdd,   // value below 0LU line non reached
-    0xdd, 0x33, 0x33,   // value above 0LU line reached
-    0x33, 0x33, 0xdd,   // value below 0LU line reached
-};
-
-static const uint8_t *get_graph_color(const EBUR128Context *ebur128, int v, int y)
-{
-    const int below0  = y > ebur128->y_zero_lu;
-    const int reached = y >= v;
-    const int line    = ebur128->y_line_ref[y] || y == ebur128->y_zero_lu;
-    const int colorid = 4*line + 2*reached + below0;
-    return graph_colors + 3*colorid;
-}
-
-static inline int lu_to_y(const EBUR128Context *ebur128, double v)
-{
-    v += 2 * ebur128->meter;                            // make it in range [0;...]
-    v  = av_clipf(v, 0, ebur128->scale_range);          // make sure it's in the graph scale
-    v  = ebur128->scale_range - v;                      // invert value (y=0 is on top)
-    return v * ebur128->graph.h / ebur128->scale_range; // rescale from scale range to px height
-}
-
-#define FONT8   0
-#define FONT16  1
-
-static const uint8_t font_colors[] = {
-    0xdd, 0xdd, 0x00,
-    0x00, 0x96, 0x96,
-};
-
-static void drawtext(AVFrame *pic, int x, int y, int ftid, const uint8_t *color, const char *fmt, ...)
-{
-    int i;
-    char buf[128] = {0};
-    const uint8_t *font;
-    int font_height;
-    va_list vl;
-
-    if      (ftid == FONT16) font = avpriv_vga16_font, font_height = 16;
-    else if (ftid == FONT8)  font = avpriv_cga_font,   font_height =  8;
-    else return;
-
-    va_start(vl, fmt);
-    vsnprintf(buf, sizeof(buf), fmt, vl);
-    va_end(vl);
-
-    for (i = 0; buf[i]; i++) {
-        int char_y, mask;
-        uint8_t *p = pic->data[0] + y*pic->linesize[0] + (x + i*8)*3;
-
-        for (char_y = 0; char_y < font_height; char_y++) {
-            for (mask = 0x80; mask; mask >>= 1) {
-                if (font[buf[i] * font_height + char_y] & mask)
-                    memcpy(p, color, 3);
-                else
-                    memcpy(p, "\x00\x00\x00", 3);
-                p += 3;
-            }
-            p += pic->linesize[0] - 8*3;
-        }
-    }
-}
-
-static void drawline(AVFrame *pic, int x, int y, int len, int step)
-{
-    int i;
-    uint8_t *p = pic->data[0] + y*pic->linesize[0] + x*3;
-
-    for (i = 0; i < len; i++) {
-        memcpy(p, "\x00\xff\x00", 3);
-        p += step;
-    }
-}
-
-static int config_video_output(AVFilterLink *outlink)
-{
-    int i, x, y;
-    uint8_t *p;
-    AVFilterContext *ctx = outlink->src;
-    EBUR128Context *ebur128 = ctx->priv;
-    AVFrame *outpicref;
-
-    /* check if there is enough space to represent everything decently */
-    if (ebur128->w < 640 || ebur128->h < 480) {
-        av_log(ctx, AV_LOG_ERROR, "Video size %dx%d is too small, "
-               "minimum size is 640x480\n", ebur128->w, ebur128->h);
-        return AVERROR(EINVAL);
-    }
-    outlink->w = ebur128->w;
-    outlink->h = ebur128->h;
-
-#define PAD 8
-
-    /* configure text area position and size */
-    ebur128->text.x  = PAD;
-    ebur128->text.y  = 40;
-    ebur128->text.w  = 3 * 8;   // 3 characters
-    ebur128->text.h  = ebur128->h - PAD - ebur128->text.y;
-
-    /* configure gauge position and size */
-    ebur128->gauge.w = 20;
-    ebur128->gauge.h = ebur128->text.h;
-    ebur128->gauge.x = ebur128->w - PAD - ebur128->gauge.w;
-    ebur128->gauge.y = ebur128->text.y;
-
-    /* configure graph position and size */
-    ebur128->graph.x = ebur128->text.x + ebur128->text.w + PAD;
-    ebur128->graph.y = ebur128->gauge.y;
-    ebur128->graph.w = ebur128->gauge.x - ebur128->graph.x - PAD;
-    ebur128->graph.h = ebur128->gauge.h;
-
-    /* graph and gauge share the LU-to-pixel code */
-    av_assert0(ebur128->graph.h == ebur128->gauge.h);
-
-    /* prepare the initial picref buffer */
-    av_frame_free(&ebur128->outpicref);
-    ebur128->outpicref = outpicref =
-        ff_get_video_buffer(outlink, outlink->w, outlink->h);
-    if (!outpicref)
-        return AVERROR(ENOMEM);
-    outlink->sample_aspect_ratio = (AVRational){1,1};
-
-    /* init y references values (to draw LU lines) */
-    ebur128->y_line_ref = av_calloc(ebur128->graph.h + 1, sizeof(*ebur128->y_line_ref));
-    if (!ebur128->y_line_ref)
-        return AVERROR(ENOMEM);
-
-    /* black background */
-    memset(outpicref->data[0], 0, ebur128->h * outpicref->linesize[0]);
-
-    /* draw LU legends */
-    drawtext(outpicref, PAD, PAD+16, FONT8, font_colors+3, " LU");
-    for (i = ebur128->meter; i >= -ebur128->meter * 2; i--) {
-        y = lu_to_y(ebur128, i);
-        x = PAD + (i < 10 && i > -10) * 8;
-        ebur128->y_line_ref[y] = i;
-        y -= 4; // -4 to center vertically
-        drawtext(outpicref, x, y + ebur128->graph.y, FONT8, font_colors+3,
-                 "%c%d", i < 0 ? '-' : i > 0 ? '+' : ' ', FFABS(i));
-    }
-
-    /* draw graph */
-    ebur128->y_zero_lu = lu_to_y(ebur128, 0);
-    p = outpicref->data[0] + ebur128->graph.y * outpicref->linesize[0]
-                           + ebur128->graph.x * 3;
-    for (y = 0; y < ebur128->graph.h; y++) {
-        const uint8_t *c = get_graph_color(ebur128, INT_MAX, y);
-
-        for (x = 0; x < ebur128->graph.w; x++)
-            memcpy(p + x*3, c, 3);
-        p += outpicref->linesize[0];
-    }
-
-    /* draw fancy rectangles around the graph and the gauge */
-#define DRAW_RECT(r) do { \
-    drawline(outpicref, r.x,       r.y - 1,   r.w, 3); \
-    drawline(outpicref, r.x,       r.y + r.h, r.w, 3); \
-    drawline(outpicref, r.x - 1,   r.y,       r.h, outpicref->linesize[0]); \
-    drawline(outpicref, r.x + r.w, r.y,       r.h, outpicref->linesize[0]); \
-} while (0)
-    DRAW_RECT(ebur128->graph);
-    DRAW_RECT(ebur128->gauge);
-
-    outlink->flags |= FF_LINK_FLAG_REQUEST_LOOP;
-
-    return 0;
-}
-
-static int config_audio_input(AVFilterLink *inlink)
-{
-    AVFilterContext *ctx = inlink->dst;
-    EBUR128Context *ebur128 = ctx->priv;
-
-    /* Force 100ms framing in case of metadata injection: the frames must have
-     * a granularity of the window overlap to be accurately exploited.
-     * As for the true peaks mode, it just simplifies the resampling buffer
-     * allocation and the lookup in it (since sample buffers differ in size, it
-     * can be more complex to integrate in the one-sample loop of
-     * filter_frame()). */
-    if (ebur128->metadata || (ebur128->peak_mode & PEAK_MODE_TRUE_PEAKS))
-        inlink->min_samples =
-        inlink->max_samples =
-        inlink->partial_buf_size = inlink->sample_rate / 10;
-    return 0;
-}
-
-static int config_audio_output(AVFilterLink *outlink)
-{
-    int i;
-    int idx_bitposn = 0;
-    AVFilterContext *ctx = outlink->src;
-    EBUR128Context *ebur128 = ctx->priv;
-    const int nb_channels = av_get_channel_layout_nb_channels(outlink->channel_layout);
-
-#define BACK_MASK (AV_CH_BACK_LEFT    |AV_CH_BACK_CENTER    |AV_CH_BACK_RIGHT| \
-                   AV_CH_TOP_BACK_LEFT|AV_CH_TOP_BACK_CENTER|AV_CH_TOP_BACK_RIGHT| \
-                   AV_CH_SIDE_LEFT                          |AV_CH_SIDE_RIGHT| \
-                   AV_CH_SURROUND_DIRECT_LEFT               |AV_CH_SURROUND_DIRECT_RIGHT)
-
-    ebur128->nb_channels  = nb_channels;
-    ebur128->ch_weighting = av_calloc(nb_channels, sizeof(*ebur128->ch_weighting));
-    if (!ebur128->ch_weighting)
-        return AVERROR(ENOMEM);
-
-    for (i = 0; i < nb_channels; i++) {
-
-        /* find the next bit that is set starting from the right */
-        while ((outlink->channel_layout & 1ULL<<idx_bitposn) == 0 && idx_bitposn < 63)
-            idx_bitposn++;
-
-        /* channel weighting */
-        if ((1ULL<<idx_bitposn & AV_CH_LOW_FREQUENCY) ||
-            (1ULL<<idx_bitposn & AV_CH_LOW_FREQUENCY_2)) {
-            ebur128->ch_weighting[i] = 0;
-        } else if (1ULL<<idx_bitposn & BACK_MASK) {
-            ebur128->ch_weighting[i] = 1.41;
-        } else {
-            ebur128->ch_weighting[i] = 1.0;
-        }
-
-        idx_bitposn++;
-
-        if (!ebur128->ch_weighting[i])
-            continue;
-
-        /* bins buffer for the two integration window (400ms and 3s) */
-        ebur128->i400.cache[i]  = av_calloc(I400_BINS,  sizeof(*ebur128->i400.cache[0]));
-        ebur128->i3000.cache[i] = av_calloc(I3000_BINS, sizeof(*ebur128->i3000.cache[0]));
-        if (!ebur128->i400.cache[i] || !ebur128->i3000.cache[i])
-            return AVERROR(ENOMEM);
-    }
-
-    outlink->flags |= FF_LINK_FLAG_REQUEST_LOOP;
-
-#if CONFIG_SWRESAMPLE
-    if (ebur128->peak_mode & PEAK_MODE_TRUE_PEAKS) {
-        int ret;
-
-        ebur128->swr_buf    = av_malloc(19200 * nb_channels * sizeof(double));
-        ebur128->true_peaks = av_calloc(nb_channels, sizeof(*ebur128->true_peaks));
-        ebur128->true_peaks_per_frame = av_calloc(nb_channels, sizeof(*ebur128->true_peaks_per_frame));
-        ebur128->swr_ctx    = swr_alloc();
-        if (!ebur128->swr_buf || !ebur128->true_peaks ||
-            !ebur128->true_peaks_per_frame || !ebur128->swr_ctx)
-            return AVERROR(ENOMEM);
-
-        av_opt_set_int(ebur128->swr_ctx, "in_channel_layout",    outlink->channel_layout, 0);
-        av_opt_set_int(ebur128->swr_ctx, "in_sample_rate",       outlink->sample_rate, 0);
-        av_opt_set_sample_fmt(ebur128->swr_ctx, "in_sample_fmt", outlink->format, 0);
-
-        av_opt_set_int(ebur128->swr_ctx, "out_channel_layout",    outlink->channel_layout, 0);
-        av_opt_set_int(ebur128->swr_ctx, "out_sample_rate",       192000, 0);
-        av_opt_set_sample_fmt(ebur128->swr_ctx, "out_sample_fmt", outlink->format, 0);
-
-        ret = swr_init(ebur128->swr_ctx);
-        if (ret < 0)
-            return ret;
-    }
-#endif
-
-    if (ebur128->peak_mode & PEAK_MODE_SAMPLES_PEAKS) {
-        ebur128->sample_peaks = av_calloc(nb_channels, sizeof(*ebur128->sample_peaks));
-        if (!ebur128->sample_peaks)
-            return AVERROR(ENOMEM);
-    }
-
-    return 0;
-}
-
-#define ENERGY(loudness) (pow(10, ((loudness) + 0.691) / 10.))
-#define LOUDNESS(energy) (-0.691 + 10 * log10(energy))
-#define DBFS(energy) (20 * log10(energy))
-
-static struct hist_entry *get_histogram(void)
-{
-    int i;
-    struct hist_entry *h = av_calloc(HIST_SIZE, sizeof(*h));
-
-    if (!h)
-        return NULL;
-    for (i = 0; i < HIST_SIZE; i++) {
-        h[i].loudness = i / (double)HIST_GRAIN + ABS_THRES;
-        h[i].energy   = ENERGY(h[i].loudness);
-    }
-    return h;
-}
-
-static av_cold int init(AVFilterContext *ctx)
-{
-    EBUR128Context *ebur128 = ctx->priv;
-    AVFilterPad pad;
-
-    if (ebur128->loglevel != AV_LOG_INFO &&
-        ebur128->loglevel != AV_LOG_VERBOSE) {
-        if (ebur128->do_video || ebur128->metadata)
-            ebur128->loglevel = AV_LOG_VERBOSE;
-        else
-            ebur128->loglevel = AV_LOG_INFO;
-    }
-
-    if (!CONFIG_SWRESAMPLE && (ebur128->peak_mode & PEAK_MODE_TRUE_PEAKS)) {
-        av_log(ctx, AV_LOG_ERROR,
-               "True-peak mode requires libswresample to be performed\n");
-        return AVERROR(EINVAL);
-    }
-
-    // if meter is  +9 scale, scale range is from -18 LU to  +9 LU (or 3*9)
-    // if meter is +18 scale, scale range is from -36 LU to +18 LU (or 3*18)
-    ebur128->scale_range = 3 * ebur128->meter;
-
-    ebur128->i400.histogram  = get_histogram();
-    ebur128->i3000.histogram = get_histogram();
-    if (!ebur128->i400.histogram || !ebur128->i3000.histogram)
-        return AVERROR(ENOMEM);
-
-    ebur128->integrated_loudness = ABS_THRES;
-    ebur128->loudness_range = 0;
-
-    /* insert output pads */
-    if (ebur128->do_video) {
-        pad = (AVFilterPad){
-            .name         = av_strdup("out0"),
-            .type         = AVMEDIA_TYPE_VIDEO,
-            .config_props = config_video_output,
-        };
-        if (!pad.name)
-            return AVERROR(ENOMEM);
-        ff_insert_outpad(ctx, 0, &pad);
-    }
-    pad = (AVFilterPad){
-        .name         = av_asprintf("out%d", ebur128->do_video),
-        .type         = AVMEDIA_TYPE_AUDIO,
-        .config_props = config_audio_output,
-    };
-    if (!pad.name)
-        return AVERROR(ENOMEM);
-    ff_insert_outpad(ctx, ebur128->do_video, &pad);
-
-    /* summary */
-    av_log(ctx, AV_LOG_VERBOSE, "EBU +%d scale\n", ebur128->meter);
-
-    return 0;
-}
-
-#define HIST_POS(power) (int)(((power) - ABS_THRES) * HIST_GRAIN)
-
-/* loudness and power should be set such as loudness = -0.691 +
- * 10*log10(power), we just avoid doing that calculus two times */
-static int gate_update(struct integrator *integ, double power,
-                       double loudness, int gate_thres)
-{
-    int ipower;
-    double relative_threshold;
-    int gate_hist_pos;
-
-    /* update powers histograms by incrementing current power count */
-    ipower = av_clip(HIST_POS(loudness), 0, HIST_SIZE - 1);
-    integ->histogram[ipower].count++;
-
-    /* compute relative threshold and get its position in the histogram */
-    integ->sum_kept_powers += power;
-    integ->nb_kept_powers++;
-    relative_threshold = integ->sum_kept_powers / integ->nb_kept_powers;
-    if (!relative_threshold)
-        relative_threshold = 1e-12;
-    integ->rel_threshold = LOUDNESS(relative_threshold) + gate_thres;
-    gate_hist_pos = av_clip(HIST_POS(integ->rel_threshold), 0, HIST_SIZE - 1);
-
-    return gate_hist_pos;
-}
-
-static int filter_frame(AVFilterLink *inlink, AVFrame *insamples)
-{
-    int i, ch, idx_insample;
-    AVFilterContext *ctx = inlink->dst;
-    EBUR128Context *ebur128 = ctx->priv;
-    const int nb_channels = ebur128->nb_channels;
-    const int nb_samples  = insamples->nb_samples;
-    const double *samples = (double *)insamples->data[0];
-    AVFrame *pic = ebur128->outpicref;
-
-#if CONFIG_SWRESAMPLE
-    if (ebur128->peak_mode & PEAK_MODE_TRUE_PEAKS) {
-        const double *swr_samples = ebur128->swr_buf;
-        int ret = swr_convert(ebur128->swr_ctx, (uint8_t**)&ebur128->swr_buf, 19200,
-                              (const uint8_t **)insamples->data, nb_samples);
-        if (ret < 0)
-            return ret;
-        for (ch = 0; ch < nb_channels; ch++)
-            ebur128->true_peaks_per_frame[ch] = 0.0;
-        for (idx_insample = 0; idx_insample < ret; idx_insample++) {
-            for (ch = 0; ch < nb_channels; ch++) {
-                ebur128->true_peaks[ch] = FFMAX(ebur128->true_peaks[ch], FFABS(*swr_samples));
-                ebur128->true_peaks_per_frame[ch] = FFMAX(ebur128->true_peaks_per_frame[ch],
-                                                          FFABS(*swr_samples));
-                swr_samples++;
-            }
-        }
-    }
-#endif
-
-    for (idx_insample = 0; idx_insample < nb_samples; idx_insample++) {
-        const int bin_id_400  = ebur128->i400.cache_pos;
-        const int bin_id_3000 = ebur128->i3000.cache_pos;
-
-#define MOVE_TO_NEXT_CACHED_ENTRY(time) do {                \
-    ebur128->i##time.cache_pos++;                           \
-    if (ebur128->i##time.cache_pos == I##time##_BINS) {     \
-        ebur128->i##time.filled    = 1;                     \
-        ebur128->i##time.cache_pos = 0;                     \
-    }                                                       \
-} while (0)
-
-        MOVE_TO_NEXT_CACHED_ENTRY(400);
-        MOVE_TO_NEXT_CACHED_ENTRY(3000);
-
-        for (ch = 0; ch < nb_channels; ch++) {
-            double bin;
-
-            if (ebur128->peak_mode & PEAK_MODE_SAMPLES_PEAKS)
-                ebur128->sample_peaks[ch] = FFMAX(ebur128->sample_peaks[ch], FFABS(*samples));
-
-            ebur128->x[ch * 3] = *samples++; // set X[i]
-
-            if (!ebur128->ch_weighting[ch])
-                continue;
-
-            /* Y[i] = X[i]*b0 + X[i-1]*b1 + X[i-2]*b2 - Y[i-1]*a1 - Y[i-2]*a2 */
-#define FILTER(Y, X, name) do {                                                 \
-            double *dst = ebur128->Y + ch*3;                                    \
-            double *src = ebur128->X + ch*3;                                    \
-            dst[2] = dst[1];                                                    \
-            dst[1] = dst[0];                                                    \
-            dst[0] = src[0]*name##_B0 + src[1]*name##_B1 + src[2]*name##_B2     \
-                                      - dst[1]*name##_A1 - dst[2]*name##_A2;    \
-} while (0)
-
-            // TODO: merge both filters in one?
-            FILTER(y, x, PRE);  // apply pre-filter
-            ebur128->x[ch * 3 + 2] = ebur128->x[ch * 3 + 1];
-            ebur128->x[ch * 3 + 1] = ebur128->x[ch * 3    ];
-            FILTER(z, y, RLB);  // apply RLB-filter
-
-            bin = ebur128->z[ch * 3] * ebur128->z[ch * 3];
-
-            /* add the new value, and limit the sum to the cache size (400ms or 3s)
-             * by removing the oldest one */
-            ebur128->i400.sum [ch] = ebur128->i400.sum [ch] + bin - ebur128->i400.cache [ch][bin_id_400];
-            ebur128->i3000.sum[ch] = ebur128->i3000.sum[ch] + bin - ebur128->i3000.cache[ch][bin_id_3000];
-
-            /* override old cache entry with the new value */
-            ebur128->i400.cache [ch][bin_id_400 ] = bin;
-            ebur128->i3000.cache[ch][bin_id_3000] = bin;
-        }
-
-        /* For integrated loudness, gating blocks are 400ms long with 75%
-         * overlap (see BS.1770-2 p5), so a re-computation is needed each 100ms
-         * (4800 samples at 48kHz). */
-        if (++ebur128->sample_count == 4800) {
-            double loudness_400, loudness_3000;
-            double power_400 = 1e-12, power_3000 = 1e-12;
-            AVFilterLink *outlink = ctx->outputs[0];
-            const int64_t pts = insamples->pts +
-                av_rescale_q(idx_insample, (AVRational){ 1, inlink->sample_rate },
-                             outlink->time_base);
-
-            ebur128->sample_count = 0;
-
-#define COMPUTE_LOUDNESS(m, time) do {                                              \
-    if (ebur128->i##time.filled) {                                                  \
-        /* weighting sum of the last <time> ms */                                   \
-        for (ch = 0; ch < nb_channels; ch++)                                        \
-            power_##time += ebur128->ch_weighting[ch] * ebur128->i##time.sum[ch];   \
-        power_##time /= I##time##_BINS;                                             \
-    }                                                                               \
-    loudness_##time = LOUDNESS(power_##time);                                       \
-} while (0)
-
-            COMPUTE_LOUDNESS(M,  400);
-            COMPUTE_LOUDNESS(S, 3000);
-
-            /* Integrated loudness */
-#define I_GATE_THRES -10  // initially defined to -8 LU in the first EBU standard
-
-            if (loudness_400 >= ABS_THRES) {
-                double integrated_sum = 0;
-                int nb_integrated = 0;
-                int gate_hist_pos = gate_update(&ebur128->i400, power_400,
-                                                loudness_400, I_GATE_THRES);
-
-                /* compute integrated loudness by summing the histogram values
-                 * above the relative threshold */
-                for (i = gate_hist_pos; i < HIST_SIZE; i++) {
-                    const int nb_v = ebur128->i400.histogram[i].count;
-                    nb_integrated  += nb_v;
-                    integrated_sum += nb_v * ebur128->i400.histogram[i].energy;
-                }
-                if (nb_integrated)
-                    ebur128->integrated_loudness = LOUDNESS(integrated_sum / nb_integrated);
-            }
-
-            /* LRA */
-#define LRA_GATE_THRES -20
-#define LRA_LOWER_PRC   10
-#define LRA_HIGHER_PRC  95
-
-            /* XXX: example code in EBU 3342 is ">=" but formula in BS.1770
-             * specs is ">" */
-            if (loudness_3000 >= ABS_THRES) {
-                int nb_powers = 0;
-                int gate_hist_pos = gate_update(&ebur128->i3000, power_3000,
-                                                loudness_3000, LRA_GATE_THRES);
-
-                for (i = gate_hist_pos; i < HIST_SIZE; i++)
-                    nb_powers += ebur128->i3000.histogram[i].count;
-                if (nb_powers) {
-                    int n, nb_pow;
-
-                    /* get lower loudness to consider */
-                    n = 0;
-                    nb_pow = LRA_LOWER_PRC  * nb_powers / 100. + 0.5;
-                    for (i = gate_hist_pos; i < HIST_SIZE; i++) {
-                        n += ebur128->i3000.histogram[i].count;
-                        if (n >= nb_pow) {
-                            ebur128->lra_low = ebur128->i3000.histogram[i].loudness;
-                            break;
-                        }
-                    }
-
-                    /* get higher loudness to consider */
-                    n = nb_powers;
-                    nb_pow = LRA_HIGHER_PRC * nb_powers / 100. + 0.5;
-                    for (i = HIST_SIZE - 1; i >= 0; i--) {
-                        n -= ebur128->i3000.histogram[i].count;
-                        if (n < nb_pow) {
-                            ebur128->lra_high = ebur128->i3000.histogram[i].loudness;
-                            break;
-                        }
-                    }
-
-                    // XXX: show low & high on the graph?
-                    ebur128->loudness_range = ebur128->lra_high - ebur128->lra_low;
-                }
-            }
-
-#define LOG_FMT "M:%6.1f S:%6.1f     I:%6.1f LUFS     LRA:%6.1f LU"
-
-            /* push one video frame */
-            if (ebur128->do_video) {
-                int x, y, ret;
-                uint8_t *p;
-
-                const int y_loudness_lu_graph = lu_to_y(ebur128, loudness_3000 + 23);
-                const int y_loudness_lu_gauge = lu_to_y(ebur128, loudness_400  + 23);
-
-                /* draw the graph using the short-term loudness */
-                p = pic->data[0] + ebur128->graph.y*pic->linesize[0] + ebur128->graph.x*3;
-                for (y = 0; y < ebur128->graph.h; y++) {
-                    const uint8_t *c = get_graph_color(ebur128, y_loudness_lu_graph, y);
-
-                    memmove(p, p + 3, (ebur128->graph.w - 1) * 3);
-                    memcpy(p + (ebur128->graph.w - 1) * 3, c, 3);
-                    p += pic->linesize[0];
-                }
-
-                /* draw the gauge using the momentary loudness */
-                p = pic->data[0] + ebur128->gauge.y*pic->linesize[0] + ebur128->gauge.x*3;
-                for (y = 0; y < ebur128->gauge.h; y++) {
-                    const uint8_t *c = get_graph_color(ebur128, y_loudness_lu_gauge, y);
-
-                    for (x = 0; x < ebur128->gauge.w; x++)
-                        memcpy(p + x*3, c, 3);
-                    p += pic->linesize[0];
-                }
-
-                /* draw textual info */
-                drawtext(pic, PAD, PAD - PAD/2, FONT16, font_colors,
-                         LOG_FMT "     ", // padding to erase trailing characters
-                         loudness_400, loudness_3000,
-                         ebur128->integrated_loudness, ebur128->loudness_range);
-
-                /* set pts and push frame */
-                pic->pts = pts;
-                ret = ff_filter_frame(outlink, av_frame_clone(pic));
-                if (ret < 0)
-                    return ret;
-            }
-
-            if (ebur128->metadata) { /* happens only once per filter_frame call */
-                char metabuf[128];
-#define META_PREFIX "lavfi.r128."
-
-#define SET_META(name, var) do {                                            \
-    snprintf(metabuf, sizeof(metabuf), "%.3f", var);                        \
-    av_dict_set(&insamples->metadata, name, metabuf, 0);                    \
-} while (0)
-
-#define SET_META_PEAK(name, ptype) do {                                     \
-    if (ebur128->peak_mode & PEAK_MODE_ ## ptype ## _PEAKS) {               \
-        char key[64];                                                       \
-        for (ch = 0; ch < nb_channels; ch++) {                              \
-            snprintf(key, sizeof(key),                                      \
-                     META_PREFIX AV_STRINGIFY(name) "_peaks_ch%d", ch);     \
-            SET_META(key, ebur128->name##_peaks[ch]);                       \
-        }                                                                   \
-    }                                                                       \
-} while (0)
-
-                SET_META(META_PREFIX "M",        loudness_400);
-                SET_META(META_PREFIX "S",        loudness_3000);
-                SET_META(META_PREFIX "I",        ebur128->integrated_loudness);
-                SET_META(META_PREFIX "LRA",      ebur128->loudness_range);
-                SET_META(META_PREFIX "LRA.low",  ebur128->lra_low);
-                SET_META(META_PREFIX "LRA.high", ebur128->lra_high);
-
-                SET_META_PEAK(sample, SAMPLES);
-                SET_META_PEAK(true,   TRUE);
-            }
-
-            av_log(ctx, ebur128->loglevel, "t: %-10s " LOG_FMT,
-                   av_ts2timestr(pts, &outlink->time_base),
-                   loudness_400, loudness_3000,
-                   ebur128->integrated_loudness, ebur128->loudness_range);
-
-#define PRINT_PEAKS(str, sp, ptype) do {                            \
-    if (ebur128->peak_mode & PEAK_MODE_ ## ptype ## _PEAKS) {       \
-        av_log(ctx, ebur128->loglevel, "  " str ":");               \
-        for (ch = 0; ch < nb_channels; ch++)                        \
-            av_log(ctx, ebur128->loglevel, " %5.1f", DBFS(sp[ch])); \
-        av_log(ctx, ebur128->loglevel, " dBFS");                    \
-    }                                                               \
-} while (0)
-
-            PRINT_PEAKS("SPK", ebur128->sample_peaks, SAMPLES);
-            PRINT_PEAKS("FTPK", ebur128->true_peaks_per_frame, TRUE);
-            PRINT_PEAKS("TPK", ebur128->true_peaks,   TRUE);
-            av_log(ctx, ebur128->loglevel, "\n");
-        }
-    }
-
-    return ff_filter_frame(ctx->outputs[ebur128->do_video], insamples);
-}
-
-static int query_formats(AVFilterContext *ctx)
-{
-    EBUR128Context *ebur128 = ctx->priv;
-    AVFilterFormats *formats;
-    AVFilterChannelLayouts *layouts;
-    AVFilterLink *inlink = ctx->inputs[0];
-    AVFilterLink *outlink = ctx->outputs[0];
-
-    static const enum AVSampleFormat sample_fmts[] = { AV_SAMPLE_FMT_DBL, AV_SAMPLE_FMT_NONE };
-    static const int input_srate[] = {48000, -1}; // ITU-R BS.1770 provides coeff only for 48kHz
-    static const enum AVPixelFormat pix_fmts[] = { AV_PIX_FMT_RGB24, AV_PIX_FMT_NONE };
-
-    /* set optional output video format */
-    if (ebur128->do_video) {
-        formats = ff_make_format_list(pix_fmts);
-        if (!formats)
-            return AVERROR(ENOMEM);
-        ff_formats_ref(formats, &outlink->in_formats);
-        outlink = ctx->outputs[1];
-    }
-
-    /* set input and output audio formats
-     * Note: ff_set_common_* functions are not used because they affect all the
-     * links, and thus break the video format negotiation */
-    formats = ff_make_format_list(sample_fmts);
-    if (!formats)
-        return AVERROR(ENOMEM);
-    ff_formats_ref(formats, &inlink->out_formats);
-    ff_formats_ref(formats, &outlink->in_formats);
-
-    layouts = ff_all_channel_layouts();
-    if (!layouts)
-        return AVERROR(ENOMEM);
-    ff_channel_layouts_ref(layouts, &inlink->out_channel_layouts);
-    ff_channel_layouts_ref(layouts, &outlink->in_channel_layouts);
-
-    formats = ff_make_format_list(input_srate);
-    if (!formats)
-        return AVERROR(ENOMEM);
-    ff_formats_ref(formats, &inlink->out_samplerates);
-    ff_formats_ref(formats, &outlink->in_samplerates);
-
-    return 0;
-}
-
-static av_cold void uninit(AVFilterContext *ctx)
-{
-    int i;
-    EBUR128Context *ebur128 = ctx->priv;
-
-    av_log(ctx, AV_LOG_INFO, "Summary:\n\n"
-           "  Integrated loudness:\n"
-           "    I:         %5.1f LUFS\n"
-           "    Threshold: %5.1f LUFS\n\n"
-           "  Loudness range:\n"
-           "    LRA:       %5.1f LU\n"
-           "    Threshold: %5.1f LUFS\n"
-           "    LRA low:   %5.1f LUFS\n"
-           "    LRA high:  %5.1f LUFS",
-           ebur128->integrated_loudness, ebur128->i400.rel_threshold,
-           ebur128->loudness_range,      ebur128->i3000.rel_threshold,
-           ebur128->lra_low, ebur128->lra_high);
-
-#define PRINT_PEAK_SUMMARY(str, sp, ptype) do {                  \
-    int ch;                                                      \
-    double maxpeak;                                              \
-    maxpeak = 0.0;                                               \
-    if (ebur128->peak_mode & PEAK_MODE_ ## ptype ## _PEAKS) {    \
-        for (ch = 0; ch < ebur128->nb_channels; ch++)            \
-            maxpeak = FFMAX(maxpeak, sp[ch]);                    \
-        av_log(ctx, AV_LOG_INFO, "\n\n  " str " peak:\n"         \
-               "    Peak:      %5.1f dBFS",                      \
-               DBFS(maxpeak));                                   \
-    }                                                            \
-} while (0)
-
-    PRINT_PEAK_SUMMARY("Sample", ebur128->sample_peaks, SAMPLES);
-    PRINT_PEAK_SUMMARY("True",   ebur128->true_peaks,   TRUE);
-    av_log(ctx, AV_LOG_INFO, "\n");
-
-    av_freep(&ebur128->y_line_ref);
-    av_freep(&ebur128->ch_weighting);
-    av_freep(&ebur128->true_peaks);
-    av_freep(&ebur128->sample_peaks);
-    av_freep(&ebur128->true_peaks_per_frame);
-    av_freep(&ebur128->i400.histogram);
-    av_freep(&ebur128->i3000.histogram);
-    for (i = 0; i < ebur128->nb_channels; i++) {
-        av_freep(&ebur128->i400.cache[i]);
-        av_freep(&ebur128->i3000.cache[i]);
-    }
-    for (i = 0; i < ctx->nb_outputs; i++)
-        av_freep(&ctx->output_pads[i].name);
-    av_frame_free(&ebur128->outpicref);
-#if CONFIG_SWRESAMPLE
-    av_freep(&ebur128->swr_buf);
-    swr_free(&ebur128->swr_ctx);
-#endif
-}
-
-static const AVFilterPad ebur128_inputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_AUDIO,
-        .filter_frame = filter_frame,
-        .config_props = config_audio_input,
-    },
-    { NULL }
-};
-
-AVFilter ff_af_ebur128 = {
-    .name          = "ebur128",
-    .description   = NULL_IF_CONFIG_SMALL("EBU R128 scanner."),
-    .priv_size     = sizeof(EBUR128Context),
-    .init          = init,
-    .uninit        = uninit,
-    .query_formats = query_formats,
-    .inputs        = ebur128_inputs,
-    .outputs       = NULL,
-    .priv_class    = &ebur128_class,
-    .flags         = AVFILTER_FLAG_DYNAMIC_OUTPUTS,
-};
diff --git a/libavfilter/libmpcodecs/av_helpers.h b/libavfilter/libmpcodecs/av_helpers.h
deleted file mode 100644
index 90b67d5..0000000
--- a/libavfilter/libmpcodecs/av_helpers.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Generic libav* helpers
- *
- * This file is part of MPlayer.
- *
- * MPlayer is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * MPlayer is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with MPlayer; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#ifndef MPLAYER_AV_HELPERS_H
-#define MPLAYER_AV_HELPERS_H
-
-void ff_init_avcodec(void);
-void ff_init_avformat(void);
-
-#endif /* MPLAYER_AV_HELPERS_H */
diff --git a/libavfilter/libmpcodecs/cpudetect.h b/libavfilter/libmpcodecs/cpudetect.h
deleted file mode 100644
index 710f6e6..0000000
--- a/libavfilter/libmpcodecs/cpudetect.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * This file is part of MPlayer.
- *
- * MPlayer is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * MPlayer is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with MPlayer; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#ifndef MPLAYER_CPUDETECT_H
-#define MPLAYER_CPUDETECT_H
-
-#define CPUTYPE_I386    3
-#define CPUTYPE_I486    4
-#define CPUTYPE_I586    5
-#define CPUTYPE_I686    6
-
-#include "libavutil/x86_cpu.h"
-
-typedef struct cpucaps_s {
-    int cpuType;
-    int cpuModel;
-    int cpuStepping;
-    int hasMMX;
-    int hasMMX2;
-    int has3DNow;
-    int has3DNowExt;
-    int hasSSE;
-    int hasSSE2;
-    int hasSSE3;
-    int hasSSSE3;
-    int hasSSE4;
-    int hasSSE42;
-    int hasSSE4a;
-    int hasAVX;
-    int isX86;
-    unsigned cl_size; /* size of cache line */
-    int hasAltiVec;
-    int hasTSC;
-} CpuCaps;
-
-extern CpuCaps ff_gCpuCaps;
-
-void ff_do_cpuid(unsigned int ax, unsigned int *p);
-
-void ff_GetCpuCaps(CpuCaps *caps);
-
-/* returned value is malloc()'ed so free() it after use */
-char *ff_GetCpuFriendlyName(unsigned int regs[], unsigned int regs2[]);
-
-#endif /* MPLAYER_CPUDETECT_H */
diff --git a/libavfilter/libmpcodecs/img_format.c b/libavfilter/libmpcodecs/img_format.c
deleted file mode 100644
index 61bf898..0000000
--- a/libavfilter/libmpcodecs/img_format.c
+++ /dev/null
@@ -1,233 +0,0 @@
-/*
- * This file is part of MPlayer.
- *
- * MPlayer is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * MPlayer is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with MPlayer; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#include "config.h"
-#include "img_format.h"
-#include "stdio.h"
-#include "libavutil/bswap.h"
-
-const char *ff_vo_format_name(int format)
-{
-    static char unknown_format[20];
-    switch(format)
-    {
-    case IMGFMT_RGB1:    return "RGB 1-bit";
-    case IMGFMT_RGB4:    return "RGB 4-bit";
-    case IMGFMT_RG4B:    return "RGB 4-bit per byte";
-    case IMGFMT_RGB8:    return "RGB 8-bit";
-    case IMGFMT_RGB12:   return "RGB 12-bit";
-    case IMGFMT_RGB15:   return "RGB 15-bit";
-    case IMGFMT_RGB16:   return "RGB 16-bit";
-    case IMGFMT_RGB24:   return "RGB 24-bit";
-//  case IMGFMT_RGB32:   return "RGB 32-bit";
-    case IMGFMT_RGB48LE: return "RGB 48-bit LE";
-    case IMGFMT_RGB48BE: return "RGB 48-bit BE";
-    case IMGFMT_RGB64LE: return "RGB 64-bit LE";
-    case IMGFMT_RGB64BE: return "RGB 64-bit BE";
-    case IMGFMT_BGR1:    return "BGR 1-bit";
-    case IMGFMT_BGR4:    return "BGR 4-bit";
-    case IMGFMT_BG4B:    return "BGR 4-bit per byte";
-    case IMGFMT_BGR8:    return "BGR 8-bit";
-    case IMGFMT_BGR12:   return "BGR 12-bit";
-    case IMGFMT_BGR15:   return "BGR 15-bit";
-    case IMGFMT_BGR16:   return "BGR 16-bit";
-    case IMGFMT_BGR24:   return "BGR 24-bit";
-//  case IMGFMT_BGR32:   return "BGR 32-bit";
-    case IMGFMT_ABGR:    return "ABGR";
-    case IMGFMT_BGRA:    return "BGRA";
-    case IMGFMT_ARGB:    return "ARGB";
-    case IMGFMT_RGBA:    return "RGBA";
-    case IMGFMT_GBR24P:  return "Planar GBR 24-bit";
-    case IMGFMT_GBR12P:  return "Planar GBR 36-bit";
-    case IMGFMT_GBR14P:  return "Planar GBR 42-bit";
-    case IMGFMT_YVU9:    return "Planar YVU9";
-    case IMGFMT_IF09:    return "Planar IF09";
-    case IMGFMT_YV12:    return "Planar YV12";
-    case IMGFMT_I420:    return "Planar I420";
-    case IMGFMT_IYUV:    return "Planar IYUV";
-    case IMGFMT_CLPL:    return "Planar CLPL";
-    case IMGFMT_Y800:    return "Planar Y800";
-    case IMGFMT_Y8:      return "Planar Y8";
-    case IMGFMT_Y8A:     return "Planar Y8 with alpha";
-    case IMGFMT_Y16_LE:  return "Planar Y16 little-endian";
-    case IMGFMT_Y16_BE:  return "Planar Y16 big-endian";
-    case IMGFMT_420P16_LE: return "Planar 420P 16-bit little-endian";
-    case IMGFMT_420P16_BE: return "Planar 420P 16-bit big-endian";
-    case IMGFMT_420P14_LE: return "Planar 420P 14-bit little-endian";
-    case IMGFMT_420P14_BE: return "Planar 420P 14-bit big-endian";
-    case IMGFMT_420P12_LE: return "Planar 420P 12-bit little-endian";
-    case IMGFMT_420P12_BE: return "Planar 420P 12-bit big-endian";
-    case IMGFMT_420P10_LE: return "Planar 420P 10-bit little-endian";
-    case IMGFMT_420P10_BE: return "Planar 420P 10-bit big-endian";
-    case IMGFMT_420P9_LE:  return "Planar 420P 9-bit little-endian";
-    case IMGFMT_420P9_BE:  return "Planar 420P 9-bit big-endian";
-    case IMGFMT_422P16_LE: return "Planar 422P 16-bit little-endian";
-    case IMGFMT_422P16_BE: return "Planar 422P 16-bit big-endian";
-    case IMGFMT_422P14_LE: return "Planar 422P 14-bit little-endian";
-    case IMGFMT_422P14_BE: return "Planar 422P 14-bit big-endian";
-    case IMGFMT_422P12_LE: return "Planar 422P 12-bit little-endian";
-    case IMGFMT_422P12_BE: return "Planar 422P 12-bit big-endian";
-    case IMGFMT_422P10_LE: return "Planar 422P 10-bit little-endian";
-    case IMGFMT_422P10_BE: return "Planar 422P 10-bit big-endian";
-    case IMGFMT_422P9_LE:  return "Planar 422P 9-bit little-endian";
-    case IMGFMT_422P9_BE:  return "Planar 422P 9-bit big-endian";
-    case IMGFMT_444P16_LE: return "Planar 444P 16-bit little-endian";
-    case IMGFMT_444P16_BE: return "Planar 444P 16-bit big-endian";
-    case IMGFMT_444P14_LE: return "Planar 444P 14-bit little-endian";
-    case IMGFMT_444P14_BE: return "Planar 444P 14-bit big-endian";
-    case IMGFMT_444P12_LE: return "Planar 444P 12-bit little-endian";
-    case IMGFMT_444P12_BE: return "Planar 444P 12-bit big-endian";
-    case IMGFMT_444P10_LE: return "Planar 444P 10-bit little-endian";
-    case IMGFMT_444P10_BE: return "Planar 444P 10-bit big-endian";
-    case IMGFMT_444P9_LE:  return "Planar 444P 9-bit little-endian";
-    case IMGFMT_444P9_BE:  return "Planar 444P 9-bit big-endian";
-    case IMGFMT_420A: return "Planar 420P with alpha";
-    case IMGFMT_444P: return "Planar 444P";
-    case IMGFMT_444A: return "Planar 444P with alpha";
-    case IMGFMT_422P: return "Planar 422P";
-    case IMGFMT_422A: return "Planar 422P with alpha";
-    case IMGFMT_411P: return "Planar 411P";
-    case IMGFMT_NV12: return "Planar NV12";
-    case IMGFMT_NV21: return "Planar NV21";
-    case IMGFMT_HM12: return "Planar NV12 Macroblock";
-    case IMGFMT_IUYV: return "Packed IUYV";
-    case IMGFMT_IY41: return "Packed IY41";
-    case IMGFMT_IYU1: return "Packed IYU1";
-    case IMGFMT_IYU2: return "Packed IYU2";
-    case IMGFMT_UYVY: return "Packed UYVY";
-    case IMGFMT_UYNV: return "Packed UYNV";
-    case IMGFMT_cyuv: return "Packed CYUV";
-    case IMGFMT_Y422: return "Packed Y422";
-    case IMGFMT_YUY2: return "Packed YUY2";
-    case IMGFMT_YUNV: return "Packed YUNV";
-    case IMGFMT_YVYU: return "Packed YVYU";
-    case IMGFMT_Y41P: return "Packed Y41P";
-    case IMGFMT_Y211: return "Packed Y211";
-    case IMGFMT_Y41T: return "Packed Y41T";
-    case IMGFMT_Y42T: return "Packed Y42T";
-    case IMGFMT_V422: return "Packed V422";
-    case IMGFMT_V655: return "Packed V655";
-    case IMGFMT_CLJR: return "Packed CLJR";
-    case IMGFMT_YUVP: return "Packed YUVP";
-    case IMGFMT_UYVP: return "Packed UYVP";
-    case IMGFMT_MPEGPES:         return "Mpeg PES";
-    case IMGFMT_ZRMJPEGNI:       return "Zoran MJPEG non-interlaced";
-    case IMGFMT_ZRMJPEGIT:       return "Zoran MJPEG top field first";
-    case IMGFMT_ZRMJPEGIB:       return "Zoran MJPEG bottom field first";
-    case IMGFMT_XVMC_MOCO_MPEG2: return "MPEG1/2 Motion Compensation";
-    case IMGFMT_XVMC_IDCT_MPEG2: return "MPEG1/2 Motion Compensation and IDCT";
-    case IMGFMT_VDPAU_MPEG1:     return "MPEG1 VDPAU acceleration";
-    case IMGFMT_VDPAU_MPEG2:     return "MPEG2 VDPAU acceleration";
-    case IMGFMT_VDPAU_H264:      return "H.264 VDPAU acceleration";
-    case IMGFMT_VDPAU_MPEG4:     return "MPEG-4 Part 2 VDPAU acceleration";
-    case IMGFMT_VDPAU_WMV3:      return "WMV3 VDPAU acceleration";
-    case IMGFMT_VDPAU_VC1:       return "VC1 VDPAU acceleration";
-    }
-    snprintf(unknown_format,20,"Unknown 0x%04x",format);
-    return unknown_format;
-}
-
-int ff_mp_get_chroma_shift(int format, int *x_shift, int *y_shift, int *component_bits)
-{
-    int xs = 0, ys = 0;
-    int bpp;
-    int err = 0;
-    int bits = 8;
-    if ((format & 0xff0000f0) == 0x34000050)
-        format = av_bswap32(format);
-    if ((format & 0xf00000ff) == 0x50000034) {
-        switch (format >> 24) {
-        case 0x50:
-            break;
-        case 0x51:
-            bits = 16;
-            break;
-        case 0x52:
-            bits = 10;
-            break;
-        case 0x53:
-            bits = 9;
-            break;
-        default:
-            err = 1;
-            break;
-        }
-        switch (format & 0x00ffffff) {
-        case 0x00343434: // 444
-            xs = 0;
-            ys = 0;
-            break;
-        case 0x00323234: // 422
-            xs = 1;
-            ys = 0;
-            break;
-        case 0x00303234: // 420
-            xs = 1;
-            ys = 1;
-            break;
-        case 0x00313134: // 411
-            xs = 2;
-            ys = 0;
-            break;
-        case 0x00303434: // 440
-            xs = 0;
-            ys = 1;
-            break;
-        default:
-            err = 1;
-            break;
-        }
-    } else switch (format) {
-    case IMGFMT_444A:
-        xs = 0;
-        ys = 0;
-        break;
-    case IMGFMT_422A:
-        xs = 1;
-        ys = 0;
-        break;
-    case IMGFMT_420A:
-    case IMGFMT_I420:
-    case IMGFMT_IYUV:
-    case IMGFMT_YV12:
-        xs = 1;
-        ys = 1;
-        break;
-    case IMGFMT_IF09:
-    case IMGFMT_YVU9:
-        xs = 2;
-        ys = 2;
-        break;
-    case IMGFMT_Y8:
-    case IMGFMT_Y800:
-        xs = 31;
-        ys = 31;
-        break;
-    default:
-        err = 1;
-        break;
-    }
-    if (x_shift) *x_shift = xs;
-    if (y_shift) *y_shift = ys;
-    if (component_bits) *component_bits = bits;
-    bpp = 8 + ((16 >> xs) >> ys);
-    if (format == IMGFMT_420A || format == IMGFMT_422A || format == IMGFMT_444A)
-        bpp += 8;
-    bpp *= (bits + 7) >> 3;
-    return err ? 0 : bpp;
-}
diff --git a/libavfilter/libmpcodecs/img_format.h b/libavfilter/libmpcodecs/img_format.h
deleted file mode 100644
index d4d64d8..0000000
--- a/libavfilter/libmpcodecs/img_format.h
+++ /dev/null
@@ -1,300 +0,0 @@
-/*
- * This file is part of MPlayer.
- *
- * MPlayer is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * MPlayer is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with MPlayer; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#ifndef MPLAYER_IMG_FORMAT_H
-#define MPLAYER_IMG_FORMAT_H
-
-#include "config.h"
-
-/* RGB/BGR Formats */
-
-#define IMGFMT_RGB_MASK 0xFFFFFF00
-#define IMGFMT_RGB (('R'<<24)|('G'<<16)|('B'<<8))
-#define IMGFMT_RGB1  (IMGFMT_RGB|1)
-#define IMGFMT_RGB4  (IMGFMT_RGB|4)
-#define IMGFMT_RGB4_CHAR  (IMGFMT_RGB|4|128) // RGB4 with 1 pixel per byte
-#define IMGFMT_RGB8  (IMGFMT_RGB|8)
-#define IMGFMT_RGB12 (IMGFMT_RGB|12)
-#define IMGFMT_RGB15 (IMGFMT_RGB|15)
-#define IMGFMT_RGB16 (IMGFMT_RGB|16)
-#define IMGFMT_RGB24 (IMGFMT_RGB|24)
-#define IMGFMT_RGB32 (IMGFMT_RGB|32)
-#define IMGFMT_RGB48LE (IMGFMT_RGB|48)
-#define IMGFMT_RGB48BE (IMGFMT_RGB|48|128)
-#define IMGFMT_RGB64LE (IMGFMT_RGB|64)
-#define IMGFMT_RGB64BE (IMGFMT_RGB|64|128)
-
-#define IMGFMT_BGR_MASK 0xFFFFFF00
-#define IMGFMT_BGR (('B'<<24)|('G'<<16)|('R'<<8))
-#define IMGFMT_BGR1  (IMGFMT_BGR|1)
-#define IMGFMT_BGR4  (IMGFMT_BGR|4)
-#define IMGFMT_BGR4_CHAR (IMGFMT_BGR|4|128) // BGR4 with 1 pixel per byte
-#define IMGFMT_BGR8  (IMGFMT_BGR|8)
-#define IMGFMT_BGR12 (IMGFMT_BGR|12)
-#define IMGFMT_BGR15 (IMGFMT_BGR|15)
-#define IMGFMT_BGR16 (IMGFMT_BGR|16)
-#define IMGFMT_BGR24 (IMGFMT_BGR|24)
-#define IMGFMT_BGR32 (IMGFMT_BGR|32)
-
-#define IMGFMT_GBR24P (('G'<<24)|('B'<<16)|('R'<<8)|24)
-#define IMGFMT_GBR12PLE (('G'<<24)|('B'<<16)|('R'<<8)|36)
-#define IMGFMT_GBR12PBE (('G'<<24)|('B'<<16)|('R'<<8)|36|128)
-#define IMGFMT_GBR14PLE (('G'<<24)|('B'<<16)|('R'<<8)|42)
-#define IMGFMT_GBR14PBE (('G'<<24)|('B'<<16)|('R'<<8)|42|128)
-
-#if HAVE_BIGENDIAN
-#define IMGFMT_ABGR    IMGFMT_RGB32
-#define IMGFMT_BGRA    (IMGFMT_RGB32|128)
-#define IMGFMT_ARGB    IMGFMT_BGR32
-#define IMGFMT_RGBA    (IMGFMT_BGR32|128)
-#define IMGFMT_RGB64NE IMGFMT_RGB64BE
-#define IMGFMT_RGB48NE IMGFMT_RGB48BE
-#define IMGFMT_RGB12BE IMGFMT_RGB12
-#define IMGFMT_RGB12LE (IMGFMT_RGB12|128)
-#define IMGFMT_RGB15BE IMGFMT_RGB15
-#define IMGFMT_RGB15LE (IMGFMT_RGB15|128)
-#define IMGFMT_RGB16BE IMGFMT_RGB16
-#define IMGFMT_RGB16LE (IMGFMT_RGB16|128)
-#define IMGFMT_BGR12BE IMGFMT_BGR12
-#define IMGFMT_BGR12LE (IMGFMT_BGR12|128)
-#define IMGFMT_BGR15BE IMGFMT_BGR15
-#define IMGFMT_BGR15LE (IMGFMT_BGR15|128)
-#define IMGFMT_BGR16BE IMGFMT_BGR16
-#define IMGFMT_BGR16LE (IMGFMT_BGR16|128)
-#define IMGFMT_GBR12P IMGFMT_GBR12PBE
-#define IMGFMT_GBR14P IMGFMT_GBR14PBE
-#else
-#define IMGFMT_ABGR (IMGFMT_BGR32|128)
-#define IMGFMT_BGRA IMGFMT_BGR32
-#define IMGFMT_ARGB (IMGFMT_RGB32|128)
-#define IMGFMT_RGBA IMGFMT_RGB32
-#define IMGFMT_RGB64NE IMGFMT_RGB64LE
-#define IMGFMT_RGB48NE IMGFMT_RGB48LE
-#define IMGFMT_RGB12BE (IMGFMT_RGB12|128)
-#define IMGFMT_RGB12LE IMGFMT_RGB12
-#define IMGFMT_RGB15BE (IMGFMT_RGB15|128)
-#define IMGFMT_RGB15LE IMGFMT_RGB15
-#define IMGFMT_RGB16BE (IMGFMT_RGB16|128)
-#define IMGFMT_RGB16LE IMGFMT_RGB16
-#define IMGFMT_BGR12BE (IMGFMT_BGR12|128)
-#define IMGFMT_BGR12LE IMGFMT_BGR12
-#define IMGFMT_BGR15BE (IMGFMT_BGR15|128)
-#define IMGFMT_BGR15LE IMGFMT_BGR15
-#define IMGFMT_BGR16BE (IMGFMT_BGR16|128)
-#define IMGFMT_BGR16LE IMGFMT_BGR16
-#define IMGFMT_GBR12P IMGFMT_GBR12PLE
-#define IMGFMT_GBR14P IMGFMT_GBR14PLE
-#endif
-
-/* old names for compatibility */
-#define IMGFMT_RG4B  IMGFMT_RGB4_CHAR
-#define IMGFMT_BG4B  IMGFMT_BGR4_CHAR
-
-#define IMGFMT_IS_RGB(fmt) (((fmt)&IMGFMT_RGB_MASK)==IMGFMT_RGB)
-#define IMGFMT_IS_BGR(fmt) (((fmt)&IMGFMT_BGR_MASK)==IMGFMT_BGR)
-
-#define IMGFMT_RGB_DEPTH(fmt) ((fmt)&0x7F)
-#define IMGFMT_BGR_DEPTH(fmt) ((fmt)&0x7F)
-
-
-/* Planar YUV Formats */
-
-#define IMGFMT_YVU9 0x39555659
-#define IMGFMT_IF09 0x39304649
-#define IMGFMT_YV12 0x32315659
-#define IMGFMT_I420 0x30323449
-#define IMGFMT_IYUV 0x56555949
-#define IMGFMT_CLPL 0x4C504C43
-#define IMGFMT_Y800 0x30303859
-#define IMGFMT_Y8   0x20203859
-#define IMGFMT_NV12 0x3231564E
-#define IMGFMT_NV21 0x3132564E
-#define IMGFMT_Y16_LE 0x20363159
-
-/* unofficial Planar Formats, FIXME if official 4CC exists */
-#define IMGFMT_444P 0x50343434
-#define IMGFMT_422P 0x50323234
-#define IMGFMT_411P 0x50313134
-#define IMGFMT_440P 0x50303434
-#define IMGFMT_HM12 0x32314D48
-#define IMGFMT_Y16_BE 0x59313620
-
-// Gray with alpha
-#define IMGFMT_Y8A 0x59320008
-// 4:2:0 planar with alpha
-#define IMGFMT_420A 0x41303234
-// 4:2:2 planar with alpha
-#define IMGFMT_422A 0x41323234
-// 4:4:4 planar with alpha
-#define IMGFMT_444A 0x41343434
-
-#define IMGFMT_444P16_LE 0x51343434
-#define IMGFMT_444P16_BE 0x34343451
-#define IMGFMT_444P14_LE 0x54343434
-#define IMGFMT_444P14_BE 0x34343454
-#define IMGFMT_444P12_LE 0x55343434
-#define IMGFMT_444P12_BE 0x34343455
-#define IMGFMT_444P10_LE 0x52343434
-#define IMGFMT_444P10_BE 0x34343452
-#define IMGFMT_444P9_LE  0x53343434
-#define IMGFMT_444P9_BE  0x34343453
-#define IMGFMT_422P16_LE 0x51323234
-#define IMGFMT_422P16_BE 0x34323251
-#define IMGFMT_422P14_LE 0x54323234
-#define IMGFMT_422P14_BE 0x34323254
-#define IMGFMT_422P12_LE 0x55323234
-#define IMGFMT_422P12_BE 0x34323255
-#define IMGFMT_422P10_LE 0x52323234
-#define IMGFMT_422P10_BE 0x34323252
-#define IMGFMT_422P9_LE  0x53323234
-#define IMGFMT_422P9_BE  0x34323253
-#define IMGFMT_420P16_LE 0x51303234
-#define IMGFMT_420P16_BE 0x34323051
-#define IMGFMT_420P14_LE 0x54303234
-#define IMGFMT_420P14_BE 0x34323054
-#define IMGFMT_420P12_LE 0x55303234
-#define IMGFMT_420P12_BE 0x34323055
-#define IMGFMT_420P10_LE 0x52303234
-#define IMGFMT_420P10_BE 0x34323052
-#define IMGFMT_420P9_LE  0x53303234
-#define IMGFMT_420P9_BE  0x34323053
-#if HAVE_BIGENDIAN
-#define IMGFMT_444P16 IMGFMT_444P16_BE
-#define IMGFMT_444P14 IMGFMT_444P14_BE
-#define IMGFMT_444P12 IMGFMT_444P12_BE
-#define IMGFMT_444P10 IMGFMT_444P10_BE
-#define IMGFMT_444P9  IMGFMT_444P9_BE
-#define IMGFMT_422P16 IMGFMT_422P16_BE
-#define IMGFMT_422P14 IMGFMT_422P14_BE
-#define IMGFMT_422P12 IMGFMT_422P12_BE
-#define IMGFMT_422P10 IMGFMT_422P10_BE
-#define IMGFMT_422P9  IMGFMT_422P9_BE
-#define IMGFMT_420P16 IMGFMT_420P16_BE
-#define IMGFMT_420P14 IMGFMT_420P14_BE
-#define IMGFMT_420P12 IMGFMT_420P12_BE
-#define IMGFMT_420P10 IMGFMT_420P10_BE
-#define IMGFMT_420P9  IMGFMT_420P9_BE
-#define IMGFMT_Y16    IMGFMT_Y16_BE
-#define IMGFMT_IS_YUVP16_NE(fmt) IMGFMT_IS_YUVP16_BE(fmt)
-#else
-#define IMGFMT_444P16 IMGFMT_444P16_LE
-#define IMGFMT_444P14 IMGFMT_444P14_LE
-#define IMGFMT_444P12 IMGFMT_444P12_LE
-#define IMGFMT_444P10 IMGFMT_444P10_LE
-#define IMGFMT_444P9  IMGFMT_444P9_LE
-#define IMGFMT_422P16 IMGFMT_422P16_LE
-#define IMGFMT_422P14 IMGFMT_422P14_LE
-#define IMGFMT_422P12 IMGFMT_422P12_LE
-#define IMGFMT_422P10 IMGFMT_422P10_LE
-#define IMGFMT_422P9  IMGFMT_422P9_LE
-#define IMGFMT_420P16 IMGFMT_420P16_LE
-#define IMGFMT_420P14 IMGFMT_420P14_LE
-#define IMGFMT_420P12 IMGFMT_420P12_LE
-#define IMGFMT_420P10 IMGFMT_420P10_LE
-#define IMGFMT_420P9  IMGFMT_420P9_LE
-#define IMGFMT_Y16    IMGFMT_Y16_LE
-#define IMGFMT_IS_YUVP16_NE(fmt) IMGFMT_IS_YUVP16_LE(fmt)
-#endif
-
-#define IMGFMT_IS_YUVP16_LE(fmt) (((fmt - 0x51000034) & 0xfc0000ff) == 0)
-#define IMGFMT_IS_YUVP16_BE(fmt) (((fmt - 0x34000051) & 0xff0000fc) == 0)
-#define IMGFMT_IS_YUVP16(fmt)    (IMGFMT_IS_YUVP16_LE(fmt) || IMGFMT_IS_YUVP16_BE(fmt))
-
-/**
- * \brief Find the corresponding full 16 bit format, i.e. IMGFMT_420P10_LE -> IMGFMT_420P16_LE
- * \return normalized format ID or 0 if none exists.
- */
-static inline int normalize_yuvp16(int fmt) {
-    if (IMGFMT_IS_YUVP16_LE(fmt))
-        return (fmt & 0x00ffffff) | 0x51000000;
-    if (IMGFMT_IS_YUVP16_BE(fmt))
-        return (fmt & 0xffffff00) | 0x00000051;
-    return 0;
-}
-
-/* Packed YUV Formats */
-
-#define IMGFMT_IUYV 0x56595549 // Interlaced UYVY
-#define IMGFMT_IY41 0x31435949 // Interlaced Y41P
-#define IMGFMT_IYU1 0x31555949
-#define IMGFMT_IYU2 0x32555949
-#define IMGFMT_UYVY 0x59565955
-#define IMGFMT_UYNV 0x564E5955 // Exactly same as UYVY
-#define IMGFMT_cyuv 0x76757963 // upside-down UYVY
-#define IMGFMT_Y422 0x32323459 // Exactly same as UYVY
-#define IMGFMT_YUY2 0x32595559
-#define IMGFMT_YUNV 0x564E5559 // Exactly same as YUY2
-#define IMGFMT_YVYU 0x55595659
-#define IMGFMT_Y41P 0x50313459
-#define IMGFMT_Y211 0x31313259
-#define IMGFMT_Y41T 0x54313459 // Y41P, Y lsb = transparency
-#define IMGFMT_Y42T 0x54323459 // UYVY, Y lsb = transparency
-#define IMGFMT_V422 0x32323456 // upside-down UYVY?
-#define IMGFMT_V655 0x35353656
-#define IMGFMT_CLJR 0x524A4C43
-#define IMGFMT_YUVP 0x50565559 // 10-bit YUYV
-#define IMGFMT_UYVP 0x50565955 // 10-bit UYVY
-
-/* Compressed Formats */
-#define IMGFMT_MPEGPES (('M'<<24)|('P'<<16)|('E'<<8)|('S'))
-#define IMGFMT_MJPEG (('M')|('J'<<8)|('P'<<16)|('G'<<24))
-/* Formats that are understood by zoran chips, we include
- * non-interlaced, interlaced top-first, interlaced bottom-first */
-#define IMGFMT_ZRMJPEGNI  (('Z'<<24)|('R'<<16)|('N'<<8)|('I'))
-#define IMGFMT_ZRMJPEGIT (('Z'<<24)|('R'<<16)|('I'<<8)|('T'))
-#define IMGFMT_ZRMJPEGIB (('Z'<<24)|('R'<<16)|('I'<<8)|('B'))
-
-// I think that this code could not be used by any other codec/format
-#define IMGFMT_XVMC 0x1DC70000
-#define IMGFMT_XVMC_MASK 0xFFFF0000
-#define IMGFMT_IS_XVMC(fmt) (((fmt)&IMGFMT_XVMC_MASK)==IMGFMT_XVMC)
-//these are chroma420
-#define IMGFMT_XVMC_MOCO_MPEG2 (IMGFMT_XVMC|0x02)
-#define IMGFMT_XVMC_IDCT_MPEG2 (IMGFMT_XVMC|0x82)
-
-// VDPAU specific format.
-#define IMGFMT_VDPAU               0x1DC80000
-#define IMGFMT_VDPAU_MASK          0xFFFF0000
-#define IMGFMT_IS_VDPAU(fmt)       (((fmt)&IMGFMT_VDPAU_MASK)==IMGFMT_VDPAU)
-#define IMGFMT_VDPAU_MPEG1         (IMGFMT_VDPAU|0x01)
-#define IMGFMT_VDPAU_MPEG2         (IMGFMT_VDPAU|0x02)
-#define IMGFMT_VDPAU_H264          (IMGFMT_VDPAU|0x03)
-#define IMGFMT_VDPAU_WMV3          (IMGFMT_VDPAU|0x04)
-#define IMGFMT_VDPAU_VC1           (IMGFMT_VDPAU|0x05)
-#define IMGFMT_VDPAU_MPEG4         (IMGFMT_VDPAU|0x06)
-
-#define IMGFMT_IS_HWACCEL(fmt) (IMGFMT_IS_VDPAU(fmt) || IMGFMT_IS_XVMC(fmt))
-
-typedef struct {
-    void* data;
-    int size;
-    int id;        // stream id. usually 0x1E0
-    int timestamp; // pts, 90000 Hz counter based
-} vo_mpegpes_t;
-
-const char *ff_vo_format_name(int format);
-
-/**
- * Calculates the scale shifts for the chroma planes for planar YUV
- *
- * \param component_bits bits per component
- * \return bits-per-pixel for format if successful (i.e. format is 3 or 4-planes planar YUV), 0 otherwise
- */
-int ff_mp_get_chroma_shift(int format, int *x_shift, int *y_shift, int *component_bits);
-
-#endif /* MPLAYER_IMG_FORMAT_H */
diff --git a/libavfilter/libmpcodecs/libvo/fastmemcpy.h b/libavfilter/libmpcodecs/libvo/fastmemcpy.h
deleted file mode 100644
index 5a17d01..0000000
--- a/libavfilter/libmpcodecs/libvo/fastmemcpy.h
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * This file is part of MPlayer.
- *
- * MPlayer is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * MPlayer is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with MPlayer; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef MPLAYER_FASTMEMCPY_H
-#define MPLAYER_FASTMEMCPY_H
-
-#include <inttypes.h>
-#include <string.h>
-#include <stddef.h>
-
-void * fast_memcpy(void * to, const void * from, size_t len);
-void * mem2agpcpy(void * to, const void * from, size_t len);
-
-#if ! defined(CONFIG_FASTMEMCPY) || ! (HAVE_MMX || HAVE_MMX2 || HAVE_AMD3DNOW /* || HAVE_SSE || HAVE_SSE2 */)
-#define mem2agpcpy(a,b,c) memcpy(a,b,c)
-#define fast_memcpy(a,b,c) memcpy(a,b,c)
-#endif
-
-static inline void * mem2agpcpy_pic(void * dst, const void * src, int bytesPerLine, int height, int dstStride, int srcStride)
-{
-    int i;
-    void *retval=dst;
-
-    if(dstStride == srcStride)
-    {
-        if (srcStride < 0) {
-                src = (const uint8_t*)src + (height-1)*srcStride;
-                dst = (uint8_t*)dst + (height-1)*dstStride;
-                srcStride = -srcStride;
-        }
-
-        mem2agpcpy(dst, src, srcStride*height);
-    }
-    else
-    {
-        for(i=0; i<height; i++)
-        {
-            mem2agpcpy(dst, src, bytesPerLine);
-            src = (const uint8_t*)src + srcStride;
-            dst = (uint8_t*)dst + dstStride;
-        }
-    }
-
-    return retval;
-}
-
-#define memcpy_pic(d, s, b, h, ds, ss) memcpy_pic2(d, s, b, h, ds, ss, 0)
-#define my_memcpy_pic(d, s, b, h, ds, ss) memcpy_pic2(d, s, b, h, ds, ss, 1)
-
-/**
- * \param limit2width always skip data between end of line and start of next
- *                    instead of copying the full block when strides are the same
- */
-static inline void * memcpy_pic2(void * dst, const void * src,
-                                 int bytesPerLine, int height,
-                                 int dstStride, int srcStride, int limit2width)
-{
-    int i;
-    void *retval=dst;
-
-    if(!limit2width && dstStride == srcStride)
-    {
-        if (srcStride < 0) {
-                src = (const uint8_t*)src + (height-1)*srcStride;
-                dst = (uint8_t*)dst + (height-1)*dstStride;
-                srcStride = -srcStride;
-        }
-
-        fast_memcpy(dst, src, srcStride*height);
-    }
-    else
-    {
-        for(i=0; i<height; i++)
-        {
-            fast_memcpy(dst, src, bytesPerLine);
-            src = (const uint8_t*)src + srcStride;
-            dst = (uint8_t*)dst + dstStride;
-        }
-    }
-
-    return retval;
-}
-
-#endif /* MPLAYER_FASTMEMCPY_H */
diff --git a/libavfilter/libmpcodecs/libvo/video_out.h b/libavfilter/libmpcodecs/libvo/video_out.h
deleted file mode 100644
index 2a3a0fa..0000000
--- a/libavfilter/libmpcodecs/libvo/video_out.h
+++ /dev/null
@@ -1,281 +0,0 @@
-/*
- * Copyright (C) Aaron Holtzman - Aug 1999
- * Strongly modified, most parts rewritten: A'rpi/ESP-team - 2000-2001
- * (C) MPlayer developers
- *
- * This file is part of MPlayer.
- *
- * MPlayer is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * MPlayer is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with MPlayer; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#ifndef MPLAYER_VIDEO_OUT_H
-#define MPLAYER_VIDEO_OUT_H
-
-#include <inttypes.h>
-#include <stdarg.h>
-
-//#include "sub/font_load.h"
-#include "../img_format.h"
-//#include "vidix/vidix.h"
-
-#define VO_EVENT_EXPOSE 1
-#define VO_EVENT_RESIZE 2
-#define VO_EVENT_KEYPRESS 4
-#define VO_EVENT_REINIT 8
-#define VO_EVENT_MOVE 16
-
-/* Obsolete: VOCTRL_QUERY_VAA 1 */
-/* does the device support the required format */
-#define VOCTRL_QUERY_FORMAT 2
-/* signal a device reset seek */
-#define VOCTRL_RESET 3
-/* true if vo driver can use GUI created windows */
-#define VOCTRL_GUISUPPORT 4
-#define VOCTRL_GUI_NOWINDOW 19
-/* used to switch to fullscreen */
-#define VOCTRL_FULLSCREEN 5
-/* signal a device pause */
-#define VOCTRL_PAUSE 7
-/* start/resume playback */
-#define VOCTRL_RESUME 8
-/* libmpcodecs direct rendering: */
-#define VOCTRL_GET_IMAGE 9
-#define VOCTRL_DRAW_IMAGE 13
-#define VOCTRL_SET_SPU_PALETTE 14
-/* decoding ahead: */
-#define VOCTRL_GET_NUM_FRAMES 10
-#define VOCTRL_GET_FRAME_NUM  11
-#define VOCTRL_SET_FRAME_NUM  12
-#define VOCTRL_GET_PANSCAN 15
-#define VOCTRL_SET_PANSCAN 16
-/* equalizer controls */
-#define VOCTRL_SET_EQUALIZER 17
-#define VOCTRL_GET_EQUALIZER 18
-//#define VOCTRL_GUI_NOWINDOW 19
-/* Frame duplication */
-#define VOCTRL_DUPLICATE_FRAME 20
-// ... 21
-#define VOCTRL_START_SLICE 21
-
-#define VOCTRL_ONTOP 25
-#define VOCTRL_ROOTWIN 26
-#define VOCTRL_BORDER 27
-#define VOCTRL_DRAW_EOSD 28
-#define VOCTRL_GET_EOSD_RES 29
-
-#define VOCTRL_SET_DEINTERLACE 30
-#define VOCTRL_GET_DEINTERLACE 31
-
-#define VOCTRL_UPDATE_SCREENINFO 32
-
-// Vo can be used by xover
-#define VOCTRL_XOVERLAY_SUPPORT 22
-
-#define VOCTRL_XOVERLAY_SET_COLORKEY 24
-typedef struct {
-  uint32_t x11; // The raw x11 color
-  uint16_t r,g,b;
-} mp_colorkey_t;
-
-#define VOCTRL_XOVERLAY_SET_WIN 23
-typedef struct {
-  int x,y;
-  int w,h;
-} mp_win_t;
-
-#define VO_TRUE      1
-#define VO_FALSE     0
-#define VO_ERROR    -1
-#define VO_NOTAVAIL -2
-#define VO_NOTIMPL  -3
-
-#define VOFLAG_FULLSCREEN         0x01
-#define VOFLAG_MODESWITCHING      0x02
-#define VOFLAG_SWSCALE            0x04
-#define VOFLAG_FLIPPING           0x08
-#define VOFLAG_HIDDEN             0x10  //< Use to create a hidden window
-#define VOFLAG_STEREO             0x20  //< Use to create a stereo-capable window
-#define VOFLAG_XOVERLAY_SUB_VO 0x10000
-
-typedef struct vo_info_s
-{
-    /* driver name ("Matrox Millennium G200/G400" */
-    const char *name;
-    /* short name (for config strings) ("mga") */
-    const char *short_name;
-    /* author ("Aaron Holtzman <aholtzma@ess.engr.uvic.ca>") */
-    const char *author;
-    /* any additional comments */
-    const char *comment;
-} vo_info_t;
-
-typedef struct vo_functions_s
-{
-    const vo_info_t *info;
-    /*
-     * Preinitializes driver (real INITIALIZATION)
-     *   arg - currently it's vo_subdevice
-     *   returns: zero on successful initialization, non-zero on error.
-     */
-    int (*preinit)(const char *arg);
-    /*
-     * Initialize (means CONFIGURE) the display driver.
-     * params:
-     *   width,height: image source size
-     *   d_width,d_height: size of the requested window size, just a hint
-     *   fullscreen: flag, 0=windowd 1=fullscreen, just a hint
-     *   title: window title, if available
-     *   format: fourcc of pixel format
-     * returns : zero on successful initialization, non-zero on error.
-     */
-    int (*config)(uint32_t width, uint32_t height, uint32_t d_width,
-                  uint32_t d_height, uint32_t fullscreen, char *title,
-                  uint32_t format);
-
-    /*
-     * Control interface
-     */
-    int (*control)(uint32_t request, void *data, ...);
-
-    /*
-     * Display a new RGB/BGR frame of the video to the screen.
-     * params:
-     *   src[0] - pointer to the image
-     */
-    int (*draw_frame)(uint8_t *src[]);
-
-    /*
-     * Draw a planar YUV slice to the buffer:
-     * params:
-     *   src[3] = source image planes (Y,U,V)
-     *   stride[3] = source image planes line widths (in bytes)
-     *   w,h = width*height of area to be copied (in Y pixels)
-     *   x,y = position at the destination image (in Y pixels)
-     */
-    int (*draw_slice)(uint8_t *src[], int stride[], int w,int h, int x,int y);
-
-    /*
-     * Draws OSD to the screen buffer
-     */
-    void (*draw_osd)(void);
-
-    /*
-     * Blit/Flip buffer to the screen. Must be called after each frame!
-     */
-    void (*flip_page)(void);
-
-    /*
-     * This func is called after every frames to handle keyboard and
-     * other events. It's called in PAUSE mode too!
-     */
-    void (*check_events)(void);
-
-    /*
-     * Closes driver. Should restore the original state of the system.
-     */
-    void (*uninit)(void);
-} vo_functions_t;
-
-const vo_functions_t* init_best_video_out(char** vo_list);
-int config_video_out(const vo_functions_t *vo, uint32_t width, uint32_t height,
-                     uint32_t d_width, uint32_t d_height, uint32_t flags,
-                     char *title, uint32_t format);
-void list_video_out(void);
-
-// NULL terminated array of all drivers
-extern const vo_functions_t* const video_out_drivers[];
-
-extern int vo_flags;
-
-extern int vo_config_count;
-
-extern int xinerama_screen;
-extern int xinerama_x;
-extern int xinerama_y;
-
-// correct resolution/bpp on screen:  (should be autodetected by vo_init())
-extern int vo_depthonscreen;
-extern int vo_screenwidth;
-extern int vo_screenheight;
-
-// requested resolution/bpp:  (-x -y -bpp options)
-extern int vo_dx;
-extern int vo_dy;
-extern int vo_dwidth;
-extern int vo_dheight;
-extern int vo_dbpp;
-
-extern int vo_grabpointer;
-extern int vo_doublebuffering;
-extern int vo_directrendering;
-extern int vo_vsync;
-extern int vo_fsmode;
-extern float vo_panscan;
-extern int vo_adapter_num;
-extern int vo_refresh_rate;
-extern int vo_keepaspect;
-extern int vo_rootwin;
-extern int vo_ontop;
-extern int vo_border;
-
-extern int vo_gamma_gamma;
-extern int vo_gamma_brightness;
-extern int vo_gamma_saturation;
-extern int vo_gamma_contrast;
-extern int vo_gamma_hue;
-extern int vo_gamma_red_intensity;
-extern int vo_gamma_green_intensity;
-extern int vo_gamma_blue_intensity;
-
-extern int vo_nomouse_input;
-extern int enable_mouse_movements;
-
-extern int vo_pts;
-extern float vo_fps;
-
-extern char *vo_subdevice;
-
-extern int vo_colorkey;
-
-extern char *vo_winname;
-extern char *vo_wintitle;
-
-extern int64_t WinID;
-
-typedef struct {
-        float min;
-        float max;
-        } range_t;
-
-float range_max(range_t *r);
-int in_range(range_t *r, float f);
-range_t *str2range(char *s);
-extern char *monitor_hfreq_str;
-extern char *monitor_vfreq_str;
-extern char *monitor_dotclock_str;
-
-struct mp_keymap {
-  int from;
-  int to;
-};
-int lookup_keymap_table(const struct mp_keymap *map, int key);
-struct vo_rect {
-  int left, right, top, bottom, width, height;
-};
-void calc_src_dst_rects(int src_width, int src_height, struct vo_rect *src, struct vo_rect *dst,
-                        struct vo_rect *borders, const struct vo_rect *crop);
-void vo_mouse_movement(int posx, int posy);
-
-#endif /* MPLAYER_VIDEO_OUT_H */
diff --git a/libavfilter/libmpcodecs/mp_image.c b/libavfilter/libmpcodecs/mp_image.c
deleted file mode 100644
index 100ace9..0000000
--- a/libavfilter/libmpcodecs/mp_image.c
+++ /dev/null
@@ -1,253 +0,0 @@
-/*
- * This file is part of MPlayer.
- *
- * MPlayer is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * MPlayer is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with MPlayer; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#include "config.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#if HAVE_MALLOC_H
-#include <malloc.h>
-#endif
-
-#include "img_format.h"
-#include "mp_image.h"
-
-#include "libvo/fastmemcpy.h"
-//#include "libavutil/mem.h"
-#include "libavutil/imgutils.h"
-
-void ff_mp_image_alloc_planes(mp_image_t *mpi) {
-    uint32_t temp[256];
-    if (avpriv_set_systematic_pal2(temp, ff_mp2ff_pix_fmt(mpi->imgfmt)) >= 0)
-        mpi->flags |= MP_IMGFLAG_RGB_PALETTE;
-
-  // IF09 - allocate space for 4. plane delta info - unused
-  if (mpi->imgfmt == IMGFMT_IF09) {
-    mpi->planes[0]=av_malloc(mpi->bpp*mpi->width*(mpi->height+2)/8+
-                            mpi->chroma_width*mpi->chroma_height);
-  } else
-    mpi->planes[0]=av_malloc(mpi->bpp*mpi->width*(mpi->height+2)/8);
-  if (mpi->flags&MP_IMGFLAG_PLANAR) {
-    int bpp = IMGFMT_IS_YUVP16(mpi->imgfmt)? 2 : 1;
-    // YV12/I420/YVU9/IF09. feel free to add other planar formats here...
-    mpi->stride[0]=mpi->stride[3]=bpp*mpi->width;
-    if(mpi->num_planes > 2){
-      mpi->stride[1]=mpi->stride[2]=bpp*mpi->chroma_width;
-      if(mpi->flags&MP_IMGFLAG_SWAPPED){
-        // I420/IYUV  (Y,U,V)
-        mpi->planes[1]=mpi->planes[0]+mpi->stride[0]*mpi->height;
-        mpi->planes[2]=mpi->planes[1]+mpi->stride[1]*mpi->chroma_height;
-        if (mpi->num_planes > 3)
-            mpi->planes[3]=mpi->planes[2]+mpi->stride[2]*mpi->chroma_height;
-      } else {
-        // YV12,YVU9,IF09  (Y,V,U)
-        mpi->planes[2]=mpi->planes[0]+mpi->stride[0]*mpi->height;
-        mpi->planes[1]=mpi->planes[2]+mpi->stride[1]*mpi->chroma_height;
-        if (mpi->num_planes > 3)
-            mpi->planes[3]=mpi->planes[1]+mpi->stride[1]*mpi->chroma_height;
-      }
-    } else {
-      // NV12/NV21
-      mpi->stride[1]=mpi->chroma_width;
-      mpi->planes[1]=mpi->planes[0]+mpi->stride[0]*mpi->height;
-    }
-  } else {
-    mpi->stride[0]=mpi->width*mpi->bpp/8;
-    if (mpi->flags & MP_IMGFLAG_RGB_PALETTE) {
-      mpi->planes[1] = av_malloc(1024);
-      memcpy(mpi->planes[1], temp, 1024);
-    }
-  }
-  mpi->flags|=MP_IMGFLAG_ALLOCATED;
-}
-
-mp_image_t* ff_alloc_mpi(int w, int h, unsigned long int fmt) {
-  mp_image_t* mpi = ff_new_mp_image(w,h);
-
-  ff_mp_image_setfmt(mpi,fmt);
-  ff_mp_image_alloc_planes(mpi);
-
-  return mpi;
-}
-
-void ff_copy_mpi(mp_image_t *dmpi, mp_image_t *mpi) {
-  if(mpi->flags&MP_IMGFLAG_PLANAR){
-    memcpy_pic(dmpi->planes[0],mpi->planes[0], mpi->w, mpi->h,
-               dmpi->stride[0],mpi->stride[0]);
-    memcpy_pic(dmpi->planes[1],mpi->planes[1], mpi->chroma_width, mpi->chroma_height,
-               dmpi->stride[1],mpi->stride[1]);
-    memcpy_pic(dmpi->planes[2], mpi->planes[2], mpi->chroma_width, mpi->chroma_height,
-               dmpi->stride[2],mpi->stride[2]);
-  } else {
-    memcpy_pic(dmpi->planes[0],mpi->planes[0],
-               mpi->w*(dmpi->bpp/8), mpi->h,
-               dmpi->stride[0],mpi->stride[0]);
-  }
-}
-
-void ff_mp_image_setfmt(mp_image_t* mpi,unsigned int out_fmt){
-    mpi->flags&=~(MP_IMGFLAG_PLANAR|MP_IMGFLAG_YUV|MP_IMGFLAG_SWAPPED);
-    mpi->imgfmt=out_fmt;
-    // compressed formats
-    if(out_fmt == IMGFMT_MPEGPES ||
-       out_fmt == IMGFMT_ZRMJPEGNI || out_fmt == IMGFMT_ZRMJPEGIT || out_fmt == IMGFMT_ZRMJPEGIB ||
-       IMGFMT_IS_HWACCEL(out_fmt)){
-        mpi->bpp=0;
-        return;
-    }
-    mpi->num_planes=1;
-    if (IMGFMT_IS_RGB(out_fmt)) {
-        if (IMGFMT_RGB_DEPTH(out_fmt) < 8 && !(out_fmt&128))
-            mpi->bpp = IMGFMT_RGB_DEPTH(out_fmt);
-        else
-            mpi->bpp=(IMGFMT_RGB_DEPTH(out_fmt)+7)&(~7);
-        return;
-    }
-    if (IMGFMT_IS_BGR(out_fmt)) {
-        if (IMGFMT_BGR_DEPTH(out_fmt) < 8 && !(out_fmt&128))
-            mpi->bpp = IMGFMT_BGR_DEPTH(out_fmt);
-        else
-            mpi->bpp=(IMGFMT_BGR_DEPTH(out_fmt)+7)&(~7);
-        mpi->flags|=MP_IMGFLAG_SWAPPED;
-        return;
-    }
-    mpi->num_planes=3;
-    if (out_fmt == IMGFMT_GBR24P) {
-        mpi->bpp=24;
-        mpi->flags|=MP_IMGFLAG_PLANAR;
-        return;
-    } else if (out_fmt == IMGFMT_GBR12P) {
-        mpi->bpp=36;
-        mpi->flags|=MP_IMGFLAG_PLANAR;
-        return;
-    } else if (out_fmt == IMGFMT_GBR14P) {
-        mpi->bpp=42;
-        mpi->flags|=MP_IMGFLAG_PLANAR;
-        return;
-    }
-    mpi->flags|=MP_IMGFLAG_YUV;
-    if (ff_mp_get_chroma_shift(out_fmt, NULL, NULL, NULL)) {
-        mpi->flags|=MP_IMGFLAG_PLANAR;
-        mpi->bpp = ff_mp_get_chroma_shift(out_fmt, &mpi->chroma_x_shift, &mpi->chroma_y_shift, NULL);
-        mpi->chroma_width  = mpi->width  >> mpi->chroma_x_shift;
-        mpi->chroma_height = mpi->height >> mpi->chroma_y_shift;
-    }
-    switch(out_fmt){
-    case IMGFMT_I420:
-    case IMGFMT_IYUV:
-        mpi->flags|=MP_IMGFLAG_SWAPPED;
-    case IMGFMT_YV12:
-        return;
-    case IMGFMT_420A:
-    case IMGFMT_422A:
-    case IMGFMT_444A:
-    case IMGFMT_IF09:
-        mpi->num_planes=4;
-    case IMGFMT_YVU9:
-    case IMGFMT_444P:
-    case IMGFMT_422P:
-    case IMGFMT_411P:
-    case IMGFMT_440P:
-    case IMGFMT_444P16_LE:
-    case IMGFMT_444P16_BE:
-    case IMGFMT_444P14_LE:
-    case IMGFMT_444P14_BE:
-    case IMGFMT_444P12_LE:
-    case IMGFMT_444P12_BE:
-    case IMGFMT_444P10_LE:
-    case IMGFMT_444P10_BE:
-    case IMGFMT_444P9_LE:
-    case IMGFMT_444P9_BE:
-    case IMGFMT_422P16_LE:
-    case IMGFMT_422P16_BE:
-    case IMGFMT_422P14_LE:
-    case IMGFMT_422P14_BE:
-    case IMGFMT_422P12_LE:
-    case IMGFMT_422P12_BE:
-    case IMGFMT_422P10_LE:
-    case IMGFMT_422P10_BE:
-    case IMGFMT_422P9_LE:
-    case IMGFMT_422P9_BE:
-    case IMGFMT_420P16_LE:
-    case IMGFMT_420P16_BE:
-    case IMGFMT_420P14_LE:
-    case IMGFMT_420P14_BE:
-    case IMGFMT_420P12_LE:
-    case IMGFMT_420P12_BE:
-    case IMGFMT_420P10_LE:
-    case IMGFMT_420P10_BE:
-    case IMGFMT_420P9_LE:
-    case IMGFMT_420P9_BE:
-        return;
-    case IMGFMT_Y16_LE:
-    case IMGFMT_Y16_BE:
-        mpi->bpp=16;
-    case IMGFMT_Y800:
-    case IMGFMT_Y8:
-        /* they're planar ones, but for easier handling use them as packed */
-        mpi->flags&=~MP_IMGFLAG_PLANAR;
-        mpi->num_planes=1;
-        return;
-    case IMGFMT_Y8A:
-        mpi->num_planes=2;
-        return;
-    case IMGFMT_UYVY:
-        mpi->flags|=MP_IMGFLAG_SWAPPED;
-    case IMGFMT_YUY2:
-        mpi->chroma_x_shift = 1;
-        mpi->bpp=16;
-        mpi->num_planes=1;
-        return;
-    case IMGFMT_NV12:
-        mpi->flags|=MP_IMGFLAG_SWAPPED;
-    case IMGFMT_NV21:
-        mpi->flags|=MP_IMGFLAG_PLANAR;
-        mpi->bpp=12;
-        mpi->num_planes=2;
-        mpi->chroma_width=(mpi->width>>0);
-        mpi->chroma_height=(mpi->height>>1);
-        mpi->chroma_x_shift=0;
-        mpi->chroma_y_shift=1;
-        return;
-    }
-    ff_mp_msg(MSGT_DECVIDEO,MSGL_WARN,"mp_image: unknown out_fmt: 0x%X\n",out_fmt);
-    mpi->bpp=0;
-}
-
-mp_image_t* ff_new_mp_image(int w,int h){
-    mp_image_t* mpi = malloc(sizeof(mp_image_t));
-    if(!mpi) return NULL; // error!
-    memset(mpi,0,sizeof(mp_image_t));
-    mpi->width=mpi->w=w;
-    mpi->height=mpi->h=h;
-    return mpi;
-}
-
-void ff_free_mp_image(mp_image_t* mpi){
-    if(!mpi) return;
-    if(mpi->flags&MP_IMGFLAG_ALLOCATED){
-        /* becouse we allocate the whole image in once */
-        av_free(mpi->planes[0]);
-        if (mpi->flags & MP_IMGFLAG_RGB_PALETTE)
-            av_free(mpi->planes[1]);
-    }
-    free(mpi);
-}
-
diff --git a/libavfilter/libmpcodecs/mp_image.h b/libavfilter/libmpcodecs/mp_image.h
deleted file mode 100644
index aedf451..0000000
--- a/libavfilter/libmpcodecs/mp_image.h
+++ /dev/null
@@ -1,159 +0,0 @@
-/*
- * This file is part of MPlayer.
- *
- * MPlayer is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * MPlayer is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with MPlayer; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#ifndef MPLAYER_MP_IMAGE_H
-#define MPLAYER_MP_IMAGE_H
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#undef printf //FIXME
-#undef fprintf //FIXME
-#include "mp_msg.h"
-#include "libavutil/avutil.h"
-#include "libavutil/avassert.h"
-#undef realloc
-#undef malloc
-#undef free
-#undef rand
-#undef srand
-#undef printf
-#undef strncpy
-#define ASMALIGN(ZEROBITS) ".p2align " #ZEROBITS "\n\t"
-#define CODEC_FLAG2_MEMC_ONLY     0x00001000 ///< Only do ME/MC (I frames -> ref, P frame -> ME+MC).
-
-enum AVPixelFormat ff_mp2ff_pix_fmt(int mp);
-
-//--------- codec's requirements (filled by the codec/vf) ---------
-
-//--- buffer content restrictions:
-// set if buffer content shouldn't be modified:
-#define MP_IMGFLAG_PRESERVE 0x01
-// set if buffer content will be READ.
-// This can be e.g. for next frame's MC: (I/P mpeg frames) -
-// then in combination with MP_IMGFLAG_PRESERVE - or it
-// can be because a video filter or codec will read a significant
-// amount of data while processing that frame (e.g. blending something
-// onto the frame, MV based intra prediction).
-// A frame marked like this should not be placed in to uncachable
-// video RAM for example.
-#define MP_IMGFLAG_READABLE 0x02
-
-//--- buffer width/stride/plane restrictions: (used for direct rendering)
-// stride _have_to_ be aligned to MB boundary:  [for DR restrictions]
-#define MP_IMGFLAG_ACCEPT_ALIGNED_STRIDE 0x4
-// stride should be aligned to MB boundary:     [for buffer allocation]
-#define MP_IMGFLAG_PREFER_ALIGNED_STRIDE 0x8
-// codec accept any stride (>=width):
-#define MP_IMGFLAG_ACCEPT_STRIDE 0x10
-// codec accept any width (width*bpp=stride -> stride%bpp==0) (>=width):
-#define MP_IMGFLAG_ACCEPT_WIDTH 0x20
-//--- for planar formats only:
-// uses only stride[0], and stride[1]=stride[2]=stride[0]>>mpi->chroma_x_shift
-#define MP_IMGFLAG_COMMON_STRIDE 0x40
-// uses only planes[0], and calculates planes[1,2] from width,height,imgfmt
-#define MP_IMGFLAG_COMMON_PLANE 0x80
-
-#define MP_IMGFLAGMASK_RESTRICTIONS 0xFF
-
-//--------- color info (filled by ff_mp_image_setfmt() ) -----------
-// set if number of planes > 1
-#define MP_IMGFLAG_PLANAR 0x100
-// set if it's YUV colorspace
-#define MP_IMGFLAG_YUV 0x200
-// set if it's swapped (BGR or YVU) plane/byteorder
-#define MP_IMGFLAG_SWAPPED 0x400
-// set if you want memory for palette allocated and managed by ff_vf_get_image etc.
-#define MP_IMGFLAG_RGB_PALETTE 0x800
-
-#define MP_IMGFLAGMASK_COLORS 0xF00
-
-// codec uses drawing/rendering callbacks (draw_slice()-like thing, DR method 2)
-// [the codec will set this flag if it supports callbacks, and the vo _may_
-//  clear it in get_image() if draw_slice() not implemented]
-#define MP_IMGFLAG_DRAW_CALLBACK 0x1000
-// set if it's in video buffer/memory: [set by vo/vf's get_image() !!!]
-#define MP_IMGFLAG_DIRECT 0x2000
-// set if buffer is allocated (used in destination images):
-#define MP_IMGFLAG_ALLOCATED 0x4000
-
-// buffer type was printed (do NOT set this flag - it's for INTERNAL USE!!!)
-#define MP_IMGFLAG_TYPE_DISPLAYED 0x8000
-
-// codec doesn't support any form of direct rendering - it has own buffer
-// allocation. so we just export its buffer pointers:
-#define MP_IMGTYPE_EXPORT 0
-// codec requires a static WO buffer, but it does only partial updates later:
-#define MP_IMGTYPE_STATIC 1
-// codec just needs some WO memory, where it writes/copies the whole frame to:
-#define MP_IMGTYPE_TEMP 2
-// I+P type, requires 2+ independent static R/W buffers
-#define MP_IMGTYPE_IP 3
-// I+P+B type, requires 2+ independent static R/W and 1+ temp WO buffers
-#define MP_IMGTYPE_IPB 4
-// Upper 16 bits give desired buffer number, -1 means get next available
-#define MP_IMGTYPE_NUMBERED 5
-// Doesn't need any buffer, incomplete image (probably a first field only)
-// we need this type to be able to differentiate between half frames and
-// all other cases
-#define MP_IMGTYPE_INCOMPLETE 6
-
-#define MP_MAX_PLANES 4
-
-#define MP_IMGFIELD_ORDERED 0x01
-#define MP_IMGFIELD_TOP_FIRST 0x02
-#define MP_IMGFIELD_REPEAT_FIRST 0x04
-#define MP_IMGFIELD_TOP 0x08
-#define MP_IMGFIELD_BOTTOM 0x10
-#define MP_IMGFIELD_INTERLACED 0x20
-
-typedef struct mp_image {
-    unsigned int flags;
-    unsigned char type;
-    int number;
-    unsigned char bpp;  // bits/pixel. NOT depth! for RGB it will be n*8
-    unsigned int imgfmt;
-    int width,height;  // stored dimensions
-    int x,y,w,h;  // visible dimensions
-    unsigned char* planes[MP_MAX_PLANES];
-    int stride[MP_MAX_PLANES];
-    char * qscale;
-    int qstride;
-    int pict_type; // 0->unknown, 1->I, 2->P, 3->B
-    int fields;
-    int qscale_type; // 0->mpeg1/4/h263, 1->mpeg2
-    int num_planes;
-    /* these are only used by planar formats Y,U(Cb),V(Cr) */
-    int chroma_width;
-    int chroma_height;
-    int chroma_x_shift; // horizontal
-    int chroma_y_shift; // vertical
-    int usage_count;
-    /* for private use by filter or vo driver (to store buffer id or dmpi) */
-    void* priv;
-} mp_image_t;
-
-void ff_mp_image_setfmt(mp_image_t* mpi,unsigned int out_fmt);
-mp_image_t* ff_new_mp_image(int w,int h);
-void ff_free_mp_image(mp_image_t* mpi);
-
-mp_image_t* ff_alloc_mpi(int w, int h, unsigned long int fmt);
-void ff_mp_image_alloc_planes(mp_image_t *mpi);
-void ff_copy_mpi(mp_image_t *dmpi, mp_image_t *mpi);
-
-#endif /* MPLAYER_MP_IMAGE_H */
diff --git a/libavfilter/libmpcodecs/mp_msg.h b/libavfilter/libmpcodecs/mp_msg.h
deleted file mode 100644
index 51cdff3..0000000
--- a/libavfilter/libmpcodecs/mp_msg.h
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
- * This file is part of MPlayer.
- *
- * MPlayer is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * MPlayer is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with MPlayer; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#ifndef MPLAYER_MP_MSG_H
-#define MPLAYER_MP_MSG_H
-
-#include <stdarg.h>
-
-// defined in mplayer.c and mencoder.c
-extern int verbose;
-
-// verbosity elevel:
-
-/* Only messages level MSGL_FATAL-MSGL_STATUS should be translated,
- * messages level MSGL_V and above should not be translated. */
-
-#define MSGL_FATAL 0  // will exit/abort
-#define MSGL_ERR 1    // continues
-#define MSGL_WARN 2   // only warning
-#define MSGL_HINT 3   // short help message
-#define MSGL_INFO 4   // -quiet
-#define MSGL_STATUS 5 // v=0
-#define MSGL_V 6      // v=1
-#define MSGL_DBG2 7   // v=2
-#define MSGL_DBG3 8   // v=3
-#define MSGL_DBG4 9   // v=4
-#define MSGL_DBG5 10  // v=5
-
-#define MSGL_FIXME 1  // for conversions from printf where the appropriate MSGL is not known; set equal to ERR for obtrusiveness
-#define MSGT_FIXME 0  // for conversions from printf where the appropriate MSGT is not known; set equal to GLOBAL for obtrusiveness
-
-// code/module:
-
-#define MSGT_GLOBAL 0        // common player stuff errors
-#define MSGT_CPLAYER 1       // console player (mplayer.c)
-#define MSGT_GPLAYER 2       // gui player
-
-#define MSGT_VO 3       // libvo
-#define MSGT_AO 4       // libao
-
-#define MSGT_DEMUXER 5    // demuxer.c (general stuff)
-#define MSGT_DS 6         // demux stream (add/read packet etc)
-#define MSGT_DEMUX 7      // fileformat-specific stuff (demux_*.c)
-#define MSGT_HEADER 8     // fileformat-specific header (*header.c)
-
-#define MSGT_AVSYNC 9     // mplayer.c timer stuff
-#define MSGT_AUTOQ 10     // mplayer.c auto-quality stuff
-
-#define MSGT_CFGPARSER 11 // cfgparser.c
-
-#define MSGT_DECAUDIO 12  // av decoder
-#define MSGT_DECVIDEO 13
-
-#define MSGT_SEEK 14    // seeking code
-#define MSGT_WIN32 15   // win32 dll stuff
-#define MSGT_OPEN 16    // open.c (stream opening)
-#define MSGT_DVD 17     // open.c (DVD init/read/seek)
-
-#define MSGT_PARSEES 18 // parse_es.c (mpeg stream parser)
-#define MSGT_LIRC 19    // lirc_mp.c and input lirc driver
-
-#define MSGT_STREAM 20  // stream.c
-#define MSGT_CACHE 21   // cache2.c
-
-#define MSGT_MENCODER 22
-
-#define MSGT_XACODEC 23 // XAnim codecs
-
-#define MSGT_TV 24      // TV input subsystem
-
-#define MSGT_OSDEP 25  // OS-dependent parts
-
-#define MSGT_SPUDEC 26 // spudec.c
-
-#define MSGT_PLAYTREE 27    // Playtree handeling (playtree.c, playtreeparser.c)
-
-#define MSGT_INPUT 28
-
-#define MSGT_VFILTER 29
-
-#define MSGT_OSD 30
-
-#define MSGT_NETWORK 31
-
-#define MSGT_CPUDETECT 32
-
-#define MSGT_CODECCFG 33
-
-#define MSGT_SWS 34
-
-#define MSGT_VOBSUB 35
-#define MSGT_SUBREADER 36
-
-#define MSGT_AFILTER 37  // Audio filter messages
-
-#define MSGT_NETST 38 // Netstream
-
-#define MSGT_MUXER 39 // muxer layer
-
-#define MSGT_OSD_MENU 40
-
-#define MSGT_IDENTIFY 41  // -identify output
-
-#define MSGT_RADIO 42
-
-#define MSGT_ASS 43 // libass messages
-
-#define MSGT_LOADER 44 // dll loader messages
-
-#define MSGT_STATUSLINE 45 // playback/encoding status line
-
-#define MSGT_TELETEXT 46       // Teletext decoder
-
-#define MSGT_MAX 64
-
-
-extern char *ff_mp_msg_charset;
-extern int ff_mp_msg_color;
-extern int ff_mp_msg_module;
-
-extern int ff_mp_msg_levels[MSGT_MAX];
-extern int ff_mp_msg_level_all;
-
-
-void ff_mp_msg_init(void);
-int ff_mp_msg_test(int mod, int lev);
-
-#include "config.h"
-
-void ff_mp_msg_va(int mod, int lev, const char *format, va_list va);
-#ifdef __GNUC__
-void ff_mp_msg(int mod, int lev, const char *format, ... ) __attribute__ ((format (printf, 3, 4)));
-#   ifdef MP_DEBUG
-#      define mp_dbg(mod,lev, args... ) ff_mp_msg(mod, lev, ## args )
-#   else
-       // only useful for developers, disable but check syntax
-#      define mp_dbg(mod,lev, args... ) do { if (0) ff_mp_msg(mod, lev, ## args ); } while (0)
-#   endif
-#else // not GNU C
-void ff_mp_msg(int mod, int lev, const char *format, ... );
-#   ifdef MP_DEBUG
-#      define mp_dbg(mod,lev, ... ) ff_mp_msg(mod, lev, __VA_ARGS__)
-#   else
-       // only useful for developers, disable but check syntax
-#      define mp_dbg(mod,lev, ... ) do { if (0) ff_mp_msg(mod, lev, __VA_ARGS__); } while (0)
-#   endif
-#endif /* __GNUC__ */
-
-const char* ff_filename_recode(const char* filename);
-
-#endif /* MPLAYER_MP_MSG_H */
diff --git a/libavfilter/libmpcodecs/mpc_info.h b/libavfilter/libmpcodecs/mpc_info.h
deleted file mode 100644
index 8554699..0000000
--- a/libavfilter/libmpcodecs/mpc_info.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * This file is part of MPlayer.
- *
- * MPlayer is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * MPlayer is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with MPlayer; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#ifndef MPLAYER_MPC_INFO_H
-#define MPLAYER_MPC_INFO_H
-
-typedef struct mp_codec_info_s
-{
-        /* codec long name ("Autodesk FLI/FLC Animation decoder" */
-        const char *name;
-        /* short name (same as driver name in codecs.conf) ("dshow") */
-        const char *short_name;
-        /* interface author/maintainer */
-        const char *maintainer;
-        /* codec author ("Aaron Holtzman <aholtzma@ess.engr.uvic.ca>") */
-        const char *author;
-        /* any additional comments */
-        const char *comment;
-} mp_codec_info_t;
-
-#define CONTROL_OK 1
-#define CONTROL_TRUE 1
-#define CONTROL_FALSE 0
-#define CONTROL_UNKNOWN -1
-#define CONTROL_ERROR -2
-#define CONTROL_NA -3
-
-#endif /* MPLAYER_MPC_INFO_H */
diff --git a/libavfilter/libmpcodecs/vf.h b/libavfilter/libmpcodecs/vf.h
deleted file mode 100644
index 0d26296..0000000
--- a/libavfilter/libmpcodecs/vf.h
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * This file is part of MPlayer.
- *
- * MPlayer is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * MPlayer is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with MPlayer; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#ifndef MPLAYER_VF_H
-#define MPLAYER_VF_H
-
-//#include "m_option.h"
-#include "mp_image.h"
-
-//extern m_obj_settings_t* vf_settings;
-//extern const m_obj_list_t vf_obj_list;
-
-struct vf_instance;
-struct vf_priv_s;
-
-typedef struct vf_info_s {
-    const char *info;
-    const char *name;
-    const char *author;
-    const char *comment;
-    int (*vf_open)(struct vf_instance *vf,char* args);
-    // Ptr to a struct dscribing the options
-    const void* opts;
-} vf_info_t;
-
-#define NUM_NUMBERED_MPI 50
-
-typedef struct vf_image_context_s {
-    mp_image_t* static_images[2];
-    mp_image_t* temp_images[1];
-    mp_image_t* export_images[1];
-    mp_image_t* numbered_images[NUM_NUMBERED_MPI];
-    int static_idx;
-} vf_image_context_t;
-
-typedef struct vf_format_context_t {
-    int have_configured;
-    int orig_width, orig_height, orig_fmt;
-} vf_format_context_t;
-
-typedef struct vf_instance {
-    const vf_info_t* info;
-    // funcs:
-    int (*config)(struct vf_instance *vf,
-        int width, int height, int d_width, int d_height,
-        unsigned int flags, unsigned int outfmt);
-    int (*control)(struct vf_instance *vf,
-        int request, void* data);
-    int (*query_format)(struct vf_instance *vf,
-        unsigned int fmt);
-    void (*get_image)(struct vf_instance *vf,
-        mp_image_t *mpi);
-    int (*put_image)(struct vf_instance *vf,
-        mp_image_t *mpi, double pts);
-    void (*start_slice)(struct vf_instance *vf,
-        mp_image_t *mpi);
-    void (*draw_slice)(struct vf_instance *vf,
-        unsigned char** src, int* stride, int w,int h, int x, int y);
-    void (*uninit)(struct vf_instance *vf);
-
-    int (*continue_buffered_image)(struct vf_instance *vf);
-    // caps:
-    unsigned int default_caps; // used by default query_format()
-    unsigned int default_reqs; // used by default config()
-    // data:
-    int w, h;
-    vf_image_context_t imgctx;
-    vf_format_context_t fmt;
-    struct vf_instance *next;
-    mp_image_t *dmpi;
-    struct vf_priv_s* priv;
-} vf_instance_t;
-
-// control codes:
-#include "mpc_info.h"
-
-typedef struct vf_seteq_s
-{
-    const char *item;
-    int value;
-} vf_equalizer_t;
-
-#define VFCTRL_QUERY_MAX_PP_LEVEL 4 /* test for postprocessing support (max level) */
-#define VFCTRL_SET_PP_LEVEL 5 /* set postprocessing level */
-#define VFCTRL_SET_EQUALIZER 6 /* set color options (brightness,contrast etc) */
-#define VFCTRL_GET_EQUALIZER 8 /* gset color options (brightness,contrast etc) */
-#define VFCTRL_DRAW_OSD 7
-#define VFCTRL_CHANGE_RECTANGLE 9 /* Change the rectangle boundaries */
-#define VFCTRL_FLIP_PAGE 10 /* Tell the vo to flip pages */
-#define VFCTRL_DUPLICATE_FRAME 11 /* For encoding - encode zero-change frame */
-#define VFCTRL_SKIP_NEXT_FRAME 12 /* For encoding - drop the next frame that passes thru */
-#define VFCTRL_FLUSH_FRAMES    13 /* For encoding - flush delayed frames */
-#define VFCTRL_SCREENSHOT      14 /* Make a screenshot */
-#define VFCTRL_INIT_EOSD       15 /* Select EOSD renderer */
-#define VFCTRL_DRAW_EOSD       16 /* Render EOSD */
-#define VFCTRL_GET_PTS         17 /* Return last pts value that reached vf_vo*/
-#define VFCTRL_SET_DEINTERLACE 18 /* Set deinterlacing status */
-#define VFCTRL_GET_DEINTERLACE 19 /* Get deinterlacing status */
-
-#include "vfcap.h"
-
-//FIXME this should be in a common header, but i dunno which
-#define MP_NOPTS_VALUE (-1LL<<63) //both int64_t and double should be able to represent this exactly
-
-
-// functions:
-void ff_vf_mpi_clear(mp_image_t* mpi,int x0,int y0,int w,int h);
-mp_image_t* ff_vf_get_image(vf_instance_t* vf, unsigned int outfmt, int mp_imgtype, int mp_imgflag, int w, int h);
-
-vf_instance_t* vf_open_plugin(const vf_info_t* const* filter_list, vf_instance_t* next, const char *name, char **args);
-vf_instance_t* vf_open_filter(vf_instance_t* next, const char *name, char **args);
-vf_instance_t* ff_vf_add_before_vo(vf_instance_t **vf, char *name, char **args);
-vf_instance_t* vf_open_encoder(vf_instance_t* next, const char *name, char *args);
-
-unsigned int ff_vf_match_csp(vf_instance_t** vfp,const unsigned int* list,unsigned int preferred);
-void ff_vf_clone_mpi_attributes(mp_image_t* dst, mp_image_t* src);
-void ff_vf_queue_frame(vf_instance_t *vf, int (*)(vf_instance_t *));
-int ff_vf_output_queued_frame(vf_instance_t *vf);
-
-// default wrappers:
-int ff_vf_next_config(struct vf_instance *vf,
-        int width, int height, int d_width, int d_height,
-        unsigned int flags, unsigned int outfmt);
-int ff_vf_next_control(struct vf_instance *vf, int request, void* data);
-void ff_vf_extra_flip(struct vf_instance *vf);
-int ff_vf_next_query_format(struct vf_instance *vf, unsigned int fmt);
-int ff_vf_next_put_image(struct vf_instance *vf,mp_image_t *mpi, double pts);
-void ff_vf_next_draw_slice (struct vf_instance *vf, unsigned char** src, int* stride, int w,int h, int x, int y);
-
-vf_instance_t* ff_append_filters(vf_instance_t* last);
-
-void ff_vf_uninit_filter(vf_instance_t* vf);
-void ff_vf_uninit_filter_chain(vf_instance_t* vf);
-
-int ff_vf_config_wrapper(struct vf_instance *vf,
-                      int width, int height, int d_width, int d_height,
-                      unsigned int flags, unsigned int outfmt);
-
-static inline int norm_qscale(int qscale, int type)
-{
-    switch (type) {
-    case 0: // MPEG-1
-        return qscale;
-    case 1: // MPEG-2
-        return qscale >> 1;
-    case 2: // H264
-        return qscale >> 2;
-    case 3: // VP56
-        return (63 - qscale + 2) >> 2;
-    }
-    return qscale;
-}
-
-#endif /* MPLAYER_VF_H */
diff --git a/libavfilter/libmpcodecs/vf_eq.c b/libavfilter/libmpcodecs/vf_eq.c
deleted file mode 100644
index c926c51..0000000
--- a/libavfilter/libmpcodecs/vf_eq.c
+++ /dev/null
@@ -1,240 +0,0 @@
-/*
- * This file is part of MPlayer.
- *
- * MPlayer is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * MPlayer is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with MPlayer; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <inttypes.h>
-
-#include "config.h"
-#include "mp_msg.h"
-#include "cpudetect.h"
-
-#include "img_format.h"
-#include "mp_image.h"
-#include "vf.h"
-
-#include "libvo/video_out.h"
-
-struct vf_priv_s {
-        unsigned char *buf;
-        int brightness;
-        int contrast;
-};
-
-#if HAVE_MMX
-static void process_MMX(unsigned char *dest, int dstride, unsigned char *src, int sstride,
-                    int w, int h, int brightness, int contrast)
-{
-        int i;
-        int pel;
-        int dstep = dstride-w;
-        int sstep = sstride-w;
-        short brvec[4];
-        short contvec[4];
-
-        contrast = ((contrast+100)*256*16)/100;
-        brightness = ((brightness+100)*511)/200-128 - contrast/32;
-
-        brvec[0] = brvec[1] = brvec[2] = brvec[3] = brightness;
-        contvec[0] = contvec[1] = contvec[2] = contvec[3] = contrast;
-
-        while (h--) {
-                __asm__ volatile (
-                        "movq (%5), %%mm3 \n\t"
-                        "movq (%6), %%mm4 \n\t"
-                        "pxor %%mm0, %%mm0 \n\t"
-                        "movl %4, %%eax\n\t"
-                        ASMALIGN(4)
-                        "1: \n\t"
-                        "movq (%0), %%mm1 \n\t"
-                        "movq (%0), %%mm2 \n\t"
-                        "punpcklbw %%mm0, %%mm1 \n\t"
-                        "punpckhbw %%mm0, %%mm2 \n\t"
-                        "psllw $4, %%mm1 \n\t"
-                        "psllw $4, %%mm2 \n\t"
-                        "pmulhw %%mm4, %%mm1 \n\t"
-                        "pmulhw %%mm4, %%mm2 \n\t"
-                        "paddw %%mm3, %%mm1 \n\t"
-                        "paddw %%mm3, %%mm2 \n\t"
-                        "packuswb %%mm2, %%mm1 \n\t"
-                        "add $8, %0 \n\t"
-                        "movq %%mm1, (%1) \n\t"
-                        "add $8, %1 \n\t"
-                        "decl %%eax \n\t"
-                        "jnz 1b \n\t"
-                        : "=r" (src), "=r" (dest)
-                        : "0" (src), "1" (dest), "r" (w>>3), "r" (brvec), "r" (contvec)
-                        : "%eax"
-                );
-
-                for (i = w&7; i; i--)
-                {
-                        pel = ((*src++* contrast)>>12) + brightness;
-                        if(pel&768) pel = (-pel)>>31;
-                        *dest++ = pel;
-                }
-
-                src += sstep;
-                dest += dstep;
-        }
-        __asm__ volatile ( "emms \n\t" ::: "memory" );
-}
-#endif
-
-static void process_C(unsigned char *dest, int dstride, unsigned char *src, int sstride,
-                    int w, int h, int brightness, int contrast)
-{
-        int i;
-        int pel;
-        int dstep = dstride-w;
-        int sstep = sstride-w;
-
-        contrast = ((contrast+100)*256*256)/100;
-        brightness = ((brightness+100)*511)/200-128 - contrast/512;
-
-        while (h--) {
-                for (i = w; i; i--)
-                {
-                        pel = ((*src++* contrast)>>16) + brightness;
-                        if(pel&768) pel = (-pel)>>31;
-                        *dest++ = pel;
-                }
-                src += sstep;
-                dest += dstep;
-        }
-}
-
-static void (*process)(unsigned char *dest, int dstride, unsigned char *src, int sstride,
-                       int w, int h, int brightness, int contrast);
-
-/* FIXME: add packed yuv version of process */
-
-static int put_image(struct vf_instance *vf, mp_image_t *mpi, double pts)
-{
-        mp_image_t *dmpi;
-
-        dmpi=ff_vf_get_image(vf->next, mpi->imgfmt,
-                          MP_IMGTYPE_EXPORT, 0,
-                          mpi->w, mpi->h);
-
-        dmpi->stride[0] = mpi->stride[0];
-        dmpi->planes[1] = mpi->planes[1];
-        dmpi->planes[2] = mpi->planes[2];
-        dmpi->stride[1] = mpi->stride[1];
-        dmpi->stride[2] = mpi->stride[2];
-
-        if (!vf->priv->buf) vf->priv->buf = malloc(mpi->stride[0]*mpi->h);
-
-        if ((vf->priv->brightness == 0) && (vf->priv->contrast == 0))
-                dmpi->planes[0] = mpi->planes[0];
-        else {
-                dmpi->planes[0] = vf->priv->buf;
-                process(dmpi->planes[0], dmpi->stride[0],
-                        mpi->planes[0], mpi->stride[0],
-                        mpi->w, mpi->h, vf->priv->brightness,
-                        vf->priv->contrast);
-        }
-
-        return ff_vf_next_put_image(vf,dmpi, pts);
-}
-
-static int control(struct vf_instance *vf, int request, void* data)
-{
-        vf_equalizer_t *eq;
-
-        switch (request) {
-        case VFCTRL_SET_EQUALIZER:
-                eq = data;
-                if (!strcmp(eq->item,"brightness")) {
-                        vf->priv->brightness = eq->value;
-                        return CONTROL_TRUE;
-                }
-                else if (!strcmp(eq->item,"contrast")) {
-                        vf->priv->contrast = eq->value;
-                        return CONTROL_TRUE;
-                }
-                break;
-        case VFCTRL_GET_EQUALIZER:
-                eq = data;
-                if (!strcmp(eq->item,"brightness")) {
-                        eq->value = vf->priv->brightness;
-                        return CONTROL_TRUE;
-                }
-                else if (!strcmp(eq->item,"contrast")) {
-                        eq->value = vf->priv->contrast;
-                        return CONTROL_TRUE;
-                }
-                break;
-        }
-        return ff_vf_next_control(vf, request, data);
-}
-
-static int query_format(struct vf_instance *vf, unsigned int fmt)
-{
-        switch (fmt) {
-        case IMGFMT_YVU9:
-        case IMGFMT_IF09:
-        case IMGFMT_YV12:
-        case IMGFMT_I420:
-        case IMGFMT_IYUV:
-        case IMGFMT_CLPL:
-        case IMGFMT_Y800:
-        case IMGFMT_Y8:
-        case IMGFMT_NV12:
-        case IMGFMT_NV21:
-        case IMGFMT_444P:
-        case IMGFMT_422P:
-        case IMGFMT_411P:
-                return ff_vf_next_query_format(vf, fmt);
-        }
-        return 0;
-}
-
-static void uninit(struct vf_instance *vf)
-{
-        free(vf->priv->buf);
-        free(vf->priv);
-}
-
-static int vf_open(vf_instance_t *vf, char *args)
-{
-        vf->control=control;
-        vf->query_format=query_format;
-        vf->put_image=put_image;
-        vf->uninit=uninit;
-
-    vf->priv = malloc(sizeof(struct vf_priv_s));
-    memset(vf->priv, 0, sizeof(struct vf_priv_s));
-    if (args) sscanf(args, "%d:%d", &vf->priv->brightness, &vf->priv->contrast);
-
-        process = process_C;
-#if HAVE_MMX
-        if(ff_gCpuCaps.hasMMX) process = process_MMX;
-#endif
-
-        return 1;
-}
-
-const vf_info_t ff_vf_info_eq = {
-        "soft video equalizer",
-        "eq",
-        "Richard Felker",
-        "",
-        vf_open,
-};
diff --git a/libavfilter/libmpcodecs/vf_eq2.c b/libavfilter/libmpcodecs/vf_eq2.c
deleted file mode 100644
index 7a3ef31..0000000
--- a/libavfilter/libmpcodecs/vf_eq2.c
+++ /dev/null
@@ -1,519 +0,0 @@
-/*
- * Software equalizer (brightness, contrast, gamma, saturation)
- *
- * Hampa Hug <hampa@hampa.ch> (original LUT gamma/contrast/brightness filter)
- * Daniel Moreno <comac@comac.darktech.org> (saturation, R/G/B gamma support)
- * Richard Felker (original MMX contrast/brightness code (vf_eq.c))
- * Michael Niedermayer <michalni@gmx.at> (LUT16)
- *
- * This file is part of MPlayer.
- *
- * MPlayer is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * MPlayer is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with MPlayer; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-#include <inttypes.h>
-
-#include "config.h"
-#include "mp_msg.h"
-#include "cpudetect.h"
-
-#include "img_format.h"
-#include "mp_image.h"
-#include "vf.h"
-
-#define LUT16
-
-/* Per channel parameters */
-typedef struct eq2_param_t {
-  unsigned char lut[256];
-#ifdef LUT16
-  uint16_t lut16[256*256];
-#endif
-  int           lut_clean;
-
-  void (*adjust) (struct eq2_param_t *par, unsigned char *dst, unsigned char *src,
-    unsigned w, unsigned h, unsigned dstride, unsigned sstride);
-
-  double        c;
-  double        b;
-  double        g;
-  double        w;
-} eq2_param_t;
-
-typedef struct vf_priv_s {
-  eq2_param_t param[3];
-
-  double        contrast;
-  double        brightness;
-  double        saturation;
-
-  double        gamma;
-  double        gamma_weight;
-  double        rgamma;
-  double        ggamma;
-  double        bgamma;
-
-  unsigned      buf_w[3];
-  unsigned      buf_h[3];
-  unsigned char *buf[3];
-} vf_eq2_t;
-
-
-static
-void create_lut (eq2_param_t *par)
-{
-  unsigned i;
-  double   g, v;
-  double   lw, gw;
-
-  g = par->g;
-  gw = par->w;
-  lw = 1.0 - gw;
-
-  if ((g < 0.001) || (g > 1000.0)) {
-    g = 1.0;
-  }
-
-  g = 1.0 / g;
-
-  for (i = 0; i < 256; i++) {
-    v = (double) i / 255.0;
-    v = par->c * (v - 0.5) + 0.5 + par->b;
-
-    if (v <= 0.0) {
-      par->lut[i] = 0;
-    }
-    else {
-      v = v*lw + pow(v, g)*gw;
-
-      if (v >= 1.0) {
-        par->lut[i] = 255;
-      }
-      else {
-        par->lut[i] = (unsigned char) (256.0 * v);
-      }
-    }
-  }
-
-#ifdef LUT16
-  for(i=0; i<256*256; i++){
-    par->lut16[i]= par->lut[i&0xFF] + (par->lut[i>>8]<<8);
-  }
-#endif
-
-  par->lut_clean = 1;
-}
-
-#if HAVE_MMX
-static
-void affine_1d_MMX (eq2_param_t *par, unsigned char *dst, unsigned char *src,
-  unsigned w, unsigned h, unsigned dstride, unsigned sstride)
-{
-  unsigned i;
-  int      contrast, brightness;
-  unsigned dstep, sstep;
-  int      pel;
-  short    brvec[4];
-  short    contvec[4];
-
-//  printf("\nmmx: src=%p dst=%p w=%d h=%d ds=%d ss=%d\n",src,dst,w,h,dstride,sstride);
-
-  contrast = (int) (par->c * 256 * 16);
-  brightness = ((int) (100.0 * par->b + 100.0) * 511) / 200 - 128 - contrast / 32;
-
-  brvec[0] = brvec[1] = brvec[2] = brvec[3] = brightness;
-  contvec[0] = contvec[1] = contvec[2] = contvec[3] = contrast;
-
-  sstep = sstride - w;
-  dstep = dstride - w;
-
-  while (h-- > 0) {
-    __asm__ volatile (
-      "movq (%5), %%mm3 \n\t"
-      "movq (%6), %%mm4 \n\t"
-      "pxor %%mm0, %%mm0 \n\t"
-      "movl %4, %%eax\n\t"
-      ASMALIGN(4)
-      "1: \n\t"
-      "movq (%0), %%mm1 \n\t"
-      "movq (%0), %%mm2 \n\t"
-      "punpcklbw %%mm0, %%mm1 \n\t"
-      "punpckhbw %%mm0, %%mm2 \n\t"
-      "psllw $4, %%mm1 \n\t"
-      "psllw $4, %%mm2 \n\t"
-      "pmulhw %%mm4, %%mm1 \n\t"
-      "pmulhw %%mm4, %%mm2 \n\t"
-      "paddw %%mm3, %%mm1 \n\t"
-      "paddw %%mm3, %%mm2 \n\t"
-      "packuswb %%mm2, %%mm1 \n\t"
-      "add $8, %0 \n\t"
-      "movq %%mm1, (%1) \n\t"
-      "add $8, %1 \n\t"
-      "decl %%eax \n\t"
-      "jnz 1b \n\t"
-      : "=r" (src), "=r" (dst)
-      : "0" (src), "1" (dst), "r" (w >> 3), "r" (brvec), "r" (contvec)
-      : "%eax"
-    );
-
-    for (i = w & 7; i > 0; i--) {
-      pel = ((*src++ * contrast) >> 12) + brightness;
-      if (pel & 768) {
-        pel = (-pel) >> 31;
-      }
-      *dst++ = pel;
-    }
-
-    src += sstep;
-    dst += dstep;
-  }
-
-  __asm__ volatile ( "emms \n\t" ::: "memory" );
-}
-#endif
-
-static
-void apply_lut (eq2_param_t *par, unsigned char *dst, unsigned char *src,
-  unsigned w, unsigned h, unsigned dstride, unsigned sstride)
-{
-  unsigned      i, j, w2;
-  unsigned char *lut;
-  uint16_t *lut16;
-
-  if (!par->lut_clean) {
-    create_lut (par);
-  }
-
-  lut = par->lut;
-#ifdef LUT16
-  lut16 = par->lut16;
-  w2= (w>>3)<<2;
-  for (j = 0; j < h; j++) {
-    uint16_t *src16= (uint16_t*)src;
-    uint16_t *dst16= (uint16_t*)dst;
-    for (i = 0; i < w2; i+=4) {
-      dst16[i+0] = lut16[src16[i+0]];
-      dst16[i+1] = lut16[src16[i+1]];
-      dst16[i+2] = lut16[src16[i+2]];
-      dst16[i+3] = lut16[src16[i+3]];
-    }
-    i <<= 1;
-#else
-  w2= (w>>3)<<3;
-  for (j = 0; j < h; j++) {
-    for (i = 0; i < w2; i+=8) {
-      dst[i+0] = lut[src[i+0]];
-      dst[i+1] = lut[src[i+1]];
-      dst[i+2] = lut[src[i+2]];
-      dst[i+3] = lut[src[i+3]];
-      dst[i+4] = lut[src[i+4]];
-      dst[i+5] = lut[src[i+5]];
-      dst[i+6] = lut[src[i+6]];
-      dst[i+7] = lut[src[i+7]];
-    }
-#endif
-    for (; i < w; i++) {
-      dst[i] = lut[src[i]];
-    }
-
-    src += sstride;
-    dst += dstride;
-  }
-}
-
-static
-int put_image (vf_instance_t *vf, mp_image_t *src, double pts)
-{
-  unsigned      i;
-  vf_eq2_t      *eq2;
-  mp_image_t    *dst;
-  unsigned long img_n,img_c;
-
-  eq2 = vf->priv;
-
-  if ((eq2->buf_w[0] != src->w) || (eq2->buf_h[0] != src->h)) {
-    eq2->buf_w[0] = src->w;
-    eq2->buf_h[0] = src->h;
-      eq2->buf_w[1] = eq2->buf_w[2] = src->w >> src->chroma_x_shift;
-      eq2->buf_h[1] = eq2->buf_h[2] = src->h >> src->chroma_y_shift;
-    img_n = eq2->buf_w[0]*eq2->buf_h[0];
-    if(src->num_planes>1){
-      img_c = eq2->buf_w[1]*eq2->buf_h[1];
-      eq2->buf[0] = realloc (eq2->buf[0], img_n + 2*img_c);
-      eq2->buf[1] = eq2->buf[0] + img_n;
-      eq2->buf[2] = eq2->buf[1] + img_c;
-    } else
-      eq2->buf[0] = realloc (eq2->buf[0], img_n);
-  }
-
-  dst = ff_vf_get_image (vf->next, src->imgfmt, MP_IMGTYPE_EXPORT, 0, src->w, src->h);
-
-  for (i = 0; i < ((src->num_planes>1)?3:1); i++) {
-    if (eq2->param[i].adjust != NULL) {
-      dst->planes[i] = eq2->buf[i];
-      dst->stride[i] = eq2->buf_w[i];
-
-      eq2->param[i].adjust (&eq2->param[i], dst->planes[i], src->planes[i],
-        eq2->buf_w[i], eq2->buf_h[i], dst->stride[i], src->stride[i]);
-    }
-    else {
-      dst->planes[i] = src->planes[i];
-      dst->stride[i] = src->stride[i];
-    }
-  }
-
-  return ff_vf_next_put_image (vf, dst, pts);
-}
-
-static
-void check_values (eq2_param_t *par)
-{
-  /* yuck! floating point comparisons... */
-
-  if ((par->c == 1.0) && (par->b == 0.0) && (par->g == 1.0)) {
-    par->adjust = NULL;
-  }
-#if HAVE_MMX
-  else if (par->g == 1.0 && ff_gCpuCaps.hasMMX) {
-    par->adjust = &affine_1d_MMX;
-  }
-#endif
-  else {
-    par->adjust = &apply_lut;
-  }
-}
-
-static
-void print_values (vf_eq2_t *eq2)
-{
-  ff_mp_msg (MSGT_VFILTER, MSGL_V, "vf_eq2: c=%.2f b=%.2f g=%.4f s=%.2f \n",
-    eq2->contrast, eq2->brightness, eq2->gamma, eq2->saturation
-  );
-}
-
-static
-void set_contrast (vf_eq2_t *eq2, double c)
-{
-  eq2->contrast = c;
-  eq2->param[0].c = c;
-  eq2->param[0].lut_clean = 0;
-  check_values (&eq2->param[0]);
-  print_values (eq2);
-}
-
-static
-void set_brightness (vf_eq2_t *eq2, double b)
-{
-  eq2->brightness = b;
-  eq2->param[0].b = b;
-  eq2->param[0].lut_clean = 0;
-  check_values (&eq2->param[0]);
-  print_values (eq2);
-}
-
-static
-void set_gamma (vf_eq2_t *eq2, double g)
-{
-  eq2->gamma = g;
-
-  eq2->param[0].g = eq2->gamma * eq2->ggamma;
-  eq2->param[1].g = sqrt (eq2->bgamma / eq2->ggamma);
-  eq2->param[2].g = sqrt (eq2->rgamma / eq2->ggamma);
-  eq2->param[0].w = eq2->param[1].w = eq2->param[2].w = eq2->gamma_weight;
-
-  eq2->param[0].lut_clean = 0;
-  eq2->param[1].lut_clean = 0;
-  eq2->param[2].lut_clean = 0;
-
-  check_values (&eq2->param[0]);
-  check_values (&eq2->param[1]);
-  check_values (&eq2->param[2]);
-
-  print_values (eq2);
-}
-
-static
-void set_saturation (vf_eq2_t *eq2, double s)
-{
-  eq2->saturation = s;
-
-  eq2->param[1].c = s;
-  eq2->param[2].c = s;
-
-  eq2->param[1].lut_clean = 0;
-  eq2->param[2].lut_clean = 0;
-
-  check_values (&eq2->param[1]);
-  check_values (&eq2->param[2]);
-
-  print_values (eq2);
-}
-
-static
-int control (vf_instance_t *vf, int request, void *data)
-{
-  vf_equalizer_t *eq;
-
-  switch (request) {
-    case VFCTRL_SET_EQUALIZER:
-      eq = (vf_equalizer_t *) data;
-
-      if (strcmp (eq->item, "gamma") == 0) {
-        set_gamma (vf->priv, exp (log (8.0) * eq->value / 100.0));
-        return CONTROL_TRUE;
-      }
-      else if (strcmp (eq->item, "contrast") == 0) {
-        set_contrast (vf->priv, (1.0 / 100.0) * (eq->value + 100));
-        return CONTROL_TRUE;
-      }
-      else if (strcmp (eq->item, "brightness") == 0) {
-        set_brightness (vf->priv, (1.0 / 100.0) * eq->value);
-        return CONTROL_TRUE;
-      }
-      else if (strcmp (eq->item, "saturation") == 0) {
-        set_saturation (vf->priv, (double) (eq->value + 100) / 100.0);
-        return CONTROL_TRUE;
-      }
-      break;
-
-    case VFCTRL_GET_EQUALIZER:
-      eq = (vf_equalizer_t *) data;
-      if (strcmp (eq->item, "gamma") == 0) {
-        eq->value = (int) (100.0 * log (vf->priv->gamma) / log (8.0));
-        return CONTROL_TRUE;
-      }
-      else if (strcmp (eq->item, "contrast") == 0) {
-        eq->value = (int) (100.0 * vf->priv->contrast) - 100;
-        return CONTROL_TRUE;
-      }
-      else if (strcmp (eq->item, "brightness") == 0) {
-        eq->value = (int) (100.0 * vf->priv->brightness);
-        return CONTROL_TRUE;
-      }
-      else if (strcmp (eq->item, "saturation") == 0) {
-        eq->value = (int) (100.0 * vf->priv->saturation) - 100;
-        return CONTROL_TRUE;
-      }
-      break;
-  }
-
-  return ff_vf_next_control (vf, request, data);
-}
-
-static
-int query_format (vf_instance_t *vf, unsigned fmt)
-{
-  switch (fmt) {
-    case IMGFMT_YVU9:
-    case IMGFMT_IF09:
-    case IMGFMT_YV12:
-    case IMGFMT_I420:
-    case IMGFMT_IYUV:
-    case IMGFMT_Y800:
-    case IMGFMT_Y8:
-    case IMGFMT_444P:
-    case IMGFMT_422P:
-    case IMGFMT_411P:
-      return ff_vf_next_query_format (vf, fmt);
-  }
-
-  return 0;
-}
-
-static
-void uninit (vf_instance_t *vf)
-{
-  if (vf->priv != NULL) {
-    free (vf->priv->buf[0]);
-    free (vf->priv);
-  }
-}
-
-static
-int vf_open(vf_instance_t *vf, char *args)
-{
-  unsigned i;
-  vf_eq2_t *eq2;
-  double   par[8];
-
-  vf->control = control;
-  vf->query_format = query_format;
-  vf->put_image = put_image;
-  vf->uninit = uninit;
-
-  vf->priv = malloc (sizeof (vf_eq2_t));
-  eq2 = vf->priv;
-
-  for (i = 0; i < 3; i++) {
-    eq2->buf[i] = NULL;
-    eq2->buf_w[i] = 0;
-    eq2->buf_h[i] = 0;
-
-    eq2->param[i].adjust = NULL;
-    eq2->param[i].c = 1.0;
-    eq2->param[i].b = 0.0;
-    eq2->param[i].g = 1.0;
-    eq2->param[i].lut_clean = 0;
-  }
-
-  eq2->contrast = 1.0;
-  eq2->brightness = 0.0;
-  eq2->saturation = 1.0;
-
-  eq2->gamma = 1.0;
-  eq2->gamma_weight = 1.0;
-  eq2->rgamma = 1.0;
-  eq2->ggamma = 1.0;
-  eq2->bgamma = 1.0;
-
-  if (args != NULL) {
-    par[0] = 1.0;
-    par[1] = 1.0;
-    par[2] = 0.0;
-    par[3] = 1.0;
-    par[4] = 1.0;
-    par[5] = 1.0;
-    par[6] = 1.0;
-    par[7] = 1.0;
-    sscanf (args, "%lf:%lf:%lf:%lf:%lf:%lf:%lf:%lf",
-      par, par + 1, par + 2, par + 3, par + 4, par + 5, par + 6, par + 7
-    );
-
-    eq2->rgamma = par[4];
-    eq2->ggamma = par[5];
-    eq2->bgamma = par[6];
-    eq2->gamma_weight = par[7];
-
-    set_gamma (eq2, par[0]);
-    set_contrast (eq2, par[1]);
-    set_brightness (eq2, par[2]);
-    set_saturation (eq2, par[3]);
-  }
-
-  return 1;
-}
-
-const vf_info_t ff_vf_info_eq2 = {
-  "Software equalizer",
-  "eq2",
-  "Hampa Hug, Daniel Moreno, Richard Felker",
-  "",
-  &vf_open,
-  NULL
-};
diff --git a/libavfilter/libmpcodecs/vf_fspp.c b/libavfilter/libmpcodecs/vf_fspp.c
deleted file mode 100644
index a8a33e2..0000000
--- a/libavfilter/libmpcodecs/vf_fspp.c
+++ /dev/null
@@ -1,2118 +0,0 @@
-/*
- * Copyright (C) 2003 Michael Niedermayer <michaelni@gmx.at>
- * Copyright (C) 2005 Nikolaj Poroshin <porosh3@psu.ru>
- *
- * This file is part of MPlayer.
- *
- * MPlayer is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * MPlayer is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with MPlayer; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-/*
- * This implementation is based on an algorithm described in
- * "Aria Nosratinia Embedded Post-Processing for
- * Enhancement of Compressed Images (1999)"
- * (http://citeseer.nj.nec.com/nosratinia99embedded.html)
- * Futher, with splitting (i)dct into hor/ver passes, one of them can be
- * performed once per block, not pixel. This allows for much better speed.
- */
-
-/*
-  Heavily optimized version of SPP filter by Nikolaj
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <inttypes.h>
-#include <math.h>
-
-#include "config.h"
-
-#include "mp_msg.h"
-#include "cpudetect.h"
-#include "img_format.h"
-#include "mp_image.h"
-#include "vf.h"
-#include "av_helpers.h"
-#include "libvo/fastmemcpy.h"
-
-#include "libavutil/internal.h"
-#include "libavutil/intreadwrite.h"
-#include "libavutil/mem.h"
-#include "libavutil/x86/asm.h"
-#include "libavcodec/avcodec.h"
-#include "libavcodec/dsputil.h"
-
-#undef free
-#undef malloc
-
-//===========================================================================//
-#define BLOCKSZ 12
-
-static const short custom_threshold[64]=
-// values (296) can't be too high
-// -it causes too big quant dependence
-// or maybe overflow(check), which results in some flashing
-{ 71, 296, 295, 237,  71,  40,  38,  19,
-  245, 193, 185, 121, 102,  73,  53,  27,
-  158, 129, 141, 107,  97,  73,  50,  26,
-  102, 116, 109,  98,  82,  66,  45,  23,
-  71,  94,  95,  81,  70,  56,  38,  20,
-  56,  77,  74,  66,  56,  44,  30,  15,
-  38,  53,  50,  45,  38,  30,  21,  11,
-  20,  27,  26,  23,  20,  15,  11,   5
-};
-
-static const uint8_t  __attribute__((aligned(32))) dither[8][8]={
-    {  0,  48,  12,  60,   3,  51,  15,  63, },
-    { 32,  16,  44,  28,  35,  19,  47,  31, },
-    {  8,  56,   4,  52,  11,  59,   7,  55, },
-    { 40,  24,  36,  20,  43,  27,  39,  23, },
-    {  2,  50,  14,  62,   1,  49,  13,  61, },
-    { 34,  18,  46,  30,  33,  17,  45,  29, },
-    { 10,  58,   6,  54,   9,  57,   5,  53, },
-    { 42,  26,  38,  22,  41,  25,  37,  21, },
-};
-
-struct vf_priv_s { //align 16 !
-    uint64_t threshold_mtx_noq[8*2];
-    uint64_t threshold_mtx[8*2];//used in both C & MMX (& later SSE2) versions
-
-    int log2_count;
-    int temp_stride;
-    int qp;
-    int mpeg2;
-    int prev_q;
-    uint8_t *src;
-    int16_t *temp;
-    int bframes;
-    char *non_b_qp;
-};
-
-
-#if !HAVE_MMX
-
-//This func reads from 1 slice, 1 and clears 0 & 1
-static void store_slice_c(uint8_t *dst, int16_t *src, int dst_stride, int src_stride, int width, int height, int log2_scale)
-{int y, x;
-#define STORE(pos)                                                        \
-    temp= (src[x + pos] + (d[pos]>>log2_scale))>>(6-log2_scale);        \
-    src[x + pos]=src[x + pos - 8*src_stride]=0;                                \
-    if(temp & 0x100) temp= ~(temp>>31);                                        \
-    dst[x + pos]= temp;
-
-    for(y=0; y<height; y++){
-        const uint8_t *d= dither[y];
-        for(x=0; x<width; x+=8){
-            int temp;
-            STORE(0);
-            STORE(1);
-            STORE(2);
-            STORE(3);
-            STORE(4);
-            STORE(5);
-            STORE(6);
-            STORE(7);
-        }
-        src+=src_stride;
-        dst+=dst_stride;
-    }
-}
-
-//This func reads from 2 slices, 0 & 2  and clears 2-nd
-static void store_slice2_c(uint8_t *dst, int16_t *src, int dst_stride, int src_stride, int width, int height, int log2_scale)
-{int y, x;
-#define STORE2(pos)                                                        \
-    temp= (src[x + pos] + src[x + pos + 16*src_stride] + (d[pos]>>log2_scale))>>(6-log2_scale);        \
-    src[x + pos + 16*src_stride]=0;                                        \
-    if(temp & 0x100) temp= ~(temp>>31);                                        \
-    dst[x + pos]= temp;
-
-    for(y=0; y<height; y++){
-        const uint8_t *d= dither[y];
-        for(x=0; x<width; x+=8){
-            int temp;
-            STORE2(0);
-            STORE2(1);
-            STORE2(2);
-            STORE2(3);
-            STORE2(4);
-            STORE2(5);
-            STORE2(6);
-            STORE2(7);
-        }
-        src+=src_stride;
-        dst+=dst_stride;
-    }
-}
-
-static void mul_thrmat_c(struct vf_priv_s *p,int q)
-{
-    int a;
-    for(a=0;a<64;a++)
-        ((short*)p->threshold_mtx)[a]=q * ((short*)p->threshold_mtx_noq)[a];//ints faster in C
-}
-
-static void column_fidct_c(int16_t* thr_adr, int16_t *data, int16_t *output, int cnt);
-static void row_idct_c(int16_t* workspace,
-                       int16_t* output_adr, int output_stride, int cnt);
-static void row_fdct_c(int16_t *data, const uint8_t *pixels, int line_size, int cnt);
-
-//this is rather ugly, but there is no need for function pointers
-#define store_slice_s store_slice_c
-#define store_slice2_s store_slice2_c
-#define mul_thrmat_s mul_thrmat_c
-#define column_fidct_s column_fidct_c
-#define row_idct_s row_idct_c
-#define row_fdct_s row_fdct_c
-
-#else /* HAVE_MMX */
-
-//This func reads from 1 slice, 1 and clears 0 & 1
-static void store_slice_mmx(uint8_t *dst, int16_t *src, long dst_stride, long src_stride, long width, long height, long log2_scale)
-{
-    const uint8_t *od=&dither[0][0];
-    const uint8_t *end=&dither[height][0];
-    width = (width+7)&~7;
-    dst_stride-=width;
-    //src_stride=(src_stride-width)*2;
-    __asm__ volatile(
-        "mov %5, %%"REG_d"                \n\t"
-        "mov %6, %%"REG_S"                \n\t"
-        "mov %7, %%"REG_D"                \n\t"
-        "mov %1, %%"REG_a"                \n\t"
-        "movd %%"REG_d", %%mm5             \n\t"
-        "xor $-1, %%"REG_d"              \n\t"
-        "mov %%"REG_a", %%"REG_c"             \n\t"
-        "add $7, %%"REG_d"               \n\t"
-        "neg %%"REG_a"                   \n\t"
-        "sub %0, %%"REG_c"            \n\t"
-        "add %%"REG_c", %%"REG_c"             \n\t"
-        "movd %%"REG_d", %%mm2             \n\t"
-        "mov %%"REG_c", %1       \n\t"
-        "mov %2, %%"REG_d"               \n\t"
-        "shl $4, %%"REG_a"               \n\t"
-
-        "2:                        \n\t"
-        "movq (%%"REG_d"), %%mm3           \n\t"
-        "movq %%mm3, %%mm4             \n\t"
-        "pxor %%mm7, %%mm7             \n\t"
-        "punpcklbw %%mm7, %%mm3        \n\t"
-        "punpckhbw %%mm7, %%mm4        \n\t"
-        "mov %0, %%"REG_c"            \n\t"
-        "psraw %%mm5, %%mm3            \n\t"
-        "psraw %%mm5, %%mm4            \n\t"
-        "1:                        \n\t"
-        "movq %%mm7, (%%"REG_S",%%"REG_a",)     \n\t"
-        "movq (%%"REG_S"), %%mm0           \n\t"
-        "movq 8(%%"REG_S"), %%mm1          \n\t"
-
-        "movq %%mm7, 8(%%"REG_S",%%"REG_a",)    \n\t"
-        "paddw %%mm3, %%mm0            \n\t"
-        "paddw %%mm4, %%mm1            \n\t"
-
-        "movq %%mm7, (%%"REG_S")           \n\t"
-        "psraw %%mm2, %%mm0            \n\t"
-        "psraw %%mm2, %%mm1            \n\t"
-
-        "movq %%mm7, 8(%%"REG_S")          \n\t"
-        "packuswb %%mm1, %%mm0         \n\t"
-        "add $16, %%"REG_S"              \n\t"
-
-        "movq %%mm0, (%%"REG_D")           \n\t"
-        "add $8, %%"REG_D"               \n\t"
-        "sub $8, %%"REG_c"               \n\t"
-        "jg 1b                      \n\t"
-        "add %1, %%"REG_S"       \n\t"
-        "add $8, %%"REG_d"               \n\t"
-        "add %3, %%"REG_D"       \n\t"
-        "cmp %4, %%"REG_d"           \n\t"
-        "jl 2b                      \n\t"
-
-        :
-        : "m" (width), "m" (src_stride), "erm" (od), "m" (dst_stride), "erm" (end),
-          "m" (log2_scale), "m" (src), "m" (dst) //input
-        : "%"REG_a, "%"REG_c, "%"REG_d, "%"REG_S, "%"REG_D
-        );
-}
-
-//This func reads from 2 slices, 0 & 2  and clears 2-nd
-static void store_slice2_mmx(uint8_t *dst, int16_t *src, long dst_stride, long src_stride, long width, long height, long log2_scale)
-{
-    const uint8_t *od=&dither[0][0];
-    const uint8_t *end=&dither[height][0];
-    width = (width+7)&~7;
-    dst_stride-=width;
-    //src_stride=(src_stride-width)*2;
-    __asm__ volatile(
-        "mov %5, %%"REG_d"                \n\t"
-        "mov %6, %%"REG_S"                \n\t"
-        "mov %7, %%"REG_D"                \n\t"
-        "mov %1, %%"REG_a"            \n\t"
-        "movd %%"REG_d", %%mm5             \n\t"
-        "xor $-1, %%"REG_d"              \n\t"
-        "mov %%"REG_a", %%"REG_c"             \n\t"
-        "add $7, %%"REG_d"               \n\t"
-        "sub %0, %%"REG_c"            \n\t"
-        "add %%"REG_c", %%"REG_c"             \n\t"
-        "movd %%"REG_d", %%mm2             \n\t"
-        "mov %%"REG_c", %1       \n\t"
-        "mov %2, %%"REG_d"               \n\t"
-        "shl $5, %%"REG_a"               \n\t"
-
-        "2:                        \n\t"
-        "movq (%%"REG_d"), %%mm3           \n\t"
-        "movq %%mm3, %%mm4             \n\t"
-        "pxor %%mm7, %%mm7             \n\t"
-        "punpcklbw %%mm7, %%mm3        \n\t"
-        "punpckhbw %%mm7, %%mm4        \n\t"
-        "mov %0, %%"REG_c"            \n\t"
-        "psraw %%mm5, %%mm3            \n\t"
-        "psraw %%mm5, %%mm4            \n\t"
-        "1:                        \n\t"
-        "movq (%%"REG_S"), %%mm0           \n\t"
-        "movq 8(%%"REG_S"), %%mm1          \n\t"
-        "paddw %%mm3, %%mm0            \n\t"
-
-        "paddw (%%"REG_S",%%"REG_a",), %%mm0    \n\t"
-        "paddw %%mm4, %%mm1            \n\t"
-        "movq 8(%%"REG_S",%%"REG_a",), %%mm6    \n\t"
-
-        "movq %%mm7, (%%"REG_S",%%"REG_a",)     \n\t"
-        "psraw %%mm2, %%mm0            \n\t"
-        "paddw %%mm6, %%mm1            \n\t"
-
-        "movq %%mm7, 8(%%"REG_S",%%"REG_a",)    \n\t"
-        "psraw %%mm2, %%mm1            \n\t"
-        "packuswb %%mm1, %%mm0         \n\t"
-
-        "movq %%mm0, (%%"REG_D")           \n\t"
-        "add $16, %%"REG_S"              \n\t"
-        "add $8, %%"REG_D"               \n\t"
-        "sub $8, %%"REG_c"               \n\t"
-        "jg 1b                      \n\t"
-        "add %1, %%"REG_S"       \n\t"
-        "add $8, %%"REG_d"               \n\t"
-        "add %3, %%"REG_D"       \n\t"
-        "cmp %4, %%"REG_d"           \n\t"
-        "jl 2b                      \n\t"
-
-        :
-        : "m" (width), "m" (src_stride), "erm" (od), "m" (dst_stride), "erm" (end),
-          "m" (log2_scale), "m" (src), "m" (dst) //input
-        : "%"REG_a, "%"REG_c, "%"REG_d, "%"REG_D, "%"REG_S
-        );
-}
-
-static void mul_thrmat_mmx(struct vf_priv_s *p, int q)
-{
-    uint64_t *adr=&p->threshold_mtx_noq[0];
-    __asm__ volatile(
-        "movd %0, %%mm7                \n\t"
-        "add $8*8*2, %%"REG_D"            \n\t"
-        "movq 0*8(%%"REG_S"), %%mm0        \n\t"
-        "punpcklwd %%mm7, %%mm7        \n\t"
-        "movq 1*8(%%"REG_S"), %%mm1        \n\t"
-        "punpckldq %%mm7, %%mm7        \n\t"
-        "pmullw %%mm7, %%mm0           \n\t"
-
-        "movq 2*8(%%"REG_S"), %%mm2        \n\t"
-        "pmullw %%mm7, %%mm1           \n\t"
-
-        "movq 3*8(%%"REG_S"), %%mm3        \n\t"
-        "pmullw %%mm7, %%mm2           \n\t"
-
-        "movq %%mm0, 0*8(%%"REG_D")        \n\t"
-        "movq 4*8(%%"REG_S"), %%mm4        \n\t"
-        "pmullw %%mm7, %%mm3           \n\t"
-
-        "movq %%mm1, 1*8(%%"REG_D")        \n\t"
-        "movq 5*8(%%"REG_S"), %%mm5        \n\t"
-        "pmullw %%mm7, %%mm4           \n\t"
-
-        "movq %%mm2, 2*8(%%"REG_D")        \n\t"
-        "movq 6*8(%%"REG_S"), %%mm6        \n\t"
-        "pmullw %%mm7, %%mm5           \n\t"
-
-        "movq %%mm3, 3*8(%%"REG_D")        \n\t"
-        "movq 7*8+0*8(%%"REG_S"), %%mm0    \n\t"
-        "pmullw %%mm7, %%mm6           \n\t"
-
-        "movq %%mm4, 4*8(%%"REG_D")        \n\t"
-        "movq 7*8+1*8(%%"REG_S"), %%mm1    \n\t"
-        "pmullw %%mm7, %%mm0           \n\t"
-
-        "movq %%mm5, 5*8(%%"REG_D")        \n\t"
-        "movq 7*8+2*8(%%"REG_S"), %%mm2    \n\t"
-        "pmullw %%mm7, %%mm1           \n\t"
-
-        "movq %%mm6, 6*8(%%"REG_D")        \n\t"
-        "movq 7*8+3*8(%%"REG_S"), %%mm3    \n\t"
-        "pmullw %%mm7, %%mm2           \n\t"
-
-        "movq %%mm0, 7*8+0*8(%%"REG_D")    \n\t"
-        "movq 7*8+4*8(%%"REG_S"), %%mm4    \n\t"
-        "pmullw %%mm7, %%mm3           \n\t"
-
-        "movq %%mm1, 7*8+1*8(%%"REG_D")    \n\t"
-        "movq 7*8+5*8(%%"REG_S"), %%mm5    \n\t"
-        "pmullw %%mm7, %%mm4           \n\t"
-
-        "movq %%mm2, 7*8+2*8(%%"REG_D")    \n\t"
-        "movq 7*8+6*8(%%"REG_S"), %%mm6    \n\t"
-        "pmullw %%mm7, %%mm5           \n\t"
-
-        "movq %%mm3, 7*8+3*8(%%"REG_D")    \n\t"
-        "movq 14*8+0*8(%%"REG_S"), %%mm0   \n\t"
-        "pmullw %%mm7, %%mm6           \n\t"
-
-        "movq %%mm4, 7*8+4*8(%%"REG_D")    \n\t"
-        "movq 14*8+1*8(%%"REG_S"), %%mm1   \n\t"
-        "pmullw %%mm7, %%mm0           \n\t"
-
-        "movq %%mm5, 7*8+5*8(%%"REG_D")    \n\t"
-        "pmullw %%mm7, %%mm1           \n\t"
-
-        "movq %%mm6, 7*8+6*8(%%"REG_D")    \n\t"
-        "movq %%mm0, 14*8+0*8(%%"REG_D")   \n\t"
-        "movq %%mm1, 14*8+1*8(%%"REG_D")   \n\t"
-
-        : "+g" (q), "+S" (adr), "+D" (adr)
-        :
-        );
-}
-
-static void column_fidct_mmx(int16_t* thr_adr,  int16_t *data,  int16_t *output,  int cnt);
-static void row_idct_mmx(int16_t* workspace,
-                         int16_t* output_adr,  int output_stride,  int cnt);
-static void row_fdct_mmx(int16_t *data,  const uint8_t *pixels,  int line_size,  int cnt);
-
-#define store_slice_s store_slice_mmx
-#define store_slice2_s store_slice2_mmx
-#define mul_thrmat_s mul_thrmat_mmx
-#define column_fidct_s column_fidct_mmx
-#define row_idct_s row_idct_mmx
-#define row_fdct_s row_fdct_mmx
-#endif // HAVE_MMX
-
-static void filter(struct vf_priv_s *p, uint8_t *dst, uint8_t *src,
-                   int dst_stride, int src_stride,
-                   int width, int height,
-                   uint8_t *qp_store, int qp_stride, int is_luma)
-{
-    int x, x0, y, es, qy, t;
-    const int stride= is_luma ? p->temp_stride : (width+16);//((width+16+15)&(~15))
-    const int step=6-p->log2_count;
-    const int qps= 3 + is_luma;
-    int32_t __attribute__((aligned(32))) block_align[4*8*BLOCKSZ+ 4*8*BLOCKSZ];
-    int16_t *block= (int16_t *)block_align;
-    int16_t *block3=(int16_t *)(block_align+4*8*BLOCKSZ);
-
-    memset(block3, 0, 4*8*BLOCKSZ);
-
-    //p->src=src-src_stride*8-8;//!
-    if (!src || !dst) return; // HACK avoid crash for Y8 colourspace
-    for(y=0; y<height; y++){
-        int index= 8 + 8*stride + y*stride;
-        fast_memcpy(p->src + index, src + y*src_stride, width);//this line can be avoided by using DR & user fr.buffers
-        for(x=0; x<8; x++){
-            p->src[index         - x - 1]= p->src[index +         x    ];
-            p->src[index + width + x    ]= p->src[index + width - x - 1];
-        }
-    }
-    for(y=0; y<8; y++){
-        fast_memcpy(p->src + (      7-y)*stride, p->src + (      y+8)*stride, stride);
-        fast_memcpy(p->src + (height+8+y)*stride, p->src + (height-y+7)*stride, stride);
-    }
-    //FIXME (try edge emu)
-
-    for(y=8; y<24; y++)
-        memset(p->temp+ 8 +y*stride, 0,width*sizeof(int16_t));
-
-    for(y=step; y<height+8; y+=step){    //step= 1,2
-        qy=y-4;
-        if (qy>height-1) qy=height-1;
-        if (qy<0) qy=0;
-        qy=(qy>>qps)*qp_stride;
-        row_fdct_s(block, p->src + y*stride +2-(y&1), stride, 2);
-        for(x0=0; x0<width+8-8*(BLOCKSZ-1); x0+=8*(BLOCKSZ-1)){
-            row_fdct_s(block+8*8, p->src + y*stride+8+x0 +2-(y&1), stride, 2*(BLOCKSZ-1));
-            if(p->qp)
-                column_fidct_s((int16_t*)(&p->threshold_mtx[0]), block+0*8, block3+0*8, 8*(BLOCKSZ-1)); //yes, this is a HOTSPOT
-            else
-                for (x=0; x<8*(BLOCKSZ-1); x+=8) {
-                    t=x+x0-2; //correct t=x+x0-2-(y&1), but its the same
-                    if (t<0) t=0;//t always < width-2
-                    t=qp_store[qy+(t>>qps)];
-                    t=norm_qscale(t, p->mpeg2);
-                    if (t!=p->prev_q) p->prev_q=t, mul_thrmat_s(p, t);
-                    column_fidct_s((int16_t*)(&p->threshold_mtx[0]), block+x*8, block3+x*8, 8); //yes, this is a HOTSPOT
-                }
-            row_idct_s(block3+0*8, p->temp + (y&15)*stride+x0+2-(y&1), stride, 2*(BLOCKSZ-1));
-            memmove(block, block+(BLOCKSZ-1)*64, 8*8*sizeof(int16_t)); //cycling
-            memmove(block3, block3+(BLOCKSZ-1)*64, 6*8*sizeof(int16_t));
-        }
-        //
-        es=width+8-x0; //  8, ...
-        if (es>8)
-            row_fdct_s(block+8*8, p->src + y*stride+8+x0 +2-(y&1), stride, (es-4)>>2);
-        column_fidct_s((int16_t*)(&p->threshold_mtx[0]), block, block3, es&(~1));
-        row_idct_s(block3+0*8, p->temp + (y&15)*stride+x0+2-(y&1), stride, es>>2);
-        {const int y1=y-8+step;//l5-7  l4-6
-            if (!(y1&7) && y1) {
-                if (y1&8) store_slice_s(dst + (y1-8)*dst_stride, p->temp+ 8 +8*stride,
-                                        dst_stride, stride, width, 8, 5-p->log2_count);
-                else store_slice2_s(dst + (y1-8)*dst_stride, p->temp+ 8 +0*stride,
-                                    dst_stride, stride, width, 8, 5-p->log2_count);
-            } }
-    }
-
-    if (y&7) {  // == height & 7
-        if (y&8) store_slice_s(dst + ((y-8)&~7)*dst_stride, p->temp+ 8 +8*stride,
-                               dst_stride, stride, width, y&7, 5-p->log2_count);
-        else store_slice2_s(dst + ((y-8)&~7)*dst_stride, p->temp+ 8 +0*stride,
-                            dst_stride, stride, width, y&7, 5-p->log2_count);
-    }
-}
-
-static int config(struct vf_instance *vf,
-                  int width, int height, int d_width, int d_height,
-                  unsigned int flags, unsigned int outfmt)
-{
-    int h= (height+16+15)&(~15);
-
-    vf->priv->temp_stride= (width+16+15)&(~15);
-    vf->priv->temp= (int16_t*)av_mallocz(vf->priv->temp_stride*3*8*sizeof(int16_t));
-    //this can also be avoided, see above
-    vf->priv->src = (uint8_t*)av_malloc(vf->priv->temp_stride*h*sizeof(uint8_t));
-
-    return ff_vf_next_config(vf,width,height,d_width,d_height,flags,outfmt);
-}
-
-static void get_image(struct vf_instance *vf, mp_image_t *mpi)
-{
-    if(mpi->flags&MP_IMGFLAG_PRESERVE) return; // don't change
-    // ok, we can do pp in-place (or pp disabled):
-    vf->dmpi=ff_vf_get_image(vf->next,mpi->imgfmt,
-                          mpi->type, mpi->flags, mpi->width, mpi->height);
-    mpi->planes[0]=vf->dmpi->planes[0];
-    mpi->stride[0]=vf->dmpi->stride[0];
-    mpi->width=vf->dmpi->width;
-    if(mpi->flags&MP_IMGFLAG_PLANAR){
-        mpi->planes[1]=vf->dmpi->planes[1];
-        mpi->planes[2]=vf->dmpi->planes[2];
-        mpi->stride[1]=vf->dmpi->stride[1];
-        mpi->stride[2]=vf->dmpi->stride[2];
-    }
-    mpi->flags|=MP_IMGFLAG_DIRECT;
-}
-
-static int put_image(struct vf_instance *vf, mp_image_t *mpi, double pts)
-{
-    mp_image_t *dmpi;
-    if(!(mpi->flags&MP_IMGFLAG_DIRECT)){
-        // no DR, so get a new image! hope we'll get DR buffer:
-        dmpi=ff_vf_get_image(vf->next,mpi->imgfmt,
-                          MP_IMGTYPE_TEMP,
-                          MP_IMGFLAG_ACCEPT_STRIDE|MP_IMGFLAG_PREFER_ALIGNED_STRIDE,
-                          mpi->width,mpi->height);
-        ff_vf_clone_mpi_attributes(dmpi, mpi);
-    }else{
-        dmpi=vf->dmpi;
-    }
-
-    vf->priv->mpeg2= mpi->qscale_type;
-    if(mpi->pict_type != 3 && mpi->qscale && !vf->priv->qp){
-        int w = mpi->qstride;
-        int h = (mpi->h + 15) >> 4;
-        if (!w) {
-            w = (mpi->w + 15) >> 4;
-            h = 1;
-        }
-        if(!vf->priv->non_b_qp)
-            vf->priv->non_b_qp= malloc(w*h);
-        fast_memcpy(vf->priv->non_b_qp, mpi->qscale, w*h);
-    }
-    if(vf->priv->log2_count || !(mpi->flags&MP_IMGFLAG_DIRECT)){
-        char *qp_tab= vf->priv->non_b_qp;
-        if(vf->priv->bframes || !qp_tab)
-            qp_tab= mpi->qscale;
-
-        if(qp_tab || vf->priv->qp){
-            filter(vf->priv, dmpi->planes[0], mpi->planes[0], dmpi->stride[0], mpi->stride[0],
-                   mpi->w, mpi->h, qp_tab, mpi->qstride, 1);
-            filter(vf->priv, dmpi->planes[1], mpi->planes[1], dmpi->stride[1], mpi->stride[1],
-                   mpi->w>>mpi->chroma_x_shift, mpi->h>>mpi->chroma_y_shift, qp_tab, mpi->qstride, 0);
-            filter(vf->priv, dmpi->planes[2], mpi->planes[2], dmpi->stride[2], mpi->stride[2],
-                   mpi->w>>mpi->chroma_x_shift, mpi->h>>mpi->chroma_y_shift, qp_tab, mpi->qstride, 0);
-        }else{
-            memcpy_pic(dmpi->planes[0], mpi->planes[0], mpi->w, mpi->h, dmpi->stride[0], mpi->stride[0]);
-            memcpy_pic(dmpi->planes[1], mpi->planes[1], mpi->w>>mpi->chroma_x_shift, mpi->h>>mpi->chroma_y_shift, dmpi->stride[1], mpi->stride[1]);
-            memcpy_pic(dmpi->planes[2], mpi->planes[2], mpi->w>>mpi->chroma_x_shift, mpi->h>>mpi->chroma_y_shift, dmpi->stride[2], mpi->stride[2]);
-        }
-    }
-
-#if HAVE_MMX
-    if(ff_gCpuCaps.hasMMX) __asm__ volatile ("emms\n\t");
-#endif
-#if HAVE_MMX2
-    if(ff_gCpuCaps.hasMMX2) __asm__ volatile ("sfence\n\t");
-#endif
-    return ff_vf_next_put_image(vf,dmpi, pts);
-}
-
-static void uninit(struct vf_instance *vf)
-{
-    if(!vf->priv) return;
-
-    av_free(vf->priv->temp);
-    vf->priv->temp= NULL;
-    av_free(vf->priv->src);
-    vf->priv->src= NULL;
-    //free(vf->priv->avctx);
-    //vf->priv->avctx= NULL;
-    free(vf->priv->non_b_qp);
-    vf->priv->non_b_qp= NULL;
-
-    av_free(vf->priv);
-    vf->priv=NULL;
-}
-
-//===========================================================================//
-
-static int query_format(struct vf_instance *vf, unsigned int fmt)
-{
-    switch(fmt){
-    case IMGFMT_YVU9:
-    case IMGFMT_IF09:
-    case IMGFMT_YV12:
-    case IMGFMT_I420:
-    case IMGFMT_IYUV:
-    case IMGFMT_CLPL:
-    case IMGFMT_Y800:
-    case IMGFMT_Y8:
-    case IMGFMT_444P:
-    case IMGFMT_422P:
-    case IMGFMT_411P:
-        return ff_vf_next_query_format(vf,fmt);
-    }
-    return 0;
-}
-
-static int control(struct vf_instance *vf, int request, void* data)
-{
-    switch(request){
-    case VFCTRL_QUERY_MAX_PP_LEVEL:
-        return 5;
-    case VFCTRL_SET_PP_LEVEL:
-        vf->priv->log2_count= *((unsigned int*)data);
-        if (vf->priv->log2_count < 4) vf->priv->log2_count=4;
-        return CONTROL_TRUE;
-    }
-    return ff_vf_next_control(vf,request,data);
-}
-
-static int vf_open(vf_instance_t *vf, char *args)
-{
-    int i=0, bias;
-    int custom_threshold_m[64];
-    int log2c=-1;
-
-    vf->config=config;
-    vf->put_image=put_image;
-    vf->get_image=get_image;
-    vf->query_format=query_format;
-    vf->uninit=uninit;
-    vf->control= control;
-    vf->priv=av_mallocz(sizeof(struct vf_priv_s));//assumes align 16 !
-
-    ff_init_avcodec();
-
-    //vf->priv->avctx= avcodec_alloc_context();
-    //dsputil_init(&vf->priv->dsp, vf->priv->avctx);
-
-    vf->priv->log2_count= 4;
-    vf->priv->bframes = 0;
-
-    if (args) sscanf(args, "%d:%d:%d:%d", &log2c, &vf->priv->qp, &i, &vf->priv->bframes);
-
-    if( log2c >=4 && log2c <=5 )
-        vf->priv->log2_count = log2c;
-    else if( log2c >= 6 )
-        vf->priv->log2_count = 5;
-
-    if(vf->priv->qp < 0)
-        vf->priv->qp = 0;
-
-    if (i < -15) i = -15;
-    if (i > 32) i = 32;
-
-    bias= (1<<4)+i; //regulable
-    vf->priv->prev_q=0;
-    //
-    for(i=0;i<64;i++) //FIXME: tune custom_threshold[] and remove this !
-        custom_threshold_m[i]=(int)(custom_threshold[i]*(bias/71.)+ 0.5);
-    for(i=0;i<8;i++){
-        vf->priv->threshold_mtx_noq[2*i]=(uint64_t)custom_threshold_m[i*8+2]
-            |(((uint64_t)custom_threshold_m[i*8+6])<<16)
-            |(((uint64_t)custom_threshold_m[i*8+0])<<32)
-            |(((uint64_t)custom_threshold_m[i*8+4])<<48);
-        vf->priv->threshold_mtx_noq[2*i+1]=(uint64_t)custom_threshold_m[i*8+5]
-            |(((uint64_t)custom_threshold_m[i*8+3])<<16)
-            |(((uint64_t)custom_threshold_m[i*8+1])<<32)
-            |(((uint64_t)custom_threshold_m[i*8+7])<<48);
-    }
-
-    if (vf->priv->qp) vf->priv->prev_q=vf->priv->qp, mul_thrmat_s(vf->priv, vf->priv->qp);
-
-    return 1;
-}
-
-const vf_info_t ff_vf_info_fspp = {
-    "fast simple postprocess",
-    "fspp",
-    "Michael Niedermayer, Nikolaj Poroshin",
-    "",
-    vf_open,
-    NULL
-};
-
-//====================================================================
-//Specific spp's dct, idct and threshold functions
-//I'd prefer to have them in the separate file.
-
-//#define MANGLE(a) #a
-
-//typedef int16_t int16_t; //! only int16_t
-
-#define DCTSIZE 8
-#define DCTSIZE_S "8"
-
-#define FIX(x,s)  ((int) ((x) * (1<<s) + 0.5)&0xffff)
-#define C64(x)    ((uint64_t)((x)|(x)<<16))<<32 | (uint64_t)(x) | (uint64_t)(x)<<16
-#define FIX64(x,s)  C64(FIX(x,s))
-
-#define MULTIPLY16H(x,k)   (((x)*(k))>>16)
-#define THRESHOLD(r,x,t) if(((unsigned)((x)+t))>t*2) r=(x);else r=0;
-#define DESCALE(x,n)  (((x) + (1 << ((n)-1))) >> n)
-
-#if HAVE_MMX
-
-DECLARE_ASM_CONST(8, uint64_t, MM_FIX_0_382683433)=FIX64(0.382683433, 14);
-DECLARE_ALIGNED(8, uint64_t, ff_MM_FIX_0_541196100)=FIX64(0.541196100, 14);
-DECLARE_ALIGNED(8, uint64_t, ff_MM_FIX_0_707106781)=FIX64(0.707106781, 14);
-DECLARE_ASM_CONST(8, uint64_t, MM_FIX_1_306562965)=FIX64(1.306562965, 14);
-
-DECLARE_ASM_CONST(8, uint64_t, MM_FIX_1_414213562_A)=FIX64(1.414213562, 14);
-
-DECLARE_ASM_CONST(8, uint64_t, MM_FIX_1_847759065)=FIX64(1.847759065, 13);
-DECLARE_ASM_CONST(8, uint64_t, MM_FIX_2_613125930)=FIX64(-2.613125930, 13); //-
-DECLARE_ASM_CONST(8, uint64_t, MM_FIX_1_414213562)=FIX64(1.414213562, 13);
-DECLARE_ASM_CONST(8, uint64_t, MM_FIX_1_082392200)=FIX64(1.082392200, 13);
-//for t3,t5,t7 == 0 shortcut
-DECLARE_ASM_CONST(8, uint64_t, MM_FIX_0_847759065)=FIX64(0.847759065, 14);
-DECLARE_ASM_CONST(8, uint64_t, MM_FIX_0_566454497)=FIX64(0.566454497, 14);
-DECLARE_ASM_CONST(8, uint64_t, MM_FIX_0_198912367)=FIX64(0.198912367, 14);
-
-DECLARE_ASM_CONST(8, uint64_t, MM_DESCALE_RND)=C64(4);
-DECLARE_ASM_CONST(8, uint64_t, MM_2)=C64(2);
-
-#else /* !HAVE_MMX */
-
-typedef int32_t int_simd16_t;
-static const int16_t FIX_0_382683433=FIX(0.382683433, 14);
-static const int16_t FIX_0_541196100=FIX(0.541196100, 14);
-static const int16_t FIX_0_707106781=FIX(0.707106781, 14);
-static const int16_t FIX_1_306562965=FIX(1.306562965, 14);
-static const int16_t FIX_1_414213562_A=FIX(1.414213562, 14);
-static const int16_t FIX_1_847759065=FIX(1.847759065, 13);
-static const int16_t FIX_2_613125930=FIX(-2.613125930, 13); //-
-static const int16_t FIX_1_414213562=FIX(1.414213562, 13);
-static const int16_t FIX_1_082392200=FIX(1.082392200, 13);
-
-#endif
-
-#if !HAVE_MMX
-
-static void column_fidct_c(int16_t* thr_adr, int16_t *data, int16_t *output, int cnt)
-{
-    int_simd16_t tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
-    int_simd16_t tmp10, tmp11, tmp12, tmp13;
-    int_simd16_t z1,z2,z3,z4,z5, z10, z11, z12, z13;
-    int_simd16_t d0, d1, d2, d3, d4, d5, d6, d7;
-
-    int16_t* dataptr;
-    int16_t* wsptr;
-    int16_t *threshold;
-    int ctr;
-
-    dataptr = data;
-    wsptr = output;
-
-    for (; cnt > 0; cnt-=2) { //start positions
-        threshold=(int16_t*)thr_adr;//threshold_mtx
-        for (ctr = DCTSIZE; ctr > 0; ctr--) {
-            // Process columns from input, add to output.
-            tmp0 = dataptr[DCTSIZE*0] + dataptr[DCTSIZE*7];
-            tmp7 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*7];
-
-            tmp1 = dataptr[DCTSIZE*1] + dataptr[DCTSIZE*6];
-            tmp6 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*6];
-
-            tmp2 = dataptr[DCTSIZE*2] + dataptr[DCTSIZE*5];
-            tmp5 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*5];
-
-            tmp3 = dataptr[DCTSIZE*3] + dataptr[DCTSIZE*4];
-            tmp4 = dataptr[DCTSIZE*3] - dataptr[DCTSIZE*4];
-
-            // Even part of FDCT
-
-            tmp10 = tmp0 + tmp3;
-            tmp13 = tmp0 - tmp3;
-            tmp11 = tmp1 + tmp2;
-            tmp12 = tmp1 - tmp2;
-
-            d0 = tmp10 + tmp11;
-            d4 = tmp10 - tmp11;
-
-            z1 = MULTIPLY16H((tmp12 + tmp13) <<2, FIX_0_707106781);
-            d2 = tmp13 + z1;
-            d6 = tmp13 - z1;
-
-            // Even part of IDCT
-
-            THRESHOLD(tmp0, d0, threshold[0*8]);
-            THRESHOLD(tmp1, d2, threshold[2*8]);
-            THRESHOLD(tmp2, d4, threshold[4*8]);
-            THRESHOLD(tmp3, d6, threshold[6*8]);
-            tmp0+=2;
-            tmp10 = (tmp0 + tmp2)>>2;
-            tmp11 = (tmp0 - tmp2)>>2;
-
-            tmp13 = (tmp1 + tmp3)>>2; //+2 !  (psnr decides)
-            tmp12 = MULTIPLY16H((tmp1 - tmp3), FIX_1_414213562_A) - tmp13; //<<2
-
-            tmp0 = tmp10 + tmp13; //->temps
-            tmp3 = tmp10 - tmp13; //->temps
-            tmp1 = tmp11 + tmp12; //->temps
-            tmp2 = tmp11 - tmp12; //->temps
-
-            // Odd part of FDCT
-
-            tmp10 = tmp4 + tmp5;
-            tmp11 = tmp5 + tmp6;
-            tmp12 = tmp6 + tmp7;
-
-            z5 = MULTIPLY16H((tmp10 - tmp12)<<2, FIX_0_382683433);
-            z2 = MULTIPLY16H(tmp10 <<2, FIX_0_541196100) + z5;
-            z4 = MULTIPLY16H(tmp12 <<2, FIX_1_306562965) + z5;
-            z3 = MULTIPLY16H(tmp11 <<2, FIX_0_707106781);
-
-            z11 = tmp7 + z3;
-            z13 = tmp7 - z3;
-
-            d5 = z13 + z2;
-            d3 = z13 - z2;
-            d1 = z11 + z4;
-            d7 = z11 - z4;
-
-            // Odd part of IDCT
-
-            THRESHOLD(tmp4, d1, threshold[1*8]);
-            THRESHOLD(tmp5, d3, threshold[3*8]);
-            THRESHOLD(tmp6, d5, threshold[5*8]);
-            THRESHOLD(tmp7, d7, threshold[7*8]);
-
-            //Simd version uses here a shortcut for the tmp5,tmp6,tmp7 == 0
-            z13 = tmp6 + tmp5;
-            z10 = (tmp6 - tmp5)<<1;
-            z11 = tmp4 + tmp7;
-            z12 = (tmp4 - tmp7)<<1;
-
-            tmp7 = (z11 + z13)>>2; //+2 !
-            tmp11 = MULTIPLY16H((z11 - z13)<<1, FIX_1_414213562);
-            z5 =    MULTIPLY16H(z10 + z12, FIX_1_847759065);
-            tmp10 = MULTIPLY16H(z12, FIX_1_082392200) - z5;
-            tmp12 = MULTIPLY16H(z10, FIX_2_613125930) + z5; // - !!
-
-            tmp6 = tmp12 - tmp7;
-            tmp5 = tmp11 - tmp6;
-            tmp4 = tmp10 + tmp5;
-
-            wsptr[DCTSIZE*0]+=  (tmp0 + tmp7);
-            wsptr[DCTSIZE*1]+=  (tmp1 + tmp6);
-            wsptr[DCTSIZE*2]+=  (tmp2 + tmp5);
-            wsptr[DCTSIZE*3]+=  (tmp3 - tmp4);
-            wsptr[DCTSIZE*4]+=  (tmp3 + tmp4);
-            wsptr[DCTSIZE*5]+=  (tmp2 - tmp5);
-            wsptr[DCTSIZE*6]=  (tmp1 - tmp6);
-            wsptr[DCTSIZE*7]=  (tmp0 - tmp7);
-            //
-            dataptr++; //next column
-            wsptr++;
-            threshold++;
-        }
-        dataptr+=8; //skip each second start pos
-        wsptr  +=8;
-    }
-}
-
-#else /* HAVE_MMX */
-
-static void column_fidct_mmx(int16_t* thr_adr,  int16_t *data,  int16_t *output,  int cnt)
-{
-    uint64_t __attribute__((aligned(8))) temps[4];
-    __asm__ volatile(
-        ASMALIGN(4)
-        "1:                   \n\t"
-        "movq "DCTSIZE_S"*0*2(%%"REG_S"), %%mm1 \n\t"
-        //
-        "movq "DCTSIZE_S"*3*2(%%"REG_S"), %%mm7 \n\t"
-        "movq %%mm1, %%mm0             \n\t"
-
-        "paddw "DCTSIZE_S"*7*2(%%"REG_S"), %%mm1 \n\t" //t0
-        "movq %%mm7, %%mm3             \n\t"
-
-        "paddw "DCTSIZE_S"*4*2(%%"REG_S"), %%mm7 \n\t" //t3
-        "movq %%mm1, %%mm5             \n\t"
-
-        "movq "DCTSIZE_S"*1*2(%%"REG_S"), %%mm6 \n\t"
-        "psubw %%mm7, %%mm1            \n\t" //t13
-
-        "movq "DCTSIZE_S"*2*2(%%"REG_S"), %%mm2 \n\t"
-        "movq %%mm6, %%mm4             \n\t"
-
-        "paddw "DCTSIZE_S"*6*2(%%"REG_S"), %%mm6 \n\t" //t1
-        "paddw %%mm7, %%mm5            \n\t" //t10
-
-        "paddw "DCTSIZE_S"*5*2(%%"REG_S"), %%mm2 \n\t" //t2
-        "movq %%mm6, %%mm7             \n\t"
-
-        "paddw %%mm2, %%mm6            \n\t" //t11
-        "psubw %%mm2, %%mm7            \n\t" //t12
-
-        "movq %%mm5, %%mm2             \n\t"
-        "paddw %%mm6, %%mm5            \n\t" //d0
-        // i0 t13 t12 i3 i1 d0 - d4
-        "psubw %%mm6, %%mm2            \n\t" //d4
-        "paddw %%mm1, %%mm7            \n\t"
-
-        "movq  4*16(%%"REG_d"), %%mm6      \n\t"
-        "psllw $2, %%mm7              \n\t"
-
-        "psubw 0*16(%%"REG_d"), %%mm5      \n\t"
-        "psubw %%mm6, %%mm2            \n\t"
-
-        "paddusw 0*16(%%"REG_d"), %%mm5    \n\t"
-        "paddusw %%mm6, %%mm2          \n\t"
-
-        "pmulhw "MANGLE(ff_MM_FIX_0_707106781)", %%mm7 \n\t"
-        //
-        "paddw 0*16(%%"REG_d"), %%mm5      \n\t"
-        "paddw %%mm6, %%mm2            \n\t"
-
-        "psubusw 0*16(%%"REG_d"), %%mm5    \n\t"
-        "psubusw %%mm6, %%mm2          \n\t"
-
-//This func is totally compute-bound,  operates at huge speed. So,  DC shortcut
-// at this place isn't worthwhile due to BTB miss penalty (checked on Pent. 3).
-//However,  typical numbers: nondc - 29%%,  dc - 46%%,  zero - 25%%. All <> 0 case is very rare.
-        "paddw "MANGLE(MM_2)", %%mm5            \n\t"
-        "movq %%mm2, %%mm6             \n\t"
-
-        "paddw %%mm5, %%mm2            \n\t"
-        "psubw %%mm6, %%mm5            \n\t"
-
-        "movq %%mm1, %%mm6             \n\t"
-        "paddw %%mm7, %%mm1            \n\t" //d2
-
-        "psubw 2*16(%%"REG_d"), %%mm1      \n\t"
-        "psubw %%mm7, %%mm6            \n\t" //d6
-
-        "movq 6*16(%%"REG_d"), %%mm7       \n\t"
-        "psraw $2, %%mm5              \n\t"
-
-        "paddusw 2*16(%%"REG_d"), %%mm1    \n\t"
-        "psubw %%mm7, %%mm6            \n\t"
-        // t7 d2 /t11 t4 t6 - d6 /t10
-
-        "paddw 2*16(%%"REG_d"), %%mm1      \n\t"
-        "paddusw %%mm7, %%mm6          \n\t"
-
-        "psubusw 2*16(%%"REG_d"), %%mm1    \n\t"
-        "paddw %%mm7, %%mm6            \n\t"
-
-        "psubw "DCTSIZE_S"*4*2(%%"REG_S"), %%mm3 \n\t"
-        "psubusw %%mm7, %%mm6          \n\t"
-
-        //movq [edi+"DCTSIZE_S"*2*2], mm1
-        //movq [edi+"DCTSIZE_S"*6*2], mm6
-        "movq %%mm1, %%mm7             \n\t"
-        "psraw $2, %%mm2              \n\t"
-
-        "psubw "DCTSIZE_S"*6*2(%%"REG_S"), %%mm4 \n\t"
-        "psubw %%mm6, %%mm1            \n\t"
-
-        "psubw "DCTSIZE_S"*7*2(%%"REG_S"), %%mm0 \n\t"
-        "paddw %%mm7, %%mm6            \n\t" //'t13
-
-        "psraw $2, %%mm6              \n\t" //paddw mm6, MM_2 !!    ---
-        "movq %%mm2, %%mm7             \n\t"
-
-        "pmulhw "MANGLE(MM_FIX_1_414213562_A)", %%mm1 \n\t"
-        "paddw %%mm6, %%mm2            \n\t" //'t0
-
-        "movq %%mm2, 0*8+%3            \n\t" //!
-        "psubw %%mm6, %%mm7            \n\t" //'t3
-
-        "movq "DCTSIZE_S"*2*2(%%"REG_S"), %%mm2 \n\t"
-        "psubw %%mm6, %%mm1            \n\t" //'t12
-
-        "psubw "DCTSIZE_S"*5*2(%%"REG_S"), %%mm2 \n\t" //t5
-        "movq %%mm5, %%mm6             \n\t"
-
-        "movq %%mm7, 3*8+%3            \n\t"
-        "paddw %%mm2, %%mm3            \n\t" //t10
-
-        "paddw %%mm4, %%mm2            \n\t" //t11
-        "paddw %%mm0, %%mm4            \n\t" //t12
-
-        "movq %%mm3, %%mm7             \n\t"
-        "psubw %%mm4, %%mm3            \n\t"
-
-        "psllw $2, %%mm3              \n\t"
-        "psllw $2, %%mm7              \n\t" //opt for P6
-
-        "pmulhw "MANGLE(MM_FIX_0_382683433)", %%mm3 \n\t"
-        "psllw $2, %%mm4              \n\t"
-
-        "pmulhw "MANGLE(ff_MM_FIX_0_541196100)", %%mm7 \n\t"
-        "psllw $2, %%mm2              \n\t"
-
-        "pmulhw "MANGLE(MM_FIX_1_306562965)", %%mm4 \n\t"
-        "paddw %%mm1, %%mm5            \n\t" //'t1
-
-        "pmulhw "MANGLE(ff_MM_FIX_0_707106781)", %%mm2 \n\t"
-        "psubw %%mm1, %%mm6            \n\t" //'t2
-        // t7 't12 't11 t4 t6 - 't13 't10   ---
-
-        "paddw %%mm3, %%mm7            \n\t" //z2
-
-        "movq %%mm5, 1*8+%3            \n\t"
-        "paddw %%mm3, %%mm4            \n\t" //z4
-
-        "movq 3*16(%%"REG_d"), %%mm3       \n\t"
-        "movq %%mm0, %%mm1             \n\t"
-
-        "movq %%mm6, 2*8+%3            \n\t"
-        "psubw %%mm2, %%mm1            \n\t" //z13
-
-//===
-        "paddw %%mm2, %%mm0            \n\t" //z11
-        "movq %%mm1, %%mm5             \n\t"
-
-        "movq 5*16(%%"REG_d"), %%mm2       \n\t"
-        "psubw %%mm7, %%mm1            \n\t" //d3
-
-        "paddw %%mm7, %%mm5            \n\t" //d5
-        "psubw %%mm3, %%mm1            \n\t"
-
-        "movq 1*16(%%"REG_d"), %%mm7       \n\t"
-        "psubw %%mm2, %%mm5            \n\t"
-
-        "movq %%mm0, %%mm6             \n\t"
-        "paddw %%mm4, %%mm0            \n\t" //d1
-
-        "paddusw %%mm3, %%mm1          \n\t"
-        "psubw %%mm4, %%mm6            \n\t" //d7
-
-        // d1 d3 - - - d5 d7 -
-        "movq 7*16(%%"REG_d"), %%mm4       \n\t"
-        "psubw %%mm7, %%mm0            \n\t"
-
-        "psubw %%mm4, %%mm6            \n\t"
-        "paddusw %%mm2, %%mm5          \n\t"
-
-        "paddusw %%mm4, %%mm6          \n\t"
-        "paddw %%mm3, %%mm1            \n\t"
-
-        "paddw %%mm2, %%mm5            \n\t"
-        "paddw %%mm4, %%mm6            \n\t"
-
-        "psubusw %%mm3, %%mm1          \n\t"
-        "psubusw %%mm2, %%mm5          \n\t"
-
-        "psubusw %%mm4, %%mm6          \n\t"
-        "movq %%mm1, %%mm4             \n\t"
-
-        "por %%mm5, %%mm4              \n\t"
-        "paddusw %%mm7, %%mm0          \n\t"
-
-        "por %%mm6, %%mm4              \n\t"
-        "paddw %%mm7, %%mm0            \n\t"
-
-        "packssdw %%mm4, %%mm4         \n\t"
-        "psubusw %%mm7, %%mm0          \n\t"
-
-        "movd %%mm4, %%"REG_a"             \n\t"
-        "or %%"REG_a", %%"REG_a"              \n\t"
-        "jnz 2f                 \n\t"
-        //movq [edi+"DCTSIZE_S"*3*2], mm1
-        //movq [edi+"DCTSIZE_S"*5*2], mm5
-        //movq [edi+"DCTSIZE_S"*1*2], mm0
-        //movq [edi+"DCTSIZE_S"*7*2], mm6
-        // t4 t5 - - - t6 t7 -
-        //--- t4 (mm0) may be <>0; mm1, mm5, mm6 == 0
-//Typical numbers: nondc - 19%%,  dc - 26%%,  zero - 55%%. zero case alone isn't worthwhile
-        "movq 0*8+%3, %%mm4            \n\t"
-        "movq %%mm0, %%mm1             \n\t"
-
-        "pmulhw "MANGLE(MM_FIX_0_847759065)", %%mm0 \n\t" //tmp6
-        "movq %%mm1, %%mm2             \n\t"
-
-        "movq "DCTSIZE_S"*0*2(%%"REG_D"), %%mm5 \n\t"
-        "movq %%mm2, %%mm3             \n\t"
-
-        "pmulhw "MANGLE(MM_FIX_0_566454497)", %%mm1 \n\t" //tmp5
-        "paddw %%mm4, %%mm5            \n\t"
-
-        "movq 1*8+%3, %%mm6            \n\t"
-        //paddw mm3, MM_2
-        "psraw $2, %%mm3              \n\t" //tmp7
-
-        "pmulhw "MANGLE(MM_FIX_0_198912367)", %%mm2 \n\t" //-tmp4
-        "psubw %%mm3, %%mm4            \n\t"
-
-        "movq "DCTSIZE_S"*1*2(%%"REG_D"), %%mm7 \n\t"
-        "paddw %%mm3, %%mm5            \n\t"
-
-        "movq %%mm4, "DCTSIZE_S"*7*2(%%"REG_D") \n\t"
-        "paddw %%mm6, %%mm7            \n\t"
-
-        "movq 2*8+%3, %%mm3            \n\t"
-        "psubw %%mm0, %%mm6            \n\t"
-
-        "movq "DCTSIZE_S"*2*2(%%"REG_D"), %%mm4 \n\t"
-        "paddw %%mm0, %%mm7            \n\t"
-
-        "movq %%mm5, "DCTSIZE_S"*0*2(%%"REG_D") \n\t"
-        "paddw %%mm3, %%mm4            \n\t"
-
-        "movq %%mm6, "DCTSIZE_S"*6*2(%%"REG_D") \n\t"
-        "psubw %%mm1, %%mm3            \n\t"
-
-        "movq "DCTSIZE_S"*5*2(%%"REG_D"), %%mm5 \n\t"
-        "paddw %%mm1, %%mm4            \n\t"
-
-        "movq "DCTSIZE_S"*3*2(%%"REG_D"), %%mm6 \n\t"
-        "paddw %%mm3, %%mm5            \n\t"
-
-        "movq 3*8+%3, %%mm0            \n\t"
-        "add $8, %%"REG_S"               \n\t"
-
-        "movq %%mm7, "DCTSIZE_S"*1*2(%%"REG_D") \n\t"
-        "paddw %%mm0, %%mm6            \n\t"
-
-        "movq %%mm4, "DCTSIZE_S"*2*2(%%"REG_D") \n\t"
-        "psubw %%mm2, %%mm0            \n\t"
-
-        "movq "DCTSIZE_S"*4*2(%%"REG_D"), %%mm7 \n\t"
-        "paddw %%mm2, %%mm6            \n\t"
-
-        "movq %%mm5, "DCTSIZE_S"*5*2(%%"REG_D") \n\t"
-        "paddw %%mm0, %%mm7            \n\t"
-
-        "movq %%mm6, "DCTSIZE_S"*3*2(%%"REG_D") \n\t"
-
-        "movq %%mm7, "DCTSIZE_S"*4*2(%%"REG_D") \n\t"
-        "add $8, %%"REG_D"               \n\t"
-        "jmp 4f                  \n\t"
-
-        "2:                    \n\t"
-        //--- non DC2
-        //psraw mm1, 2 w/o it -> offset. thr1, thr1, thr1  (actually thr1, thr1, thr1-1)
-        //psraw mm5, 2
-        //psraw mm0, 2
-        //psraw mm6, 2
-        "movq %%mm5, %%mm3             \n\t"
-        "psubw %%mm1, %%mm5            \n\t"
-
-        "psllw $1, %%mm5              \n\t" //'z10
-        "paddw %%mm1, %%mm3            \n\t" //'z13
-
-        "movq %%mm0, %%mm2             \n\t"
-        "psubw %%mm6, %%mm0            \n\t"
-
-        "movq %%mm5, %%mm1             \n\t"
-        "psllw $1, %%mm0              \n\t" //'z12
-
-        "pmulhw "MANGLE(MM_FIX_2_613125930)", %%mm1 \n\t" //-
-        "paddw %%mm0, %%mm5            \n\t"
-
-        "pmulhw "MANGLE(MM_FIX_1_847759065)", %%mm5 \n\t" //'z5
-        "paddw %%mm6, %%mm2            \n\t" //'z11
-
-        "pmulhw "MANGLE(MM_FIX_1_082392200)", %%mm0 \n\t"
-        "movq %%mm2, %%mm7             \n\t"
-
-        //---
-        "movq 0*8+%3, %%mm4            \n\t"
-        "psubw %%mm3, %%mm2            \n\t"
-
-        "psllw $1, %%mm2              \n\t"
-        "paddw %%mm3, %%mm7            \n\t" //'t7
-
-        "pmulhw "MANGLE(MM_FIX_1_414213562)", %%mm2 \n\t" //'t11
-        "movq %%mm4, %%mm6             \n\t"
-        //paddw mm7, MM_2
-        "psraw $2, %%mm7              \n\t"
-
-        "paddw "DCTSIZE_S"*0*2(%%"REG_D"), %%mm4 \n\t"
-        "psubw %%mm7, %%mm6            \n\t"
-
-        "movq 1*8+%3, %%mm3            \n\t"
-        "paddw %%mm7, %%mm4            \n\t"
-
-        "movq %%mm6, "DCTSIZE_S"*7*2(%%"REG_D") \n\t"
-        "paddw %%mm5, %%mm1            \n\t" //'t12
-
-        "movq %%mm4, "DCTSIZE_S"*0*2(%%"REG_D") \n\t"
-        "psubw %%mm7, %%mm1            \n\t" //'t6
-
-        "movq 2*8+%3, %%mm7            \n\t"
-        "psubw %%mm5, %%mm0            \n\t" //'t10
-
-        "movq 3*8+%3, %%mm6            \n\t"
-        "movq %%mm3, %%mm5             \n\t"
-
-        "paddw "DCTSIZE_S"*1*2(%%"REG_D"), %%mm3 \n\t"
-        "psubw %%mm1, %%mm5            \n\t"
-
-        "psubw %%mm1, %%mm2            \n\t" //'t5
-        "paddw %%mm1, %%mm3            \n\t"
-
-        "movq %%mm5, "DCTSIZE_S"*6*2(%%"REG_D") \n\t"
-        "movq %%mm7, %%mm4             \n\t"
-
-        "paddw "DCTSIZE_S"*2*2(%%"REG_D"), %%mm7 \n\t"
-        "psubw %%mm2, %%mm4            \n\t"
-
-        "paddw "DCTSIZE_S"*5*2(%%"REG_D"), %%mm4 \n\t"
-        "paddw %%mm2, %%mm7            \n\t"
-
-        "movq %%mm3, "DCTSIZE_S"*1*2(%%"REG_D") \n\t"
-        "paddw %%mm2, %%mm0            \n\t" //'t4
-
-        // 't4 't6 't5 - - - - 't7
-        "movq %%mm7, "DCTSIZE_S"*2*2(%%"REG_D") \n\t"
-        "movq %%mm6, %%mm1             \n\t"
-
-        "paddw "DCTSIZE_S"*4*2(%%"REG_D"), %%mm6 \n\t"
-        "psubw %%mm0, %%mm1            \n\t"
-
-        "paddw "DCTSIZE_S"*3*2(%%"REG_D"), %%mm1 \n\t"
-        "paddw %%mm0, %%mm6            \n\t"
-
-        "movq %%mm4, "DCTSIZE_S"*5*2(%%"REG_D") \n\t"
-        "add $8, %%"REG_S"               \n\t"
-
-        "movq %%mm6, "DCTSIZE_S"*4*2(%%"REG_D") \n\t"
-
-        "movq %%mm1, "DCTSIZE_S"*3*2(%%"REG_D") \n\t"
-        "add $8, %%"REG_D"               \n\t"
-
-        "4:                     \n\t"
-//=part 2 (the same)===========================================================
-        "movq "DCTSIZE_S"*0*2(%%"REG_S"), %%mm1 \n\t"
-        //
-        "movq "DCTSIZE_S"*3*2(%%"REG_S"), %%mm7 \n\t"
-        "movq %%mm1, %%mm0             \n\t"
-
-        "paddw "DCTSIZE_S"*7*2(%%"REG_S"), %%mm1 \n\t" //t0
-        "movq %%mm7, %%mm3             \n\t"
-
-        "paddw "DCTSIZE_S"*4*2(%%"REG_S"), %%mm7 \n\t" //t3
-        "movq %%mm1, %%mm5             \n\t"
-
-        "movq "DCTSIZE_S"*1*2(%%"REG_S"), %%mm6 \n\t"
-        "psubw %%mm7, %%mm1            \n\t" //t13
-
-        "movq "DCTSIZE_S"*2*2(%%"REG_S"), %%mm2 \n\t"
-        "movq %%mm6, %%mm4             \n\t"
-
-        "paddw "DCTSIZE_S"*6*2(%%"REG_S"), %%mm6 \n\t" //t1
-        "paddw %%mm7, %%mm5            \n\t" //t10
-
-        "paddw "DCTSIZE_S"*5*2(%%"REG_S"), %%mm2 \n\t" //t2
-        "movq %%mm6, %%mm7             \n\t"
-
-        "paddw %%mm2, %%mm6            \n\t" //t11
-        "psubw %%mm2, %%mm7            \n\t" //t12
-
-        "movq %%mm5, %%mm2             \n\t"
-        "paddw %%mm6, %%mm5            \n\t" //d0
-        // i0 t13 t12 i3 i1 d0 - d4
-        "psubw %%mm6, %%mm2            \n\t" //d4
-        "paddw %%mm1, %%mm7            \n\t"
-
-        "movq  1*8+4*16(%%"REG_d"), %%mm6  \n\t"
-        "psllw $2, %%mm7              \n\t"
-
-        "psubw 1*8+0*16(%%"REG_d"), %%mm5  \n\t"
-        "psubw %%mm6, %%mm2            \n\t"
-
-        "paddusw 1*8+0*16(%%"REG_d"), %%mm5 \n\t"
-        "paddusw %%mm6, %%mm2          \n\t"
-
-        "pmulhw "MANGLE(ff_MM_FIX_0_707106781)", %%mm7 \n\t"
-        //
-        "paddw 1*8+0*16(%%"REG_d"), %%mm5  \n\t"
-        "paddw %%mm6, %%mm2            \n\t"
-
-        "psubusw 1*8+0*16(%%"REG_d"), %%mm5 \n\t"
-        "psubusw %%mm6, %%mm2          \n\t"
-
-//This func is totally compute-bound,  operates at huge speed. So,  DC shortcut
-// at this place isn't worthwhile due to BTB miss penalty (checked on Pent. 3).
-//However,  typical numbers: nondc - 29%%,  dc - 46%%,  zero - 25%%. All <> 0 case is very rare.
-        "paddw "MANGLE(MM_2)", %%mm5            \n\t"
-        "movq %%mm2, %%mm6             \n\t"
-
-        "paddw %%mm5, %%mm2            \n\t"
-        "psubw %%mm6, %%mm5            \n\t"
-
-        "movq %%mm1, %%mm6             \n\t"
-        "paddw %%mm7, %%mm1            \n\t" //d2
-
-        "psubw 1*8+2*16(%%"REG_d"), %%mm1  \n\t"
-        "psubw %%mm7, %%mm6            \n\t" //d6
-
-        "movq 1*8+6*16(%%"REG_d"), %%mm7   \n\t"
-        "psraw $2, %%mm5              \n\t"
-
-        "paddusw 1*8+2*16(%%"REG_d"), %%mm1 \n\t"
-        "psubw %%mm7, %%mm6            \n\t"
-        // t7 d2 /t11 t4 t6 - d6 /t10
-
-        "paddw 1*8+2*16(%%"REG_d"), %%mm1  \n\t"
-        "paddusw %%mm7, %%mm6          \n\t"
-
-        "psubusw 1*8+2*16(%%"REG_d"), %%mm1 \n\t"
-        "paddw %%mm7, %%mm6            \n\t"
-
-        "psubw "DCTSIZE_S"*4*2(%%"REG_S"), %%mm3 \n\t"
-        "psubusw %%mm7, %%mm6          \n\t"
-
-        //movq [edi+"DCTSIZE_S"*2*2], mm1
-        //movq [edi+"DCTSIZE_S"*6*2], mm6
-        "movq %%mm1, %%mm7             \n\t"
-        "psraw $2, %%mm2              \n\t"
-
-        "psubw "DCTSIZE_S"*6*2(%%"REG_S"), %%mm4 \n\t"
-        "psubw %%mm6, %%mm1            \n\t"
-
-        "psubw "DCTSIZE_S"*7*2(%%"REG_S"), %%mm0 \n\t"
-        "paddw %%mm7, %%mm6            \n\t" //'t13
-
-        "psraw $2, %%mm6              \n\t" //paddw mm6, MM_2 !!    ---
-        "movq %%mm2, %%mm7             \n\t"
-
-        "pmulhw "MANGLE(MM_FIX_1_414213562_A)", %%mm1 \n\t"
-        "paddw %%mm6, %%mm2            \n\t" //'t0
-
-        "movq %%mm2, 0*8+%3            \n\t" //!
-        "psubw %%mm6, %%mm7            \n\t" //'t3
-
-        "movq "DCTSIZE_S"*2*2(%%"REG_S"), %%mm2 \n\t"
-        "psubw %%mm6, %%mm1            \n\t" //'t12
-
-        "psubw "DCTSIZE_S"*5*2(%%"REG_S"), %%mm2 \n\t" //t5
-        "movq %%mm5, %%mm6             \n\t"
-
-        "movq %%mm7, 3*8+%3            \n\t"
-        "paddw %%mm2, %%mm3            \n\t" //t10
-
-        "paddw %%mm4, %%mm2            \n\t" //t11
-        "paddw %%mm0, %%mm4            \n\t" //t12
-
-        "movq %%mm3, %%mm7             \n\t"
-        "psubw %%mm4, %%mm3            \n\t"
-
-        "psllw $2, %%mm3              \n\t"
-        "psllw $2, %%mm7              \n\t" //opt for P6
-
-        "pmulhw "MANGLE(MM_FIX_0_382683433)", %%mm3 \n\t"
-        "psllw $2, %%mm4              \n\t"
-
-        "pmulhw "MANGLE(ff_MM_FIX_0_541196100)", %%mm7 \n\t"
-        "psllw $2, %%mm2              \n\t"
-
-        "pmulhw "MANGLE(MM_FIX_1_306562965)", %%mm4 \n\t"
-        "paddw %%mm1, %%mm5            \n\t" //'t1
-
-        "pmulhw "MANGLE(ff_MM_FIX_0_707106781)", %%mm2 \n\t"
-        "psubw %%mm1, %%mm6            \n\t" //'t2
-        // t7 't12 't11 t4 t6 - 't13 't10   ---
-
-        "paddw %%mm3, %%mm7            \n\t" //z2
-
-        "movq %%mm5, 1*8+%3            \n\t"
-        "paddw %%mm3, %%mm4            \n\t" //z4
-
-        "movq 1*8+3*16(%%"REG_d"), %%mm3   \n\t"
-        "movq %%mm0, %%mm1             \n\t"
-
-        "movq %%mm6, 2*8+%3            \n\t"
-        "psubw %%mm2, %%mm1            \n\t" //z13
-
-//===
-        "paddw %%mm2, %%mm0            \n\t" //z11
-        "movq %%mm1, %%mm5             \n\t"
-
-        "movq 1*8+5*16(%%"REG_d"), %%mm2   \n\t"
-        "psubw %%mm7, %%mm1            \n\t" //d3
-
-        "paddw %%mm7, %%mm5            \n\t" //d5
-        "psubw %%mm3, %%mm1            \n\t"
-
-        "movq 1*8+1*16(%%"REG_d"), %%mm7   \n\t"
-        "psubw %%mm2, %%mm5            \n\t"
-
-        "movq %%mm0, %%mm6             \n\t"
-        "paddw %%mm4, %%mm0            \n\t" //d1
-
-        "paddusw %%mm3, %%mm1          \n\t"
-        "psubw %%mm4, %%mm6            \n\t" //d7
-
-        // d1 d3 - - - d5 d7 -
-        "movq 1*8+7*16(%%"REG_d"), %%mm4   \n\t"
-        "psubw %%mm7, %%mm0            \n\t"
-
-        "psubw %%mm4, %%mm6            \n\t"
-        "paddusw %%mm2, %%mm5          \n\t"
-
-        "paddusw %%mm4, %%mm6          \n\t"
-        "paddw %%mm3, %%mm1            \n\t"
-
-        "paddw %%mm2, %%mm5            \n\t"
-        "paddw %%mm4, %%mm6            \n\t"
-
-        "psubusw %%mm3, %%mm1          \n\t"
-        "psubusw %%mm2, %%mm5          \n\t"
-
-        "psubusw %%mm4, %%mm6          \n\t"
-        "movq %%mm1, %%mm4             \n\t"
-
-        "por %%mm5, %%mm4              \n\t"
-        "paddusw %%mm7, %%mm0          \n\t"
-
-        "por %%mm6, %%mm4              \n\t"
-        "paddw %%mm7, %%mm0            \n\t"
-
-        "packssdw %%mm4, %%mm4         \n\t"
-        "psubusw %%mm7, %%mm0          \n\t"
-
-        "movd %%mm4, %%"REG_a"             \n\t"
-        "or %%"REG_a", %%"REG_a"              \n\t"
-        "jnz 3f                 \n\t"
-        //movq [edi+"DCTSIZE_S"*3*2], mm1
-        //movq [edi+"DCTSIZE_S"*5*2], mm5
-        //movq [edi+"DCTSIZE_S"*1*2], mm0
-        //movq [edi+"DCTSIZE_S"*7*2], mm6
-        // t4 t5 - - - t6 t7 -
-        //--- t4 (mm0) may be <>0; mm1, mm5, mm6 == 0
-//Typical numbers: nondc - 19%%,  dc - 26%%,  zero - 55%%. zero case alone isn't worthwhile
-        "movq 0*8+%3, %%mm4            \n\t"
-        "movq %%mm0, %%mm1             \n\t"
-
-        "pmulhw "MANGLE(MM_FIX_0_847759065)", %%mm0 \n\t" //tmp6
-        "movq %%mm1, %%mm2             \n\t"
-
-        "movq "DCTSIZE_S"*0*2(%%"REG_D"), %%mm5 \n\t"
-        "movq %%mm2, %%mm3             \n\t"
-
-        "pmulhw "MANGLE(MM_FIX_0_566454497)", %%mm1 \n\t" //tmp5
-        "paddw %%mm4, %%mm5            \n\t"
-
-        "movq 1*8+%3, %%mm6            \n\t"
-        //paddw mm3, MM_2
-        "psraw $2, %%mm3              \n\t" //tmp7
-
-        "pmulhw "MANGLE(MM_FIX_0_198912367)", %%mm2 \n\t" //-tmp4
-        "psubw %%mm3, %%mm4            \n\t"
-
-        "movq "DCTSIZE_S"*1*2(%%"REG_D"), %%mm7 \n\t"
-        "paddw %%mm3, %%mm5            \n\t"
-
-        "movq %%mm4, "DCTSIZE_S"*7*2(%%"REG_D") \n\t"
-        "paddw %%mm6, %%mm7            \n\t"
-
-        "movq 2*8+%3, %%mm3            \n\t"
-        "psubw %%mm0, %%mm6            \n\t"
-
-        "movq "DCTSIZE_S"*2*2(%%"REG_D"), %%mm4 \n\t"
-        "paddw %%mm0, %%mm7            \n\t"
-
-        "movq %%mm5, "DCTSIZE_S"*0*2(%%"REG_D") \n\t"
-        "paddw %%mm3, %%mm4            \n\t"
-
-        "movq %%mm6, "DCTSIZE_S"*6*2(%%"REG_D") \n\t"
-        "psubw %%mm1, %%mm3            \n\t"
-
-        "movq "DCTSIZE_S"*5*2(%%"REG_D"), %%mm5 \n\t"
-        "paddw %%mm1, %%mm4            \n\t"
-
-        "movq "DCTSIZE_S"*3*2(%%"REG_D"), %%mm6 \n\t"
-        "paddw %%mm3, %%mm5            \n\t"
-
-        "movq 3*8+%3, %%mm0            \n\t"
-        "add $24, %%"REG_S"              \n\t"
-
-        "movq %%mm7, "DCTSIZE_S"*1*2(%%"REG_D") \n\t"
-        "paddw %%mm0, %%mm6            \n\t"
-
-        "movq %%mm4, "DCTSIZE_S"*2*2(%%"REG_D") \n\t"
-        "psubw %%mm2, %%mm0            \n\t"
-
-        "movq "DCTSIZE_S"*4*2(%%"REG_D"), %%mm7 \n\t"
-        "paddw %%mm2, %%mm6            \n\t"
-
-        "movq %%mm5, "DCTSIZE_S"*5*2(%%"REG_D") \n\t"
-        "paddw %%mm0, %%mm7            \n\t"
-
-        "movq %%mm6, "DCTSIZE_S"*3*2(%%"REG_D") \n\t"
-
-        "movq %%mm7, "DCTSIZE_S"*4*2(%%"REG_D") \n\t"
-        "add $24, %%"REG_D"              \n\t"
-        "sub $2, %%"REG_c"               \n\t"
-        "jnz 1b                \n\t"
-        "jmp 5f                   \n\t"
-
-        "3:                    \n\t"
-        //--- non DC2
-        //psraw mm1, 2 w/o it -> offset. thr1, thr1, thr1  (actually thr1, thr1, thr1-1)
-        //psraw mm5, 2
-        //psraw mm0, 2
-        //psraw mm6, 2
-        "movq %%mm5, %%mm3             \n\t"
-        "psubw %%mm1, %%mm5            \n\t"
-
-        "psllw $1, %%mm5              \n\t" //'z10
-        "paddw %%mm1, %%mm3            \n\t" //'z13
-
-        "movq %%mm0, %%mm2             \n\t"
-        "psubw %%mm6, %%mm0            \n\t"
-
-        "movq %%mm5, %%mm1             \n\t"
-        "psllw $1, %%mm0              \n\t" //'z12
-
-        "pmulhw "MANGLE(MM_FIX_2_613125930)", %%mm1 \n\t" //-
-        "paddw %%mm0, %%mm5            \n\t"
-
-        "pmulhw "MANGLE(MM_FIX_1_847759065)", %%mm5 \n\t" //'z5
-        "paddw %%mm6, %%mm2            \n\t" //'z11
-
-        "pmulhw "MANGLE(MM_FIX_1_082392200)", %%mm0 \n\t"
-        "movq %%mm2, %%mm7             \n\t"
-
-        //---
-        "movq 0*8+%3, %%mm4            \n\t"
-        "psubw %%mm3, %%mm2            \n\t"
-
-        "psllw $1, %%mm2              \n\t"
-        "paddw %%mm3, %%mm7            \n\t" //'t7
-
-        "pmulhw "MANGLE(MM_FIX_1_414213562)", %%mm2 \n\t" //'t11
-        "movq %%mm4, %%mm6             \n\t"
-        //paddw mm7, MM_2
-        "psraw $2, %%mm7              \n\t"
-
-        "paddw "DCTSIZE_S"*0*2(%%"REG_D"), %%mm4 \n\t"
-        "psubw %%mm7, %%mm6            \n\t"
-
-        "movq 1*8+%3, %%mm3            \n\t"
-        "paddw %%mm7, %%mm4            \n\t"
-
-        "movq %%mm6, "DCTSIZE_S"*7*2(%%"REG_D") \n\t"
-        "paddw %%mm5, %%mm1            \n\t" //'t12
-
-        "movq %%mm4, "DCTSIZE_S"*0*2(%%"REG_D") \n\t"
-        "psubw %%mm7, %%mm1            \n\t" //'t6
-
-        "movq 2*8+%3, %%mm7            \n\t"
-        "psubw %%mm5, %%mm0            \n\t" //'t10
-
-        "movq 3*8+%3, %%mm6            \n\t"
-        "movq %%mm3, %%mm5             \n\t"
-
-        "paddw "DCTSIZE_S"*1*2(%%"REG_D"), %%mm3 \n\t"
-        "psubw %%mm1, %%mm5            \n\t"
-
-        "psubw %%mm1, %%mm2            \n\t" //'t5
-        "paddw %%mm1, %%mm3            \n\t"
-
-        "movq %%mm5, "DCTSIZE_S"*6*2(%%"REG_D") \n\t"
-        "movq %%mm7, %%mm4             \n\t"
-
-        "paddw "DCTSIZE_S"*2*2(%%"REG_D"), %%mm7 \n\t"
-        "psubw %%mm2, %%mm4            \n\t"
-
-        "paddw "DCTSIZE_S"*5*2(%%"REG_D"), %%mm4 \n\t"
-        "paddw %%mm2, %%mm7            \n\t"
-
-        "movq %%mm3, "DCTSIZE_S"*1*2(%%"REG_D") \n\t"
-        "paddw %%mm2, %%mm0            \n\t" //'t4
-
-        // 't4 't6 't5 - - - - 't7
-        "movq %%mm7, "DCTSIZE_S"*2*2(%%"REG_D") \n\t"
-        "movq %%mm6, %%mm1             \n\t"
-
-        "paddw "DCTSIZE_S"*4*2(%%"REG_D"), %%mm6 \n\t"
-        "psubw %%mm0, %%mm1            \n\t"
-
-        "paddw "DCTSIZE_S"*3*2(%%"REG_D"), %%mm1 \n\t"
-        "paddw %%mm0, %%mm6            \n\t"
-
-        "movq %%mm4, "DCTSIZE_S"*5*2(%%"REG_D") \n\t"
-        "add $24, %%"REG_S"              \n\t"
-
-        "movq %%mm6, "DCTSIZE_S"*4*2(%%"REG_D") \n\t"
-
-        "movq %%mm1, "DCTSIZE_S"*3*2(%%"REG_D") \n\t"
-        "add $24, %%"REG_D"              \n\t"
-        "sub $2, %%"REG_c"               \n\t"
-        "jnz 1b                \n\t"
-        "5:                      \n\t"
-
-        : "+S"(data), "+D"(output), "+c"(cnt), "=o"(temps)
-        : "d"(thr_adr)
-        : "%"REG_a
-        );
-}
-
-#endif // HAVE_MMX
-
-#if !HAVE_MMX
-
-static void row_idct_c(int16_t* workspace,
-                       int16_t* output_adr, int output_stride, int cnt)
-{
-    int_simd16_t tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
-    int_simd16_t tmp10, tmp11, tmp12, tmp13;
-    int_simd16_t z5, z10, z11, z12, z13;
-    int16_t* outptr;
-    int16_t* wsptr;
-
-    cnt*=4;
-    wsptr = workspace;
-    outptr = output_adr;
-    for (; cnt > 0; cnt--) {
-        // Even part
-        //Simd version reads 4x4 block and transposes it
-        tmp10 = ( wsptr[2] +  wsptr[3]);
-        tmp11 = ( wsptr[2] -  wsptr[3]);
-
-        tmp13 = ( wsptr[0] +  wsptr[1]);
-        tmp12 = (MULTIPLY16H( wsptr[0] - wsptr[1], FIX_1_414213562_A)<<2) - tmp13;//this shift order to avoid overflow
-
-        tmp0 = tmp10 + tmp13; //->temps
-        tmp3 = tmp10 - tmp13; //->temps
-        tmp1 = tmp11 + tmp12;
-        tmp2 = tmp11 - tmp12;
-
-        // Odd part
-        //Also transpose, with previous:
-        // ---- ----      ||||
-        // ---- ---- idct ||||
-        // ---- ---- ---> ||||
-        // ---- ----      ||||
-        z13 = wsptr[4] + wsptr[5];
-        z10 = wsptr[4] - wsptr[5];
-        z11 = wsptr[6] + wsptr[7];
-        z12 = wsptr[6] - wsptr[7];
-
-        tmp7 = z11 + z13;
-        tmp11 = MULTIPLY16H(z11 - z13, FIX_1_414213562);
-
-        z5 =    MULTIPLY16H(z10 + z12, FIX_1_847759065);
-        tmp10 = MULTIPLY16H(z12, FIX_1_082392200) - z5;
-        tmp12 = MULTIPLY16H(z10, FIX_2_613125930) + z5; // - FIX_
-
-        tmp6 = (tmp12<<3) - tmp7;
-        tmp5 = (tmp11<<3) - tmp6;
-        tmp4 = (tmp10<<3) + tmp5;
-
-        // Final output stage: descale and write column
-        outptr[0*output_stride]+= DESCALE(tmp0 + tmp7, 3);
-        outptr[1*output_stride]+= DESCALE(tmp1 + tmp6, 3);
-        outptr[2*output_stride]+= DESCALE(tmp2 + tmp5, 3);
-        outptr[3*output_stride]+= DESCALE(tmp3 - tmp4, 3);
-        outptr[4*output_stride]+= DESCALE(tmp3 + tmp4, 3);
-        outptr[5*output_stride]+= DESCALE(tmp2 - tmp5, 3);
-        outptr[6*output_stride]+= DESCALE(tmp1 - tmp6, 3); //no += ?
-        outptr[7*output_stride]+= DESCALE(tmp0 - tmp7, 3); //no += ?
-        outptr++;
-
-        wsptr += DCTSIZE;       // advance pointer to next row
-    }
-}
-
-#else /* HAVE_MMX */
-
-static void row_idct_mmx (int16_t* workspace,
-                          int16_t* output_adr,  int output_stride,  int cnt)
-{
-    uint64_t __attribute__((aligned(8))) temps[4];
-    __asm__ volatile(
-        "lea (%%"REG_a",%%"REG_a",2), %%"REG_d"    \n\t"
-        "1:                     \n\t"
-        "movq "DCTSIZE_S"*0*2(%%"REG_S"), %%mm0 \n\t"
-        //
-
-        "movq "DCTSIZE_S"*1*2(%%"REG_S"), %%mm1 \n\t"
-        "movq %%mm0, %%mm4             \n\t"
-
-        "movq "DCTSIZE_S"*2*2(%%"REG_S"), %%mm2 \n\t"
-        "punpcklwd %%mm1, %%mm0        \n\t"
-
-        "movq "DCTSIZE_S"*3*2(%%"REG_S"), %%mm3 \n\t"
-        "punpckhwd %%mm1, %%mm4        \n\t"
-
-        //transpose 4x4
-        "movq %%mm2, %%mm7             \n\t"
-        "punpcklwd %%mm3, %%mm2        \n\t"
-
-        "movq %%mm0, %%mm6             \n\t"
-        "punpckldq %%mm2, %%mm0        \n\t" //0
-
-        "punpckhdq %%mm2, %%mm6        \n\t" //1
-        "movq %%mm0, %%mm5             \n\t"
-
-        "punpckhwd %%mm3, %%mm7        \n\t"
-        "psubw %%mm6, %%mm0            \n\t"
-
-        "pmulhw "MANGLE(MM_FIX_1_414213562_A)", %%mm0 \n\t"
-        "movq %%mm4, %%mm2             \n\t"
-
-        "punpckldq %%mm7, %%mm4        \n\t" //2
-        "paddw %%mm6, %%mm5            \n\t"
-
-        "punpckhdq %%mm7, %%mm2        \n\t" //3
-        "movq %%mm4, %%mm1             \n\t"
-
-        "psllw $2, %%mm0              \n\t"
-        "paddw %%mm2, %%mm4            \n\t" //t10
-
-        "movq "DCTSIZE_S"*0*2+"DCTSIZE_S"(%%"REG_S"), %%mm3 \n\t"
-        "psubw %%mm2, %%mm1            \n\t" //t11
-
-        "movq "DCTSIZE_S"*1*2+"DCTSIZE_S"(%%"REG_S"), %%mm2 \n\t"
-        "psubw %%mm5, %%mm0            \n\t"
-
-        "movq %%mm4, %%mm6             \n\t"
-        "paddw %%mm5, %%mm4            \n\t" //t0
-
-        "psubw %%mm5, %%mm6            \n\t" //t3
-        "movq %%mm1, %%mm7             \n\t"
-
-        "movq "DCTSIZE_S"*2*2+"DCTSIZE_S"(%%"REG_S"), %%mm5 \n\t"
-        "paddw %%mm0, %%mm1            \n\t" //t1
-
-        "movq %%mm4, 0*8+%3            \n\t" //t0
-        "movq %%mm3, %%mm4             \n\t"
-
-        "movq %%mm6, 1*8+%3            \n\t" //t3
-        "punpcklwd %%mm2, %%mm3        \n\t"
-
-        //transpose 4x4
-        "movq "DCTSIZE_S"*3*2+"DCTSIZE_S"(%%"REG_S"), %%mm6 \n\t"
-        "punpckhwd %%mm2, %%mm4        \n\t"
-
-        "movq %%mm5, %%mm2             \n\t"
-        "punpcklwd %%mm6, %%mm5        \n\t"
-
-        "psubw %%mm0, %%mm7            \n\t" //t2
-        "punpckhwd %%mm6, %%mm2        \n\t"
-
-        "movq %%mm3, %%mm0             \n\t"
-        "punpckldq %%mm5, %%mm3        \n\t" //4
-
-        "punpckhdq %%mm5, %%mm0        \n\t" //5
-        "movq %%mm4, %%mm5             \n\t"
-
-        //
-        "movq %%mm3, %%mm6             \n\t"
-        "punpckldq %%mm2, %%mm4        \n\t" //6
-
-        "psubw %%mm0, %%mm3            \n\t" //z10
-        "punpckhdq %%mm2, %%mm5        \n\t" //7
-
-        "paddw %%mm0, %%mm6            \n\t" //z13
-        "movq %%mm4, %%mm2             \n\t"
-
-        "movq %%mm3, %%mm0             \n\t"
-        "psubw %%mm5, %%mm4            \n\t" //z12
-
-        "pmulhw "MANGLE(MM_FIX_2_613125930)", %%mm0 \n\t" //-
-        "paddw %%mm4, %%mm3            \n\t"
-
-        "pmulhw "MANGLE(MM_FIX_1_847759065)", %%mm3 \n\t" //z5
-        "paddw %%mm5, %%mm2            \n\t" //z11  >
-
-        "pmulhw "MANGLE(MM_FIX_1_082392200)", %%mm4 \n\t"
-        "movq %%mm2, %%mm5             \n\t"
-
-        "psubw %%mm6, %%mm2            \n\t"
-        "paddw %%mm6, %%mm5            \n\t" //t7
-
-        "pmulhw "MANGLE(MM_FIX_1_414213562)", %%mm2 \n\t" //t11
-        "paddw %%mm3, %%mm0            \n\t" //t12
-
-        "psllw $3, %%mm0              \n\t"
-        "psubw %%mm3, %%mm4            \n\t" //t10
-
-        "movq 0*8+%3, %%mm6            \n\t"
-        "movq %%mm1, %%mm3             \n\t"
-
-        "psllw $3, %%mm4              \n\t"
-        "psubw %%mm5, %%mm0            \n\t" //t6
-
-        "psllw $3, %%mm2              \n\t"
-        "paddw %%mm0, %%mm1            \n\t" //d1
-
-        "psubw %%mm0, %%mm2            \n\t" //t5
-        "psubw %%mm0, %%mm3            \n\t" //d6
-
-        "paddw %%mm2, %%mm4            \n\t" //t4
-        "movq %%mm7, %%mm0             \n\t"
-
-        "paddw %%mm2, %%mm7            \n\t" //d2
-        "psubw %%mm2, %%mm0            \n\t" //d5
-
-        "movq "MANGLE(MM_DESCALE_RND)", %%mm2   \n\t" //4
-        "psubw %%mm5, %%mm6            \n\t" //d7
-
-        "paddw 0*8+%3, %%mm5           \n\t" //d0
-        "paddw %%mm2, %%mm1            \n\t"
-
-        "paddw %%mm2, %%mm5            \n\t"
-        "psraw $3, %%mm1              \n\t"
-
-        "paddw %%mm2, %%mm7            \n\t"
-        "psraw $3, %%mm5              \n\t"
-
-        "paddw (%%"REG_D"), %%mm5          \n\t"
-        "psraw $3, %%mm7              \n\t"
-
-        "paddw (%%"REG_D",%%"REG_a",), %%mm1    \n\t"
-        "paddw %%mm2, %%mm0            \n\t"
-
-        "paddw (%%"REG_D",%%"REG_a",2), %%mm7   \n\t"
-        "paddw %%mm2, %%mm3            \n\t"
-
-        "movq %%mm5, (%%"REG_D")           \n\t"
-        "paddw %%mm2, %%mm6            \n\t"
-
-        "movq %%mm1, (%%"REG_D",%%"REG_a",)     \n\t"
-        "psraw $3, %%mm0              \n\t"
-
-        "movq %%mm7, (%%"REG_D",%%"REG_a",2)    \n\t"
-        "add %%"REG_d", %%"REG_D"             \n\t" //3*ls
-
-        "movq 1*8+%3, %%mm5           \n\t" //t3
-        "psraw $3, %%mm3              \n\t"
-
-        "paddw (%%"REG_D",%%"REG_a",2), %%mm0   \n\t"
-        "psubw %%mm4, %%mm5            \n\t" //d3
-
-        "paddw (%%"REG_D",%%"REG_d",), %%mm3    \n\t"
-        "psraw $3, %%mm6              \n\t"
-
-        "paddw 1*8+%3, %%mm4           \n\t" //d4
-        "paddw %%mm2, %%mm5            \n\t"
-
-        "paddw (%%"REG_D",%%"REG_a",4), %%mm6   \n\t"
-        "paddw %%mm2, %%mm4            \n\t"
-
-        "movq %%mm0, (%%"REG_D",%%"REG_a",2)    \n\t"
-        "psraw $3, %%mm5              \n\t"
-
-        "paddw (%%"REG_D"), %%mm5          \n\t"
-        "psraw $3, %%mm4              \n\t"
-
-        "paddw (%%"REG_D",%%"REG_a",), %%mm4    \n\t"
-        "add $"DCTSIZE_S"*2*4, %%"REG_S"      \n\t" //4 rows
-
-        "movq %%mm3, (%%"REG_D",%%"REG_d",)     \n\t"
-        "movq %%mm6, (%%"REG_D",%%"REG_a",4)    \n\t"
-        "movq %%mm5, (%%"REG_D")           \n\t"
-        "movq %%mm4, (%%"REG_D",%%"REG_a",)     \n\t"
-
-        "sub %%"REG_d", %%"REG_D"             \n\t"
-        "add $8, %%"REG_D"               \n\t"
-        "dec %%"REG_c"                   \n\t"
-        "jnz 1b                  \n\t"
-
-        : "+S"(workspace), "+D"(output_adr), "+c"(cnt), "=o"(temps)
-        : "a"(output_stride*sizeof(short))
-        : "%"REG_d
-        );
-}
-
-#endif // HAVE_MMX
-
-#if !HAVE_MMX
-
-static void row_fdct_c(int16_t *data, const uint8_t *pixels, int line_size, int cnt)
-{
-    int_simd16_t tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
-    int_simd16_t tmp10, tmp11, tmp12, tmp13;
-    int_simd16_t z1, z2, z3, z4, z5, z11, z13;
-    int16_t *dataptr;
-
-    cnt*=4;
-    // Pass 1: process rows.
-
-    dataptr = data;
-    for (; cnt > 0; cnt--) {
-        tmp0 = pixels[line_size*0] + pixels[line_size*7];
-        tmp7 = pixels[line_size*0] - pixels[line_size*7];
-        tmp1 = pixels[line_size*1] + pixels[line_size*6];
-        tmp6 = pixels[line_size*1] - pixels[line_size*6];
-        tmp2 = pixels[line_size*2] + pixels[line_size*5];
-        tmp5 = pixels[line_size*2] - pixels[line_size*5];
-        tmp3 = pixels[line_size*3] + pixels[line_size*4];
-        tmp4 = pixels[line_size*3] - pixels[line_size*4];
-
-        // Even part
-
-        tmp10 = tmp0 + tmp3;
-        tmp13 = tmp0 - tmp3;
-        tmp11 = tmp1 + tmp2;
-        tmp12 = tmp1 - tmp2;
-        //Even columns are written first, this leads to different order of columns
-        //in column_fidct(), but they are processed independently, so all ok.
-        //Later in the row_idct() columns readed at the same order.
-        dataptr[2] = tmp10 + tmp11;
-        dataptr[3] = tmp10 - tmp11;
-
-        z1 = MULTIPLY16H((tmp12 + tmp13)<<2, FIX_0_707106781);
-        dataptr[0] = tmp13 + z1;
-        dataptr[1] = tmp13 - z1;
-
-        // Odd part
-
-        tmp10 = (tmp4 + tmp5) <<2;
-        tmp11 = (tmp5 + tmp6) <<2;
-        tmp12 = (tmp6 + tmp7) <<2;
-
-        z5 = MULTIPLY16H(tmp10 - tmp12, FIX_0_382683433);
-        z2 = MULTIPLY16H(tmp10, FIX_0_541196100) + z5;
-        z4 = MULTIPLY16H(tmp12, FIX_1_306562965) + z5;
-        z3 = MULTIPLY16H(tmp11, FIX_0_707106781);
-
-        z11 = tmp7 + z3;
-        z13 = tmp7 - z3;
-
-        dataptr[4] = z13 + z2;
-        dataptr[5] = z13 - z2;
-        dataptr[6] = z11 + z4;
-        dataptr[7] = z11 - z4;
-
-        pixels++;               // advance pointer to next column
-        dataptr += DCTSIZE;
-    }
-}
-
-#else /* HAVE_MMX */
-
-static void row_fdct_mmx(int16_t *data,  const uint8_t *pixels,  int line_size,  int cnt)
-{
-    uint64_t __attribute__((aligned(8))) temps[4];
-    __asm__ volatile(
-        "lea (%%"REG_a",%%"REG_a",2), %%"REG_d"    \n\t"
-        "6:                     \n\t"
-        "movd (%%"REG_S"), %%mm0           \n\t"
-        "pxor %%mm7, %%mm7             \n\t"
-
-        "movd (%%"REG_S",%%"REG_a",), %%mm1     \n\t"
-        "punpcklbw %%mm7, %%mm0        \n\t"
-
-        "movd (%%"REG_S",%%"REG_a",2), %%mm2    \n\t"
-        "punpcklbw %%mm7, %%mm1        \n\t"
-
-        "punpcklbw %%mm7, %%mm2        \n\t"
-        "add %%"REG_d", %%"REG_S"             \n\t"
-
-        "movq %%mm0, %%mm5             \n\t"
-        //
-
-        "movd (%%"REG_S",%%"REG_a",4), %%mm3    \n\t" //7  ;prefetch!
-        "movq %%mm1, %%mm6             \n\t"
-
-        "movd (%%"REG_S",%%"REG_d",), %%mm4     \n\t" //6
-        "punpcklbw %%mm7, %%mm3        \n\t"
-
-        "psubw %%mm3, %%mm5            \n\t"
-        "punpcklbw %%mm7, %%mm4        \n\t"
-
-        "paddw %%mm3, %%mm0            \n\t"
-        "psubw %%mm4, %%mm6            \n\t"
-
-        "movd (%%"REG_S",%%"REG_a",2), %%mm3    \n\t" //5
-        "paddw %%mm4, %%mm1            \n\t"
-
-        "movq %%mm5, 0*8+%3            \n\t" //t7
-        "punpcklbw %%mm7, %%mm3        \n\t"
-
-        "movq %%mm6, 1*8+%3            \n\t" //t6
-        "movq %%mm2, %%mm4             \n\t"
-
-        "movd (%%"REG_S"), %%mm5           \n\t" //3
-        "paddw %%mm3, %%mm2            \n\t"
-
-        "movd (%%"REG_S",%%"REG_a",), %%mm6     \n\t" //4
-        "punpcklbw %%mm7, %%mm5        \n\t"
-
-        "psubw %%mm3, %%mm4            \n\t"
-        "punpcklbw %%mm7, %%mm6        \n\t"
-
-        "movq %%mm5, %%mm3             \n\t"
-        "paddw %%mm6, %%mm5            \n\t" //t3
-
-        "psubw %%mm6, %%mm3            \n\t" //t4  ; t0 t1 t2 t4 t5 t3 - -
-        "movq %%mm0, %%mm6             \n\t"
-
-        "movq %%mm1, %%mm7             \n\t"
-        "psubw %%mm5, %%mm0            \n\t" //t13
-
-        "psubw %%mm2, %%mm1            \n\t"
-        "paddw %%mm2, %%mm7            \n\t" //t11
-
-        "paddw %%mm0, %%mm1            \n\t"
-        "movq %%mm7, %%mm2             \n\t"
-
-        "psllw $2, %%mm1              \n\t"
-        "paddw %%mm5, %%mm6            \n\t" //t10
-
-        "pmulhw "MANGLE(ff_MM_FIX_0_707106781)", %%mm1 \n\t"
-        "paddw %%mm6, %%mm7            \n\t" //d2
-
-        "psubw %%mm2, %%mm6            \n\t" //d3
-        "movq %%mm0, %%mm5             \n\t"
-
-        //transpose 4x4
-        "movq %%mm7, %%mm2             \n\t"
-        "punpcklwd %%mm6, %%mm7        \n\t"
-
-        "paddw %%mm1, %%mm0            \n\t" //d0
-        "punpckhwd %%mm6, %%mm2        \n\t"
-
-        "psubw %%mm1, %%mm5            \n\t" //d1
-        "movq %%mm0, %%mm6             \n\t"
-
-        "movq 1*8+%3, %%mm1            \n\t"
-        "punpcklwd %%mm5, %%mm0        \n\t"
-
-        "punpckhwd %%mm5, %%mm6        \n\t"
-        "movq %%mm0, %%mm5             \n\t"
-
-        "punpckldq %%mm7, %%mm0        \n\t" //0
-        "paddw %%mm4, %%mm3            \n\t"
-
-        "punpckhdq %%mm7, %%mm5        \n\t" //1
-        "movq %%mm6, %%mm7             \n\t"
-
-        "movq %%mm0, "DCTSIZE_S"*0*2(%%"REG_D") \n\t"
-        "punpckldq %%mm2, %%mm6        \n\t" //2
-
-        "movq %%mm5, "DCTSIZE_S"*1*2(%%"REG_D") \n\t"
-        "punpckhdq %%mm2, %%mm7        \n\t" //3
-
-        "movq %%mm6, "DCTSIZE_S"*2*2(%%"REG_D") \n\t"
-        "paddw %%mm1, %%mm4            \n\t"
-
-        "movq %%mm7, "DCTSIZE_S"*3*2(%%"REG_D") \n\t"
-        "psllw $2, %%mm3              \n\t" //t10
-
-        "movq 0*8+%3, %%mm2           \n\t"
-        "psllw $2, %%mm4              \n\t" //t11
-
-        "pmulhw "MANGLE(ff_MM_FIX_0_707106781)", %%mm4 \n\t" //z3
-        "paddw %%mm2, %%mm1            \n\t"
-
-        "psllw $2, %%mm1              \n\t" //t12
-        "movq %%mm3, %%mm0             \n\t"
-
-        "pmulhw "MANGLE(ff_MM_FIX_0_541196100)", %%mm0 \n\t"
-        "psubw %%mm1, %%mm3            \n\t"
-
-        "pmulhw "MANGLE(MM_FIX_0_382683433)", %%mm3 \n\t" //z5
-        "movq %%mm2, %%mm5             \n\t"
-
-        "pmulhw "MANGLE(MM_FIX_1_306562965)", %%mm1 \n\t"
-        "psubw %%mm4, %%mm2            \n\t" //z13
-
-        "paddw %%mm4, %%mm5            \n\t" //z11
-        "movq %%mm2, %%mm6             \n\t"
-
-        "paddw %%mm3, %%mm0            \n\t" //z2
-        "movq %%mm5, %%mm7             \n\t"
-
-        "paddw %%mm0, %%mm2            \n\t" //d4
-        "psubw %%mm0, %%mm6            \n\t" //d5
-
-        "movq %%mm2, %%mm4             \n\t"
-        "paddw %%mm3, %%mm1            \n\t" //z4
-
-        //transpose 4x4
-        "punpcklwd %%mm6, %%mm2        \n\t"
-        "paddw %%mm1, %%mm5            \n\t" //d6
-
-        "punpckhwd %%mm6, %%mm4        \n\t"
-        "psubw %%mm1, %%mm7            \n\t" //d7
-
-        "movq %%mm5, %%mm6             \n\t"
-        "punpcklwd %%mm7, %%mm5        \n\t"
-
-        "punpckhwd %%mm7, %%mm6        \n\t"
-        "movq %%mm2, %%mm7             \n\t"
-
-        "punpckldq %%mm5, %%mm2        \n\t" //4
-        "sub %%"REG_d", %%"REG_S"             \n\t"
-
-        "punpckhdq %%mm5, %%mm7        \n\t" //5
-        "movq %%mm4, %%mm5             \n\t"
-
-        "movq %%mm2, "DCTSIZE_S"*0*2+"DCTSIZE_S"(%%"REG_D") \n\t"
-        "punpckldq %%mm6, %%mm4        \n\t" //6
-
-        "movq %%mm7, "DCTSIZE_S"*1*2+"DCTSIZE_S"(%%"REG_D") \n\t"
-        "punpckhdq %%mm6, %%mm5        \n\t" //7
-
-        "movq %%mm4, "DCTSIZE_S"*2*2+"DCTSIZE_S"(%%"REG_D") \n\t"
-        "add $4, %%"REG_S"               \n\t"
-
-        "movq %%mm5, "DCTSIZE_S"*3*2+"DCTSIZE_S"(%%"REG_D") \n\t"
-        "add $"DCTSIZE_S"*2*4, %%"REG_D"      \n\t" //4 rows
-        "dec %%"REG_c"                   \n\t"
-        "jnz 6b                  \n\t"
-
-        : "+S"(pixels), "+D"(data), "+c"(cnt), "=o"(temps)
-        : "a"(line_size)
-        : "%"REG_d);
-}
-
-#endif // HAVE_MMX
diff --git a/libavfilter/libmpcodecs/vf_ilpack.c b/libavfilter/libmpcodecs/vf_ilpack.c
deleted file mode 100644
index 4db6c0a..0000000
--- a/libavfilter/libmpcodecs/vf_ilpack.c
+++ /dev/null
@@ -1,458 +0,0 @@
-/*
- * This file is part of MPlayer.
- *
- * MPlayer is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * MPlayer is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with MPlayer; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <inttypes.h>
-
-#include "config.h"
-#include "mp_msg.h"
-#include "cpudetect.h"
-
-#include "img_format.h"
-#include "mp_image.h"
-#include "vf.h"
-#include "libavutil/attributes.h"
-#include "libavutil/x86/asm.h"
-
-typedef void (pack_func_t)(unsigned char *dst, unsigned char *y,
-    unsigned char *u, unsigned char *v, int w, int us, int vs);
-
-struct vf_priv_s {
-    int mode;
-    pack_func_t *pack[2];
-};
-
-static void pack_nn_C(unsigned char *dst, unsigned char *y,
-    unsigned char *u, unsigned char *v, int w,
-    int av_unused us, int av_unused vs)
-{
-    int j;
-    for (j = w/2; j; j--) {
-        *dst++ = *y++;
-        *dst++ = *u++;
-        *dst++ = *y++;
-        *dst++ = *v++;
-    }
-}
-
-static void pack_li_0_C(unsigned char *dst, unsigned char *y,
-    unsigned char *u, unsigned char *v, int w, int us, int vs)
-{
-    int j;
-    for (j = w/2; j; j--) {
-        *dst++ = *y++;
-        *dst++ = (u[us+us] + 7*u[0])>>3;
-        *dst++ = *y++;
-        *dst++ = (v[vs+vs] + 7*v[0])>>3;
-        u++; v++;
-    }
-}
-
-static void pack_li_1_C(unsigned char *dst, unsigned char *y,
-    unsigned char *u, unsigned char *v, int w, int us, int vs)
-{
-    int j;
-    for (j = w/2; j; j--) {
-        *dst++ = *y++;
-        *dst++ = (3*u[us+us] + 5*u[0])>>3;
-        *dst++ = *y++;
-        *dst++ = (3*v[vs+vs] + 5*v[0])>>3;
-        u++; v++;
-    }
-}
-
-#if HAVE_MMX
-static void pack_nn_MMX(unsigned char *dst, unsigned char *y,
-    unsigned char *u, unsigned char *v, int w,
-    int av_unused us, int av_unused vs)
-{
-    __asm__ volatile (""
-        ASMALIGN(4)
-        "1: \n\t"
-        "movq (%0), %%mm1 \n\t"
-        "movq (%0), %%mm2 \n\t"
-        "movq (%1), %%mm4 \n\t"
-        "movq (%2), %%mm6 \n\t"
-        "punpcklbw %%mm6, %%mm4 \n\t"
-        "punpcklbw %%mm4, %%mm1 \n\t"
-        "punpckhbw %%mm4, %%mm2 \n\t"
-
-        "add $8, %0 \n\t"
-        "add $4, %1 \n\t"
-        "add $4, %2 \n\t"
-        "movq %%mm1, (%3) \n\t"
-        "movq %%mm2, 8(%3) \n\t"
-        "add $16, %3 \n\t"
-        "decl %4 \n\t"
-        "jnz 1b \n\t"
-        "emms \n\t"
-        :
-        : "r" (y), "r" (u), "r" (v), "r" (dst), "r" (w/8)
-        : "memory"
-        );
-    pack_nn_C(dst, y, u, v, (w&7), 0, 0);
-}
-
-#if HAVE_EBX_AVAILABLE
-static void pack_li_0_MMX(unsigned char *dst, unsigned char *y,
-    unsigned char *u, unsigned char *v, int w, int us, int vs)
-{
-    __asm__ volatile (""
-        "push %%"REG_BP" \n\t"
-#if ARCH_X86_64
-        "mov %6, %%"REG_BP" \n\t"
-#else
-        "movl 4(%%"REG_d"), %%"REG_BP" \n\t"
-        "movl (%%"REG_d"), %%"REG_d" \n\t"
-#endif
-        "pxor %%mm0, %%mm0 \n\t"
-
-        ASMALIGN(4)
-        ".Lli0: \n\t"
-        "movq (%%"REG_S"), %%mm1 \n\t"
-        "movq (%%"REG_S"), %%mm2 \n\t"
-
-        "movq (%%"REG_a",%%"REG_d",2), %%mm4 \n\t"
-        "movq (%%"REG_b",%%"REG_BP",2), %%mm6 \n\t"
-        "punpcklbw %%mm0, %%mm4 \n\t"
-        "punpcklbw %%mm0, %%mm6 \n\t"
-        "movq (%%"REG_a"), %%mm3 \n\t"
-        "movq (%%"REG_b"), %%mm5 \n\t"
-        "punpcklbw %%mm0, %%mm3 \n\t"
-        "punpcklbw %%mm0, %%mm5 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "psrlw $3, %%mm4 \n\t"
-        "psrlw $3, %%mm6 \n\t"
-        "packuswb %%mm4, %%mm4 \n\t"
-        "packuswb %%mm6, %%mm6 \n\t"
-        "punpcklbw %%mm6, %%mm4 \n\t"
-        "punpcklbw %%mm4, %%mm1 \n\t"
-        "punpckhbw %%mm4, %%mm2 \n\t"
-
-        "movq %%mm1, (%%"REG_D") \n\t"
-        "movq %%mm2, 8(%%"REG_D") \n\t"
-
-        "movq 8(%%"REG_S"), %%mm1 \n\t"
-        "movq 8(%%"REG_S"), %%mm2 \n\t"
-
-        "movq (%%"REG_a",%%"REG_d",2), %%mm4 \n\t"
-        "movq (%%"REG_b",%%"REG_BP",2), %%mm6 \n\t"
-        "punpckhbw %%mm0, %%mm4 \n\t"
-        "punpckhbw %%mm0, %%mm6 \n\t"
-        "movq (%%"REG_a"), %%mm3 \n\t"
-        "movq (%%"REG_b"), %%mm5 \n\t"
-        "punpckhbw %%mm0, %%mm3 \n\t"
-        "punpckhbw %%mm0, %%mm5 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "psrlw $3, %%mm4 \n\t"
-        "psrlw $3, %%mm6 \n\t"
-        "packuswb %%mm4, %%mm4 \n\t"
-        "packuswb %%mm6, %%mm6 \n\t"
-        "punpcklbw %%mm6, %%mm4 \n\t"
-        "punpcklbw %%mm4, %%mm1 \n\t"
-        "punpckhbw %%mm4, %%mm2 \n\t"
-
-        "add $16, %%"REG_S" \n\t"
-        "add $8, %%"REG_a" \n\t"
-        "add $8, %%"REG_b" \n\t"
-
-        "movq %%mm1, 16(%%"REG_D") \n\t"
-        "movq %%mm2, 24(%%"REG_D") \n\t"
-        "add $32, %%"REG_D" \n\t"
-
-        "decl %%ecx \n\t"
-        "jnz .Lli0 \n\t"
-        "emms \n\t"
-        "pop %%"REG_BP" \n\t"
-        :
-        : "S" (y), "D" (dst), "a" (u), "b" (v), "c" (w/16),
-#if ARCH_X86_64
-        "d" ((x86_reg)us), "r" ((x86_reg)vs)
-#else
-        "d" (&us)
-#endif
-        : "memory"
-        );
-    pack_li_0_C(dst, y, u, v, (w&15), us, vs);
-}
-
-static void pack_li_1_MMX(unsigned char *dst, unsigned char *y,
-    unsigned char *u, unsigned char *v, int w, int us, int vs)
-{
-    __asm__ volatile (""
-        "push %%"REG_BP" \n\t"
-#if ARCH_X86_64
-        "mov %6, %%"REG_BP" \n\t"
-#else
-        "movl 4(%%"REG_d"), %%"REG_BP" \n\t"
-        "movl (%%"REG_d"), %%"REG_d" \n\t"
-#endif
-        "pxor %%mm0, %%mm0 \n\t"
-
-        ASMALIGN(4)
-        ".Lli1: \n\t"
-        "movq (%%"REG_S"), %%mm1 \n\t"
-        "movq (%%"REG_S"), %%mm2 \n\t"
-
-        "movq (%%"REG_a",%%"REG_d",2), %%mm4 \n\t"
-        "movq (%%"REG_b",%%"REG_BP",2), %%mm6 \n\t"
-        "punpcklbw %%mm0, %%mm4 \n\t"
-        "punpcklbw %%mm0, %%mm6 \n\t"
-        "movq (%%"REG_a"), %%mm3 \n\t"
-        "movq (%%"REG_b"), %%mm5 \n\t"
-        "punpcklbw %%mm0, %%mm3 \n\t"
-        "punpcklbw %%mm0, %%mm5 \n\t"
-        "movq %%mm4, %%mm7 \n\t"
-        "paddw %%mm4, %%mm4 \n\t"
-        "paddw %%mm7, %%mm4 \n\t"
-        "movq %%mm6, %%mm7 \n\t"
-        "paddw %%mm6, %%mm6 \n\t"
-        "paddw %%mm7, %%mm6 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "psrlw $3, %%mm4 \n\t"
-        "psrlw $3, %%mm6 \n\t"
-        "packuswb %%mm4, %%mm4 \n\t"
-        "packuswb %%mm6, %%mm6 \n\t"
-        "punpcklbw %%mm6, %%mm4 \n\t"
-        "punpcklbw %%mm4, %%mm1 \n\t"
-        "punpckhbw %%mm4, %%mm2 \n\t"
-
-        "movq %%mm1, (%%"REG_D") \n\t"
-        "movq %%mm2, 8(%%"REG_D") \n\t"
-
-        "movq 8(%%"REG_S"), %%mm1 \n\t"
-        "movq 8(%%"REG_S"), %%mm2 \n\t"
-
-        "movq (%%"REG_a",%%"REG_d",2), %%mm4 \n\t"
-        "movq (%%"REG_b",%%"REG_BP",2), %%mm6 \n\t"
-        "punpckhbw %%mm0, %%mm4 \n\t"
-        "punpckhbw %%mm0, %%mm6 \n\t"
-        "movq (%%"REG_a"), %%mm3 \n\t"
-        "movq (%%"REG_b"), %%mm5 \n\t"
-        "punpckhbw %%mm0, %%mm3 \n\t"
-        "punpckhbw %%mm0, %%mm5 \n\t"
-        "movq %%mm4, %%mm7 \n\t"
-        "paddw %%mm4, %%mm4 \n\t"
-        "paddw %%mm7, %%mm4 \n\t"
-        "movq %%mm6, %%mm7 \n\t"
-        "paddw %%mm6, %%mm6 \n\t"
-        "paddw %%mm7, %%mm6 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "paddw %%mm3, %%mm4 \n\t"
-        "paddw %%mm5, %%mm6 \n\t"
-        "psrlw $3, %%mm4 \n\t"
-        "psrlw $3, %%mm6 \n\t"
-        "packuswb %%mm4, %%mm4 \n\t"
-        "packuswb %%mm6, %%mm6 \n\t"
-        "punpcklbw %%mm6, %%mm4 \n\t"
-        "punpcklbw %%mm4, %%mm1 \n\t"
-        "punpckhbw %%mm4, %%mm2 \n\t"
-
-        "add $16, %%"REG_S" \n\t"
-        "add $8, %%"REG_a" \n\t"
-        "add $8, %%"REG_b" \n\t"
-
-        "movq %%mm1, 16(%%"REG_D") \n\t"
-        "movq %%mm2, 24(%%"REG_D") \n\t"
-        "add $32, %%"REG_D" \n\t"
-
-        "decl %%ecx \n\t"
-        "jnz .Lli1 \n\t"
-        "emms \n\t"
-        "pop %%"REG_BP" \n\t"
-        :
-        : "S" (y), "D" (dst), "a" (u), "b" (v), "c" (w/16),
-#if ARCH_X86_64
-        "d" ((x86_reg)us), "r" ((x86_reg)vs)
-#else
-        "d" (&us)
-#endif
-        : "memory"
-        );
-    pack_li_1_C(dst, y, u, v, (w&15), us, vs);
-}
-#endif /* HAVE_EBX_AVAILABLE */
-#endif
-
-static pack_func_t *pack_nn;
-static pack_func_t *pack_li_0;
-static pack_func_t *pack_li_1;
-
-static void ilpack(unsigned char *dst, unsigned char *src[3],
-    int dststride, int srcstride[3], int w, int h, pack_func_t *pack[2])
-{
-    int i;
-    unsigned char *y, *u, *v;
-    int ys = srcstride[0], us = srcstride[1], vs = srcstride[2];
-    int a, b;
-
-    y = src[0];
-    u = src[1];
-    v = src[2];
-
-    pack_nn(dst, y, u, v, w, 0, 0);
-    y += ys; dst += dststride;
-    pack_nn(dst, y, u+us, v+vs, w, 0, 0);
-    y += ys; dst += dststride;
-    for (i=2; i<h-2; i++) {
-        a = (i&2) ? 1 : -1;
-        b = (i&1) ^ ((i&2)>>1);
-        pack[b](dst, y, u, v, w, us*a, vs*a);
-        y += ys;
-        if ((i&3) == 1) {
-            u -= us;
-            v -= vs;
-        } else {
-            u += us;
-            v += vs;
-        }
-        dst += dststride;
-    }
-    pack_nn(dst, y, u, v, w, 0, 0);
-    y += ys; dst += dststride; u += us; v += vs;
-    pack_nn(dst, y, u, v, w, 0, 0);
-}
-
-
-static int put_image(struct vf_instance *vf, mp_image_t *mpi, double pts)
-{
-    mp_image_t *dmpi;
-
-    // hope we'll get DR buffer:
-    dmpi=ff_vf_get_image(vf->next, IMGFMT_YUY2,
-              MP_IMGTYPE_TEMP, MP_IMGFLAG_ACCEPT_STRIDE,
-              mpi->w, mpi->h);
-
-    ilpack(dmpi->planes[0], mpi->planes, dmpi->stride[0], mpi->stride, mpi->w, mpi->h, vf->priv->pack);
-
-    return ff_vf_next_put_image(vf,dmpi, pts);
-}
-
-static int config(struct vf_instance *vf,
-          int width, int height, int d_width, int d_height,
-          unsigned int flags, unsigned int outfmt)
-{
-    /* FIXME - also support UYVY output? */
-    return ff_vf_next_config(vf, width, height, d_width, d_height, flags, IMGFMT_YUY2);
-}
-
-
-static int query_format(struct vf_instance *vf, unsigned int fmt)
-{
-    /* FIXME - really any YUV 4:2:0 input format should work */
-    switch (fmt) {
-    case IMGFMT_YV12:
-    case IMGFMT_IYUV:
-    case IMGFMT_I420:
-        return ff_vf_next_query_format(vf,IMGFMT_YUY2);
-    }
-    return 0;
-}
-
-static int vf_open(vf_instance_t *vf, char *args)
-{
-    vf->config=config;
-    vf->query_format=query_format;
-    vf->put_image=put_image;
-    vf->priv = calloc(1, sizeof(struct vf_priv_s));
-    vf->priv->mode = 1;
-    if (args) sscanf(args, "%d", &vf->priv->mode);
-
-    pack_nn = pack_nn_C;
-    pack_li_0 = pack_li_0_C;
-    pack_li_1 = pack_li_1_C;
-#if HAVE_MMX
-    if(ff_gCpuCaps.hasMMX) {
-        pack_nn = pack_nn_MMX;
-#if HAVE_EBX_AVAILABLE
-        pack_li_0 = pack_li_0_MMX;
-        pack_li_1 = pack_li_1_MMX;
-#endif
-    }
-#endif
-
-    switch(vf->priv->mode) {
-    case 0:
-        vf->priv->pack[0] = vf->priv->pack[1] = pack_nn;
-        break;
-    default:
-        ff_mp_msg(MSGT_VFILTER, MSGL_WARN,
-            "ilpack: unknown mode %d (fallback to linear)\n",
-            vf->priv->mode);
-        /* Fallthrough */
-    case 1:
-        vf->priv->pack[0] = pack_li_0;
-        vf->priv->pack[1] = pack_li_1;
-        break;
-    }
-
-    return 1;
-}
-
-const vf_info_t ff_vf_info_ilpack = {
-    "4:2:0 planar -> 4:2:2 packed reinterlacer",
-    "ilpack",
-    "Richard Felker",
-    "",
-    vf_open,
-    NULL
-};
diff --git a/libavfilter/libmpcodecs/vf_pp7.c b/libavfilter/libmpcodecs/vf_pp7.c
deleted file mode 100644
index 30f9530..0000000
--- a/libavfilter/libmpcodecs/vf_pp7.c
+++ /dev/null
@@ -1,491 +0,0 @@
-/*
- * Copyright (C) 2005 Michael Niedermayer <michaelni@gmx.at>
- *
- * This file is part of MPlayer.
- *
- * MPlayer is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * MPlayer is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with MPlayer; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <inttypes.h>
-#include <math.h>
-
-#include "config.h"
-
-#include "mp_msg.h"
-#include "cpudetect.h"
-
-#if HAVE_MALLOC_H
-#include <malloc.h>
-#endif
-
-#include "libavutil/mem.h"
-
-#include "img_format.h"
-#include "mp_image.h"
-#include "vf.h"
-#include "libvo/fastmemcpy.h"
-
-#define XMIN(a,b) ((a) < (b) ? (a) : (b))
-#define XMAX(a,b) ((a) > (b) ? (a) : (b))
-
-//===========================================================================//
-static const uint8_t  __attribute__((aligned(8))) dither[8][8]={
-{  0,  48,  12,  60,   3,  51,  15,  63, },
-{ 32,  16,  44,  28,  35,  19,  47,  31, },
-{  8,  56,   4,  52,  11,  59,   7,  55, },
-{ 40,  24,  36,  20,  43,  27,  39,  23, },
-{  2,  50,  14,  62,   1,  49,  13,  61, },
-{ 34,  18,  46,  30,  33,  17,  45,  29, },
-{ 10,  58,   6,  54,   9,  57,   5,  53, },
-{ 42,  26,  38,  22,  41,  25,  37,  21, },
-};
-
-struct vf_priv_s {
-    int qp;
-    int mode;
-    int mpeg2;
-    int temp_stride;
-    uint8_t *src;
-};
-#if 0
-static inline void dct7_c(int16_t *dst, int s0, int s1, int s2, int s3, int step){
-    int s, d;
-    int dst2[64];
-//#define S0 (1024/0.37796447300922719759)
-#define C0 ((int)(1024*0.37796447300922719759+0.5)) //sqrt(1/7)
-#define C1 ((int)(1024*0.53452248382484879308/6+0.5)) //sqrt(2/7)/6
-
-#define C2 ((int)(1024*0.45221175985034745004/2+0.5))
-#define C3 ((int)(1024*0.36264567479870879474/2+0.5))
-
-//0.1962505182412941918 0.0149276808419397944-0.2111781990832339584
-#define C4 ((int)(1024*0.1962505182412941918+0.5))
-#define C5 ((int)(1024*0.0149276808419397944+0.5))
-//#define C6 ((int)(1024*0.2111781990832339584+0.5))
-#if 0
-    s= s0 + s1 + s2;
-    dst[0*step] = ((s + s3)*C0 + 512) >> 10;
-    s= (s - 6*s3)*C1 + 512;
-    d= (s0-s2)*C4 + (s1-s2)*C5;
-    dst[1*step] = (s + 2*d)>>10;
-    s -= d;
-    d= (s1-s0)*C2 + (s1-s2)*C3;
-    dst[2*step] = (s + d)>>10;
-    dst[3*step] = (s - d)>>10;
-#elif 1
-    s = s3+s3;
-    s3= s-s0;
-    s0= s+s0;
-    s = s2+s1;
-    s2= s2-s1;
-    dst[0*step]= s0 + s;
-    dst[2*step]= s0 - s;
-    dst[1*step]= 2*s3 +   s2;
-    dst[3*step]=   s3 - 2*s2;
-#else
-    int i,j,n=7;
-    for(i=0; i<7; i+=2){
-        dst2[i*step/2]= 0;
-        for(j=0; j<4; j++)
-            dst2[i*step/2] += src[j*step] * cos(i*M_PI/n*(j+0.5)) * sqrt((i?2.0:1.0)/n);
-        if(fabs(dst2[i*step/2] - dst[i*step/2]) > 20)
-            printf("%d %d %d (%d %d %d %d) -> (%d %d %d %d)\n", i,dst2[i*step/2], dst[i*step/2],src[0*step], src[1*step], src[2*step], src[3*step], dst[0*step], dst[1*step],dst[2*step],dst[3*step]);
-    }
-#endif
-}
-#endif
-
-static inline void dctA_c(int16_t *dst, uint8_t *src, int stride){
-    int i;
-
-    for(i=0; i<4; i++){
-        int s0=  src[0*stride] + src[6*stride];
-        int s1=  src[1*stride] + src[5*stride];
-        int s2=  src[2*stride] + src[4*stride];
-        int s3=  src[3*stride];
-        int s= s3+s3;
-        s3= s-s0;
-        s0= s+s0;
-        s = s2+s1;
-        s2= s2-s1;
-        dst[0]= s0 + s;
-        dst[2]= s0 - s;
-        dst[1]= 2*s3 +   s2;
-        dst[3]=   s3 - 2*s2;
-        src++;
-        dst+=4;
-    }
-}
-
-static void dctB_c(int16_t *dst, int16_t *src){
-    int i;
-
-    for(i=0; i<4; i++){
-        int s0=  src[0*4] + src[6*4];
-        int s1=  src[1*4] + src[5*4];
-        int s2=  src[2*4] + src[4*4];
-        int s3=  src[3*4];
-        int s= s3+s3;
-        s3= s-s0;
-        s0= s+s0;
-        s = s2+s1;
-        s2= s2-s1;
-        dst[0*4]= s0 + s;
-        dst[2*4]= s0 - s;
-        dst[1*4]= 2*s3 +   s2;
-        dst[3*4]=   s3 - 2*s2;
-        src++;
-        dst++;
-    }
-}
-
-#if HAVE_MMX
-static void dctB_mmx(int16_t *dst, int16_t *src){
-    __asm__ volatile (
-        "movq  (%0), %%mm0      \n\t"
-        "movq  1*4*2(%0), %%mm1 \n\t"
-        "paddw 6*4*2(%0), %%mm0 \n\t"
-        "paddw 5*4*2(%0), %%mm1 \n\t"
-        "movq  2*4*2(%0), %%mm2 \n\t"
-        "movq  3*4*2(%0), %%mm3 \n\t"
-        "paddw 4*4*2(%0), %%mm2 \n\t"
-        "paddw %%mm3, %%mm3     \n\t" //s
-        "movq %%mm3, %%mm4      \n\t" //s
-        "psubw %%mm0, %%mm3     \n\t" //s-s0
-        "paddw %%mm0, %%mm4     \n\t" //s+s0
-        "movq %%mm2, %%mm0      \n\t" //s2
-        "psubw %%mm1, %%mm2     \n\t" //s2-s1
-        "paddw %%mm1, %%mm0     \n\t" //s2+s1
-        "movq %%mm4, %%mm1      \n\t" //s0'
-        "psubw %%mm0, %%mm4     \n\t" //s0'-s'
-        "paddw %%mm0, %%mm1     \n\t" //s0'+s'
-        "movq %%mm3, %%mm0      \n\t" //s3'
-        "psubw %%mm2, %%mm3     \n\t"
-        "psubw %%mm2, %%mm3     \n\t"
-        "paddw %%mm0, %%mm2     \n\t"
-        "paddw %%mm0, %%mm2     \n\t"
-        "movq %%mm1, (%1)       \n\t"
-        "movq %%mm4, 2*4*2(%1)  \n\t"
-        "movq %%mm2, 1*4*2(%1)  \n\t"
-        "movq %%mm3, 3*4*2(%1)  \n\t"
-        :: "r" (src), "r"(dst)
-    );
-}
-#endif
-
-static void (*dctB)(int16_t *dst, int16_t *src)= dctB_c;
-
-#define N0 4
-#define N1 5
-#define N2 10
-#define SN0 2
-#define SN1 2.2360679775
-#define SN2 3.16227766017
-#define N (1<<16)
-
-static const int factor[16]={
-    N/(N0*N0), N/(N0*N1), N/(N0*N0),N/(N0*N2),
-    N/(N1*N0), N/(N1*N1), N/(N1*N0),N/(N1*N2),
-    N/(N0*N0), N/(N0*N1), N/(N0*N0),N/(N0*N2),
-    N/(N2*N0), N/(N2*N1), N/(N2*N0),N/(N2*N2),
-};
-
-static const int thres[16]={
-    N/(SN0*SN0), N/(SN0*SN2), N/(SN0*SN0),N/(SN0*SN2),
-    N/(SN2*SN0), N/(SN2*SN2), N/(SN2*SN0),N/(SN2*SN2),
-    N/(SN0*SN0), N/(SN0*SN2), N/(SN0*SN0),N/(SN0*SN2),
-    N/(SN2*SN0), N/(SN2*SN2), N/(SN2*SN0),N/(SN2*SN2),
-};
-
-static int thres2[99][16];
-
-static void init_thres2(void){
-    int qp, i;
-    int bias= 0; //FIXME
-
-    for(qp=0; qp<99; qp++){
-        for(i=0; i<16; i++){
-            thres2[qp][i]= ((i&1)?SN2:SN0) * ((i&4)?SN2:SN0) * XMAX(1,qp) * (1<<2) - 1 - bias;
-        }
-    }
-}
-
-static int hardthresh_c(int16_t *src, int qp){
-    int i;
-    int a;
-
-    a= src[0] * factor[0];
-    for(i=1; i<16; i++){
-        unsigned int threshold1= thres2[qp][i];
-        unsigned int threshold2= (threshold1<<1);
-        int level= src[i];
-        if(((unsigned)(level+threshold1))>threshold2){
-            a += level * factor[i];
-        }
-    }
-    return (a + (1<<11))>>12;
-}
-
-static int mediumthresh_c(int16_t *src, int qp){
-    int i;
-    int a;
-
-    a= src[0] * factor[0];
-    for(i=1; i<16; i++){
-        unsigned int threshold1= thres2[qp][i];
-        unsigned int threshold2= (threshold1<<1);
-        int level= src[i];
-        if(((unsigned)(level+threshold1))>threshold2){
-            if(((unsigned)(level+2*threshold1))>2*threshold2){
-                a += level * factor[i];
-            }else{
-                if(level>0) a+= 2*(level - (int)threshold1)*factor[i];
-                else        a+= 2*(level + (int)threshold1)*factor[i];
-            }
-        }
-    }
-    return (a + (1<<11))>>12;
-}
-
-static int softthresh_c(int16_t *src, int qp){
-    int i;
-    int a;
-
-    a= src[0] * factor[0];
-    for(i=1; i<16; i++){
-        unsigned int threshold1= thres2[qp][i];
-        unsigned int threshold2= (threshold1<<1);
-        int level= src[i];
-        if(((unsigned)(level+threshold1))>threshold2){
-            if(level>0) a+= (level - (int)threshold1)*factor[i];
-            else        a+= (level + (int)threshold1)*factor[i];
-        }
-    }
-    return (a + (1<<11))>>12;
-}
-
-static int (*requantize)(int16_t *src, int qp)= hardthresh_c;
-
-static void filter(struct vf_priv_s *p, uint8_t *dst, uint8_t *src, int dst_stride, int src_stride, int width, int height, uint8_t *qp_store, int qp_stride, int is_luma){
-    int x, y;
-    const int stride= is_luma ? p->temp_stride : ((width+16+15)&(~15));
-    uint8_t  *p_src= p->src + 8*stride;
-    int16_t *block= (int16_t *)p->src;
-    int16_t *temp= (int16_t *)(p->src + 32);
-
-    if (!src || !dst) return; // HACK avoid crash for Y8 colourspace
-    for(y=0; y<height; y++){
-        int index= 8 + 8*stride + y*stride;
-        fast_memcpy(p_src + index, src + y*src_stride, width);
-        for(x=0; x<8; x++){
-            p_src[index         - x - 1]= p_src[index +         x    ];
-            p_src[index + width + x    ]= p_src[index + width - x - 1];
-        }
-    }
-    for(y=0; y<8; y++){
-        fast_memcpy(p_src + (       7-y)*stride, p_src + (       y+8)*stride, stride);
-        fast_memcpy(p_src + (height+8+y)*stride, p_src + (height-y+7)*stride, stride);
-    }
-    //FIXME (try edge emu)
-
-    for(y=0; y<height; y++){
-        for(x=-8; x<0; x+=4){
-            const int index= x + y*stride + (8-3)*(1+stride) + 8; //FIXME silly offset
-            uint8_t *src  = p_src + index;
-            int16_t *tp= temp+4*x;
-
-            dctA_c(tp+4*8, src, stride);
-        }
-        for(x=0; x<width; ){
-            const int qps= 3 + is_luma;
-            int qp;
-            int end= XMIN(x+8, width);
-
-            if(p->qp)
-                qp= p->qp;
-            else{
-                qp= qp_store[ (XMIN(x, width-1)>>qps) + (XMIN(y, height-1)>>qps) * qp_stride];
-                qp=norm_qscale(qp, p->mpeg2);
-            }
-            for(; x<end; x++){
-                const int index= x + y*stride + (8-3)*(1+stride) + 8; //FIXME silly offset
-                uint8_t *src  = p_src + index;
-                int16_t *tp= temp+4*x;
-                int v;
-
-                if((x&3)==0)
-                    dctA_c(tp+4*8, src, stride);
-
-                dctB(block, tp);
-
-                v= requantize(block, qp);
-                v= (v + dither[y&7][x&7])>>6;
-                if((unsigned)v > 255)
-                    v= (-v)>>31;
-                dst[x + y*dst_stride]= v;
-            }
-        }
-    }
-}
-
-static int config(struct vf_instance *vf,
-    int width, int height, int d_width, int d_height,
-    unsigned int flags, unsigned int outfmt){
-    int h= (height+16+15)&(~15);
-
-    vf->priv->temp_stride= (width+16+15)&(~15);
-    vf->priv->src = av_malloc(vf->priv->temp_stride*(h+8)*sizeof(uint8_t));
-
-    return ff_vf_next_config(vf,width,height,d_width,d_height,flags,outfmt);
-}
-
-static void get_image(struct vf_instance *vf, mp_image_t *mpi){
-    if(mpi->flags&MP_IMGFLAG_PRESERVE) return; // don't change
-    // ok, we can do pp in-place (or pp disabled):
-    vf->dmpi=ff_vf_get_image(vf->next,mpi->imgfmt,
-        mpi->type, mpi->flags | MP_IMGFLAG_READABLE, mpi->width, mpi->height);
-    mpi->planes[0]=vf->dmpi->planes[0];
-    mpi->stride[0]=vf->dmpi->stride[0];
-    mpi->width=vf->dmpi->width;
-    if(mpi->flags&MP_IMGFLAG_PLANAR){
-        mpi->planes[1]=vf->dmpi->planes[1];
-        mpi->planes[2]=vf->dmpi->planes[2];
-        mpi->stride[1]=vf->dmpi->stride[1];
-        mpi->stride[2]=vf->dmpi->stride[2];
-    }
-    mpi->flags|=MP_IMGFLAG_DIRECT;
-}
-
-static int put_image(struct vf_instance *vf, mp_image_t *mpi, double pts){
-    mp_image_t *dmpi;
-
-    if(mpi->flags&MP_IMGFLAG_DIRECT){
-        dmpi=vf->dmpi;
-    }else{
-        // no DR, so get a new image! hope we'll get DR buffer:
-        dmpi=ff_vf_get_image(vf->next,mpi->imgfmt,
-            MP_IMGTYPE_TEMP,
-            MP_IMGFLAG_ACCEPT_STRIDE|MP_IMGFLAG_PREFER_ALIGNED_STRIDE,
-            mpi->width,mpi->height);
-        ff_vf_clone_mpi_attributes(dmpi, mpi);
-    }
-
-    vf->priv->mpeg2= mpi->qscale_type;
-    if(mpi->qscale || vf->priv->qp){
-        filter(vf->priv, dmpi->planes[0], mpi->planes[0], dmpi->stride[0], mpi->stride[0], mpi->w, mpi->h, mpi->qscale, mpi->qstride, 1);
-        filter(vf->priv, dmpi->planes[1], mpi->planes[1], dmpi->stride[1], mpi->stride[1], mpi->w>>mpi->chroma_x_shift, mpi->h>>mpi->chroma_y_shift, mpi->qscale, mpi->qstride, 0);
-        filter(vf->priv, dmpi->planes[2], mpi->planes[2], dmpi->stride[2], mpi->stride[2], mpi->w>>mpi->chroma_x_shift, mpi->h>>mpi->chroma_y_shift, mpi->qscale, mpi->qstride, 0);
-    }else{
-        memcpy_pic(dmpi->planes[0], mpi->planes[0], mpi->w, mpi->h, dmpi->stride[0], mpi->stride[0]);
-        memcpy_pic(dmpi->planes[1], mpi->planes[1], mpi->w>>mpi->chroma_x_shift, mpi->h>>mpi->chroma_y_shift, dmpi->stride[1], mpi->stride[1]);
-        memcpy_pic(dmpi->planes[2], mpi->planes[2], mpi->w>>mpi->chroma_x_shift, mpi->h>>mpi->chroma_y_shift, dmpi->stride[2], mpi->stride[2]);
-    }
-
-#if HAVE_MMX
-    if(ff_gCpuCaps.hasMMX) __asm__ volatile ("emms\n\t");
-#endif
-#if HAVE_MMX2
-    if(ff_gCpuCaps.hasMMX2) __asm__ volatile ("sfence\n\t");
-#endif
-
-    return ff_vf_next_put_image(vf,dmpi, pts);
-}
-
-static void uninit(struct vf_instance *vf){
-    if(!vf->priv) return;
-
-    av_free(vf->priv->src);
-    vf->priv->src= NULL;
-
-    free(vf->priv);
-    vf->priv=NULL;
-}
-
-//===========================================================================//
-static int query_format(struct vf_instance *vf, unsigned int fmt){
-    switch(fmt){
-    case IMGFMT_YVU9:
-    case IMGFMT_IF09:
-    case IMGFMT_YV12:
-    case IMGFMT_I420:
-    case IMGFMT_IYUV:
-    case IMGFMT_CLPL:
-    case IMGFMT_Y800:
-    case IMGFMT_Y8:
-    case IMGFMT_444P:
-    case IMGFMT_422P:
-    case IMGFMT_411P:
-        return ff_vf_next_query_format(vf,fmt);
-    }
-    return 0;
-}
-
-static int control(struct vf_instance *vf, int request, void* data){
-    return ff_vf_next_control(vf,request,data);
-}
-
-static int vf_open(vf_instance_t *vf, char *args){
-    vf->config=config;
-    vf->put_image=put_image;
-    vf->get_image=get_image;
-    vf->query_format=query_format;
-    vf->uninit=uninit;
-    vf->control= control;
-    vf->priv=malloc(sizeof(struct vf_priv_s));
-    memset(vf->priv, 0, sizeof(struct vf_priv_s));
-
-    if (args) sscanf(args, "%d:%d", &vf->priv->qp, &vf->priv->mode);
-
-    if(vf->priv->qp < 0)
-        vf->priv->qp = 0;
-
-    init_thres2();
-
-    switch(vf->priv->mode){
-        case 0: requantize= hardthresh_c; break;
-        case 1: requantize= softthresh_c; break;
-        default:
-        case 2: requantize= mediumthresh_c; break;
-    }
-
-#if HAVE_MMX
-    if(ff_gCpuCaps.hasMMX){
-        dctB= dctB_mmx;
-    }
-#endif
-#if 0
-    if(ff_gCpuCaps.hasMMX){
-        switch(vf->priv->mode){
-            case 0: requantize= hardthresh_mmx; break;
-            case 1: requantize= softthresh_mmx; break;
-        }
-    }
-#endif
-
-    return 1;
-}
-
-const vf_info_t ff_vf_info_pp7 = {
-    "postprocess 7",
-    "pp7",
-    "Michael Niedermayer",
-    "",
-    vf_open,
-    NULL
-};
diff --git a/libavfilter/libmpcodecs/vf_softpulldown.c b/libavfilter/libmpcodecs/vf_softpulldown.c
deleted file mode 100644
index 556374e..0000000
--- a/libavfilter/libmpcodecs/vf_softpulldown.c
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
- * This file is part of MPlayer.
- *
- * MPlayer is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * MPlayer is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with MPlayer; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "config.h"
-#include "mp_msg.h"
-
-#include "img_format.h"
-#include "mp_image.h"
-#include "vf.h"
-
-#include "libvo/fastmemcpy.h"
-
-struct vf_priv_s {
-    int state;
-    long long in;
-    long long out;
-};
-
-static int put_image(struct vf_instance *vf, mp_image_t *mpi, double pts)
-{
-    mp_image_t *dmpi;
-    int ret = 0;
-    int flags = mpi->fields;
-    int state = vf->priv->state;
-
-    dmpi = ff_vf_get_image(vf->next, mpi->imgfmt,
-                        MP_IMGTYPE_STATIC, MP_IMGFLAG_ACCEPT_STRIDE |
-                        MP_IMGFLAG_PRESERVE, mpi->width, mpi->height);
-
-    vf->priv->in++;
-
-    if ((state == 0 &&
-         !(flags & MP_IMGFIELD_TOP_FIRST)) ||
-        (state == 1 &&
-         flags & MP_IMGFIELD_TOP_FIRST)) {
-        ff_mp_msg(MSGT_VFILTER, MSGL_WARN,
-               "softpulldown: Unexpected field flags: state=%d top_field_first=%d repeat_first_field=%d\n",
-               state,
-               (flags & MP_IMGFIELD_TOP_FIRST) != 0,
-               (flags & MP_IMGFIELD_REPEAT_FIRST) != 0);
-        state ^= 1;
-    }
-
-    if (state == 0) {
-        ret = ff_vf_next_put_image(vf, mpi, MP_NOPTS_VALUE);
-        vf->priv->out++;
-        if (flags & MP_IMGFIELD_REPEAT_FIRST) {
-            my_memcpy_pic(dmpi->planes[0],
-                       mpi->planes[0], mpi->w, mpi->h/2,
-                       dmpi->stride[0]*2, mpi->stride[0]*2);
-            if (mpi->flags & MP_IMGFLAG_PLANAR) {
-                my_memcpy_pic(dmpi->planes[1],
-                              mpi->planes[1],
-                              mpi->chroma_width,
-                              mpi->chroma_height/2,
-                              dmpi->stride[1]*2,
-                              mpi->stride[1]*2);
-                my_memcpy_pic(dmpi->planes[2],
-                              mpi->planes[2],
-                              mpi->chroma_width,
-                              mpi->chroma_height/2,
-                              dmpi->stride[2]*2,
-                              mpi->stride[2]*2);
-            }
-            state=1;
-        }
-    } else {
-        my_memcpy_pic(dmpi->planes[0]+dmpi->stride[0],
-                      mpi->planes[0]+mpi->stride[0], mpi->w, mpi->h/2,
-                      dmpi->stride[0]*2, mpi->stride[0]*2);
-        if (mpi->flags & MP_IMGFLAG_PLANAR) {
-            my_memcpy_pic(dmpi->planes[1]+dmpi->stride[1],
-                          mpi->planes[1]+mpi->stride[1],
-                          mpi->chroma_width, mpi->chroma_height/2,
-                          dmpi->stride[1]*2, mpi->stride[1]*2);
-            my_memcpy_pic(dmpi->planes[2]+dmpi->stride[2],
-                          mpi->planes[2]+mpi->stride[2],
-                          mpi->chroma_width, mpi->chroma_height/2,
-                          dmpi->stride[2]*2, mpi->stride[2]*2);
-        }
-        ret = ff_vf_next_put_image(vf, dmpi, MP_NOPTS_VALUE);
-        vf->priv->out++;
-        if (flags & MP_IMGFIELD_REPEAT_FIRST) {
-            ret |= ff_vf_next_put_image(vf, mpi, MP_NOPTS_VALUE);
-            vf->priv->out++;
-            state=0;
-        } else {
-            my_memcpy_pic(dmpi->planes[0],
-                          mpi->planes[0], mpi->w, mpi->h/2,
-                          dmpi->stride[0]*2, mpi->stride[0]*2);
-            if (mpi->flags & MP_IMGFLAG_PLANAR) {
-                my_memcpy_pic(dmpi->planes[1],
-                              mpi->planes[1],
-                              mpi->chroma_width,
-                              mpi->chroma_height/2,
-                              dmpi->stride[1]*2,
-                              mpi->stride[1]*2);
-                my_memcpy_pic(dmpi->planes[2],
-                              mpi->planes[2],
-                              mpi->chroma_width,
-                              mpi->chroma_height/2,
-                              dmpi->stride[2]*2,
-                              mpi->stride[2]*2);
-            }
-        }
-    }
-
-    vf->priv->state = state;
-
-    return ret;
-}
-
-static int config(struct vf_instance *vf,
-    int width, int height, int d_width, int d_height,
-    unsigned int flags, unsigned int outfmt)
-{
-    return ff_vf_next_config(vf,width,height,d_width,d_height,flags,outfmt);
-}
-
-static void uninit(struct vf_instance *vf)
-{
-    ff_mp_msg(MSGT_VFILTER, MSGL_INFO, "softpulldown: %lld frames in, %lld frames out\n", vf->priv->in, vf->priv->out);
-    free(vf->priv);
-}
-
-static int vf_open(vf_instance_t *vf, char *args)
-{
-    vf->config = config;
-    vf->put_image = put_image;
-    vf->uninit = uninit;
-    vf->default_reqs = VFCAP_ACCEPT_STRIDE;
-    vf->priv = calloc(1, sizeof(struct vf_priv_s));
-    vf->priv->state = 0;
-    return 1;
-}
-
-const vf_info_t ff_vf_info_softpulldown = {
-    "mpeg2 soft 3:2 pulldown",
-    "softpulldown",
-    "Tobias Diedrich <ranma+mplayer@tdiedrich.de>",
-    "",
-    vf_open,
-    NULL
-};
diff --git a/libavfilter/libmpcodecs/vf_uspp.c b/libavfilter/libmpcodecs/vf_uspp.c
deleted file mode 100644
index 1fb2523..0000000
--- a/libavfilter/libmpcodecs/vf_uspp.c
+++ /dev/null
@@ -1,393 +0,0 @@
-/*
- * Copyright (C) 2005 Michael Niedermayer <michaelni@gmx.at>
- *
- * This file is part of MPlayer.
- *
- * MPlayer is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * MPlayer is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with MPlayer; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <inttypes.h>
-#include <math.h>
-#include <assert.h>
-
-#include "config.h"
-
-#include "mp_msg.h"
-#include "cpudetect.h"
-
-#include "libavutil/mem.h"
-#include "libavcodec/avcodec.h"
-
-#include "img_format.h"
-#include "mp_image.h"
-#include "vf.h"
-#include "av_helpers.h"
-#include "libvo/fastmemcpy.h"
-
-#define XMIN(a,b) ((a) < (b) ? (a) : (b))
-
-#define BLOCK 16
-
-//===========================================================================//
-static const uint8_t  __attribute__((aligned(8))) dither[8][8]={
-{  0*4,  48*4,  12*4,  60*4,   3*4,  51*4,  15*4,  63*4, },
-{ 32*4,  16*4,  44*4,  28*4,  35*4,  19*4,  47*4,  31*4, },
-{  8*4,  56*4,   4*4,  52*4,  11*4,  59*4,   7*4,  55*4, },
-{ 40*4,  24*4,  36*4,  20*4,  43*4,  27*4,  39*4,  23*4, },
-{  2*4,  50*4,  14*4,  62*4,   1*4,  49*4,  13*4,  61*4, },
-{ 34*4,  18*4,  46*4,  30*4,  33*4,  17*4,  45*4,  29*4, },
-{ 10*4,  58*4,   6*4,  54*4,   9*4,  57*4,   5*4,  53*4, },
-{ 42*4,  26*4,  38*4,  22*4,  41*4,  25*4,  37*4,  21*4, },
-};
-
-static const uint8_t offset[511][2]= {
-{ 0, 0},
-{ 0, 0}, { 8, 8},
-{ 0, 0}, { 4, 4}, {12, 8}, { 8,12},
-{ 0, 0}, {10, 2}, { 4, 4}, {14, 6}, { 8, 8}, { 2,10}, {12,12}, { 6,14},
-
-{ 0, 0}, {10, 2}, { 4, 4}, {14, 6}, { 8, 8}, { 2,10}, {12,12}, { 6,14},
-{ 5, 1}, {15, 3}, { 9, 5}, { 3, 7}, {13, 9}, { 7,11}, { 1,13}, {11,15},
-
-{ 0, 0}, { 8, 0}, { 0, 8}, { 8, 8}, { 5, 1}, {13, 1}, { 5, 9}, {13, 9},
-{ 2, 2}, {10, 2}, { 2,10}, {10,10}, { 7, 3}, {15, 3}, { 7,11}, {15,11},
-{ 4, 4}, {12, 4}, { 4,12}, {12,12}, { 1, 5}, { 9, 5}, { 1,13}, { 9,13},
-{ 6, 6}, {14, 6}, { 6,14}, {14,14}, { 3, 7}, {11, 7}, { 3,15}, {11,15},
-
-{ 0, 0}, { 8, 0}, { 0, 8}, { 8, 8}, { 4, 0}, {12, 0}, { 4, 8}, {12, 8},
-{ 1, 1}, { 9, 1}, { 1, 9}, { 9, 9}, { 5, 1}, {13, 1}, { 5, 9}, {13, 9},
-{ 3, 2}, {11, 2}, { 3,10}, {11,10}, { 7, 2}, {15, 2}, { 7,10}, {15,10},
-{ 2, 3}, {10, 3}, { 2,11}, {10,11}, { 6, 3}, {14, 3}, { 6,11}, {14,11},
-{ 0, 4}, { 8, 4}, { 0,12}, { 8,12}, { 4, 4}, {12, 4}, { 4,12}, {12,12},
-{ 1, 5}, { 9, 5}, { 1,13}, { 9,13}, { 5, 5}, {13, 5}, { 5,13}, {13,13},
-{ 3, 6}, {11, 6}, { 3,14}, {11,14}, { 7, 6}, {15, 6}, { 7,14}, {15,14},
-{ 2, 7}, {10, 7}, { 2,15}, {10,15}, { 6, 7}, {14, 7}, { 6,15}, {14,15},
-
-{ 0, 0}, { 8, 0}, { 0, 8}, { 8, 8}, { 0, 2}, { 8, 2}, { 0,10}, { 8,10},
-{ 0, 4}, { 8, 4}, { 0,12}, { 8,12}, { 0, 6}, { 8, 6}, { 0,14}, { 8,14},
-{ 1, 1}, { 9, 1}, { 1, 9}, { 9, 9}, { 1, 3}, { 9, 3}, { 1,11}, { 9,11},
-{ 1, 5}, { 9, 5}, { 1,13}, { 9,13}, { 1, 7}, { 9, 7}, { 1,15}, { 9,15},
-{ 2, 0}, {10, 0}, { 2, 8}, {10, 8}, { 2, 2}, {10, 2}, { 2,10}, {10,10},
-{ 2, 4}, {10, 4}, { 2,12}, {10,12}, { 2, 6}, {10, 6}, { 2,14}, {10,14},
-{ 3, 1}, {11, 1}, { 3, 9}, {11, 9}, { 3, 3}, {11, 3}, { 3,11}, {11,11},
-{ 3, 5}, {11, 5}, { 3,13}, {11,13}, { 3, 7}, {11, 7}, { 3,15}, {11,15},
-{ 4, 0}, {12, 0}, { 4, 8}, {12, 8}, { 4, 2}, {12, 2}, { 4,10}, {12,10},
-{ 4, 4}, {12, 4}, { 4,12}, {12,12}, { 4, 6}, {12, 6}, { 4,14}, {12,14},
-{ 5, 1}, {13, 1}, { 5, 9}, {13, 9}, { 5, 3}, {13, 3}, { 5,11}, {13,11},
-{ 5, 5}, {13, 5}, { 5,13}, {13,13}, { 5, 7}, {13, 7}, { 5,15}, {13,15},
-{ 6, 0}, {14, 0}, { 6, 8}, {14, 8}, { 6, 2}, {14, 2}, { 6,10}, {14,10},
-{ 6, 4}, {14, 4}, { 6,12}, {14,12}, { 6, 6}, {14, 6}, { 6,14}, {14,14},
-{ 7, 1}, {15, 1}, { 7, 9}, {15, 9}, { 7, 3}, {15, 3}, { 7,11}, {15,11},
-{ 7, 5}, {15, 5}, { 7,13}, {15,13}, { 7, 7}, {15, 7}, { 7,15}, {15,15},
-
-{ 0, 0}, { 8, 0}, { 0, 8}, { 8, 8}, { 4, 4}, {12, 4}, { 4,12}, {12,12}, { 0, 4}, { 8, 4}, { 0,12}, { 8,12}, { 4, 0}, {12, 0}, { 4, 8}, {12, 8}, { 2, 2}, {10, 2}, { 2,10}, {10,10}, { 6, 6}, {14, 6}, { 6,14}, {14,14}, { 2, 6}, {10, 6}, { 2,14}, {10,14}, { 6, 2}, {14, 2}, { 6,10}, {14,10}, { 0, 2}, { 8, 2}, { 0,10}, { 8,10}, { 4, 6}, {12, 6}, { 4,14}, {12,14}, { 0, 6}, { 8, 6}, { 0,14}, { 8,14}, { 4, 2}, {12, 2}, { 4,10}, {12,10}, { 2, 0}, {10, 0}, { 2, 8}, {10, 8}, { 6, 4}, {14, 4}, { 6,12}, {14,12}, { 2, 4}, {10, 4}, { 2,12}, {10,12}, { 6, 0}, {14, 0}, { 6, 8}, {14, 8}, { 1, 1}, { 9, 1}, { 1, 9}, { 9, 9}, { 5, 5}, {13, 5}, { 5,13}, {13,13}, { 1, 5}, { 9, 5}, { 1,13}, { 9,13}, { 5, 1}, {13, 1}, { 5, 9}, {13, 9}, { 3, 3}, {11, 3}, { 3,11}, {11,11}, { 7, 7}, {15, 7}, { 7,15}, {15,15}, { 3, 7}, {11, 7}, { 3,15}, {11,15}, { 7, 3}, {15, 3}, { 7,11}, {15,11}, { 1, 3}, { 9, 3}, { 1,11}, { 9,11}, { 5, 7}, {13, 7}, { 5,15}, {13,15}, { 1, 7}, { 9, 7}, { 1,15}, { 9,15}, { 5, 3}, {13, 3}, { 5,11}, {13,11}, { 3, 1}, {11, 1}
-, { 3, 9}, {11, 9}, { 7, 5}, {15, 5}, { 7,13}, {15,13}, { 3, 5}, {11, 5}, { 3,13}, {11,13}, { 7, 1}, {15, 1}, { 7, 9}, {15, 9}, { 0, 1}, { 8, 1}, { 0, 9}, { 8, 9}, { 4, 5}, {12, 5}, { 4,13}, {12,13}, { 0, 5}, { 8, 5}, { 0,13}, { 8,13}, { 4, 1}, {12, 1}, { 4, 9}, {12, 9}, { 2, 3}, {10, 3}, { 2,11}, {10,11}, { 6, 7}, {14, 7}, { 6,15}, {14,15}, { 2, 7}, {10, 7}, { 2,15}, {10,15}, { 6, 3}, {14, 3}, { 6,11}, {14,11}, { 0, 3}, { 8, 3}, { 0,11}, { 8,11}, { 4, 7}, {12, 7}, { 4,15}, {12,15}, { 0, 7}, { 8, 7}, { 0,15}, { 8,15}, { 4, 3}, {12, 3}, { 4,11}, {12,11}, { 2, 1}, {10, 1}, { 2, 9}, {10, 9}, { 6, 5}, {14, 5}, { 6,13}, {14,13}, { 2, 5}, {10, 5}, { 2,13}, {10,13}, { 6, 1}, {14, 1}, { 6, 9}, {14, 9}, { 1, 0}, { 9, 0}, { 1, 8}, { 9, 8}, { 5, 4}, {13, 4}, { 5,12}, {13,12}, { 1, 4}, { 9, 4}, { 1,12}, { 9,12}, { 5, 0}, {13, 0}, { 5, 8}, {13, 8}, { 3, 2}, {11, 2}, { 3,10}, {11,10}, { 7, 6}, {15, 6}, { 7,14}, {15,14}, { 3, 6}, {11, 6}, { 3,14}, {11,14}, { 7, 2}, {15, 2}, { 7,10}, {15,10}, { 1, 2}, { 9, 2}, { 1,10}, { 9,
-10}, { 5, 6}, {13, 6}, { 5,14}, {13,14}, { 1, 6}, { 9, 6}, { 1,14}, { 9,14}, { 5, 2}, {13, 2}, { 5,10}, {13,10}, { 3, 0}, {11, 0}, { 3, 8}, {11, 8}, { 7, 4}, {15, 4}, { 7,12}, {15,12}, { 3, 4}, {11, 4}, { 3,12}, {11,12}, { 7, 0}, {15, 0}, { 7, 8}, {15, 8},
-};
-
-struct vf_priv_s {
-    int log2_count;
-    int qp;
-    int mode;
-    int mpeg2;
-    int temp_stride[3];
-    uint8_t *src[3];
-    int16_t *temp[3];
-    int outbuf_size;
-    uint8_t *outbuf;
-    AVCodecContext *avctx_enc[BLOCK*BLOCK];
-    AVFrame *frame;
-    AVFrame *frame_dec;
-};
-
-static void store_slice_c(uint8_t *dst, int16_t *src, int dst_stride, int src_stride, int width, int height, int log2_scale){
-        int y, x;
-
-#define STORE(pos) \
-        temp= ((src[x + y*src_stride + pos]<<log2_scale) + d[pos])>>8;\
-        if(temp & 0x100) temp= ~(temp>>31);\
-        dst[x + y*dst_stride + pos]= temp;
-
-        for(y=0; y<height; y++){
-                const uint8_t *d= dither[y&7];
-                for(x=0; x<width; x+=8){
-                        int temp;
-                        STORE(0);
-                        STORE(1);
-                        STORE(2);
-                        STORE(3);
-                        STORE(4);
-                        STORE(5);
-                        STORE(6);
-                        STORE(7);
-                }
-        }
-}
-
-static void filter(struct vf_priv_s *p, uint8_t *dst[3], uint8_t *src[3], int dst_stride[3], int src_stride[3], int width, int height, uint8_t *qp_store, int qp_stride){
-    int x, y, i, j;
-    const int count= 1<<p->log2_count;
-
-    for(i=0; i<3; i++){
-        int is_chroma= !!i;
-        int w= width >>is_chroma;
-        int h= height>>is_chroma;
-        int stride= p->temp_stride[i];
-        int block= BLOCK>>is_chroma;
-
-        if (!src[i] || !dst[i])
-            continue; // HACK avoid crash for Y8 colourspace
-        for(y=0; y<h; y++){
-            int index= block + block*stride + y*stride;
-            fast_memcpy(p->src[i] + index, src[i] + y*src_stride[i], w);
-            for(x=0; x<block; x++){
-                p->src[i][index     - x - 1]= p->src[i][index +     x    ];
-                p->src[i][index + w + x    ]= p->src[i][index + w - x - 1];
-            }
-        }
-        for(y=0; y<block; y++){
-            fast_memcpy(p->src[i] + (  block-1-y)*stride, p->src[i] + (  y+block  )*stride, stride);
-            fast_memcpy(p->src[i] + (h+block  +y)*stride, p->src[i] + (h-y+block-1)*stride, stride);
-        }
-
-        p->frame->linesize[i]= stride;
-        memset(p->temp[i], 0, (h+2*block)*stride*sizeof(int16_t));
-    }
-
-    if(p->qp)
-        p->frame->quality= p->qp * FF_QP2LAMBDA;
-    else
-        p->frame->quality= norm_qscale(qp_store[0], p->mpeg2) * FF_QP2LAMBDA;
-//    init per MB qscale stuff FIXME
-
-    for(i=0; i<count; i++){
-        const int x1= offset[i+count-1][0];
-        const int y1= offset[i+count-1][1];
-        int offset;
-        p->frame->data[0]= p->src[0] + x1 + y1 * p->frame->linesize[0];
-        p->frame->data[1]= p->src[1] + x1/2 + y1/2 * p->frame->linesize[1];
-        p->frame->data[2]= p->src[2] + x1/2 + y1/2 * p->frame->linesize[2];
-
-        avcodec_encode_video(p->avctx_enc[i], p->outbuf, p->outbuf_size, p->frame);
-        p->frame_dec = p->avctx_enc[i]->coded_frame;
-
-        offset= (BLOCK-x1) + (BLOCK-y1)*p->frame_dec->linesize[0];
-        //FIXME optimize
-        for(y=0; y<height; y++){
-            for(x=0; x<width; x++){
-                p->temp[0][ x + y*p->temp_stride[0] ] += p->frame_dec->data[0][ x + y*p->frame_dec->linesize[0] + offset ];
-            }
-        }
-        offset= (BLOCK/2-x1/2) + (BLOCK/2-y1/2)*p->frame_dec->linesize[1];
-        for(y=0; y<height/2; y++){
-            for(x=0; x<width/2; x++){
-                p->temp[1][ x + y*p->temp_stride[1] ] += p->frame_dec->data[1][ x + y*p->frame_dec->linesize[1] + offset ];
-                p->temp[2][ x + y*p->temp_stride[2] ] += p->frame_dec->data[2][ x + y*p->frame_dec->linesize[2] + offset ];
-            }
-        }
-    }
-
-    for(j=0; j<3; j++){
-        int is_chroma= !!j;
-        if (!dst[j])
-            continue; // HACK avoid crash for Y8 colourspace
-        store_slice_c(dst[j], p->temp[j], dst_stride[j], p->temp_stride[j], width>>is_chroma, height>>is_chroma, 8-p->log2_count);
-    }
-}
-
-static int config(struct vf_instance *vf,
-        int width, int height, int d_width, int d_height,
-        unsigned int flags, unsigned int outfmt){
-        int i;
-        AVCodec *enc= avcodec_find_encoder(AV_CODEC_ID_SNOW);
-
-        for(i=0; i<3; i++){
-            int is_chroma= !!i;
-            int w= ((width  + 4*BLOCK-1) & (~(2*BLOCK-1)))>>is_chroma;
-            int h= ((height + 4*BLOCK-1) & (~(2*BLOCK-1)))>>is_chroma;
-
-            vf->priv->temp_stride[i]= w;
-            vf->priv->temp[i]= malloc(vf->priv->temp_stride[i]*h*sizeof(int16_t));
-            vf->priv->src [i]= malloc(vf->priv->temp_stride[i]*h*sizeof(uint8_t));
-        }
-        for(i=0; i< (1<<vf->priv->log2_count); i++){
-            AVCodecContext *avctx_enc;
-            AVDictionary *opts = NULL;
-
-            avctx_enc=
-            vf->priv->avctx_enc[i]= avcodec_alloc_context3(NULL);
-            avctx_enc->width = width + BLOCK;
-            avctx_enc->height = height + BLOCK;
-            avctx_enc->time_base= (AVRational){1,25};  // meaningless
-            avctx_enc->gop_size = 300;
-            avctx_enc->max_b_frames= 0;
-            avctx_enc->pix_fmt = AV_PIX_FMT_YUV420P;
-            avctx_enc->flags = CODEC_FLAG_QSCALE | CODEC_FLAG_LOW_DELAY;
-            avctx_enc->strict_std_compliance = FF_COMPLIANCE_EXPERIMENTAL;
-            avctx_enc->global_quality= 123;
-            av_dict_set(&opts, "no_bitstream", "1", 0);
-            avcodec_open2(avctx_enc, enc, &opts);
-            av_dict_free(&opts);
-            assert(avctx_enc->codec);
-        }
-        vf->priv->frame= av_frame_alloc();
-        vf->priv->frame_dec= av_frame_alloc();
-
-        vf->priv->outbuf_size= (width + BLOCK)*(height + BLOCK)*10;
-        vf->priv->outbuf= malloc(vf->priv->outbuf_size);
-
-        return ff_vf_next_config(vf,width,height,d_width,d_height,flags,outfmt);
-}
-
-static void get_image(struct vf_instance *vf, mp_image_t *mpi){
-    if(mpi->flags&MP_IMGFLAG_PRESERVE) return; // don't change
-    // ok, we can do pp in-place (or pp disabled):
-    vf->dmpi=ff_vf_get_image(vf->next,mpi->imgfmt,
-        mpi->type, mpi->flags | MP_IMGFLAG_READABLE, mpi->width, mpi->height);
-    mpi->planes[0]=vf->dmpi->planes[0];
-    mpi->stride[0]=vf->dmpi->stride[0];
-    mpi->width=vf->dmpi->width;
-    if(mpi->flags&MP_IMGFLAG_PLANAR){
-        mpi->planes[1]=vf->dmpi->planes[1];
-        mpi->planes[2]=vf->dmpi->planes[2];
-        mpi->stride[1]=vf->dmpi->stride[1];
-        mpi->stride[2]=vf->dmpi->stride[2];
-    }
-    mpi->flags|=MP_IMGFLAG_DIRECT;
-}
-
-static int put_image(struct vf_instance *vf, mp_image_t *mpi, double pts){
-    mp_image_t *dmpi;
-
-    if(!(mpi->flags&MP_IMGFLAG_DIRECT)){
-        // no DR, so get a new image! hope we'll get DR buffer:
-        dmpi=ff_vf_get_image(vf->next,mpi->imgfmt,
-            MP_IMGTYPE_TEMP,
-            MP_IMGFLAG_ACCEPT_STRIDE|MP_IMGFLAG_PREFER_ALIGNED_STRIDE,
-            mpi->width,mpi->height);
-        ff_vf_clone_mpi_attributes(dmpi, mpi);
-    }else{
-        dmpi=vf->dmpi;
-    }
-
-    vf->priv->mpeg2= mpi->qscale_type;
-    if(vf->priv->log2_count || !(mpi->flags&MP_IMGFLAG_DIRECT)){
-        if(mpi->qscale || vf->priv->qp){
-            filter(vf->priv, dmpi->planes, mpi->planes, dmpi->stride, mpi->stride, mpi->w, mpi->h, mpi->qscale, mpi->qstride);
-        }else{
-            memcpy_pic(dmpi->planes[0], mpi->planes[0], mpi->w, mpi->h, dmpi->stride[0], mpi->stride[0]);
-            memcpy_pic(dmpi->planes[1], mpi->planes[1], mpi->w>>mpi->chroma_x_shift, mpi->h>>mpi->chroma_y_shift, dmpi->stride[1], mpi->stride[1]);
-            memcpy_pic(dmpi->planes[2], mpi->planes[2], mpi->w>>mpi->chroma_x_shift, mpi->h>>mpi->chroma_y_shift, dmpi->stride[2], mpi->stride[2]);
-        }
-    }
-
-#if HAVE_MMX
-    if(ff_gCpuCaps.hasMMX) __asm__ volatile ("emms\n\t");
-#endif
-#if HAVE_MMX2
-    if(ff_gCpuCaps.hasMMX2) __asm__ volatile ("sfence\n\t");
-#endif
-
-    return ff_vf_next_put_image(vf,dmpi, pts);
-}
-
-static void uninit(struct vf_instance *vf){
-    int i;
-    if(!vf->priv) return;
-
-    for(i=0; i<3; i++){
-        free(vf->priv->temp[i]);
-        vf->priv->temp[i]= NULL;
-        free(vf->priv->src[i]);
-        vf->priv->src[i]= NULL;
-    }
-    for(i=0; i<BLOCK*BLOCK; i++){
-        av_freep(&vf->priv->avctx_enc[i]);
-    }
-
-    free(vf->priv);
-    vf->priv=NULL;
-}
-
-//===========================================================================//
-static int query_format(struct vf_instance *vf, unsigned int fmt){
-    switch(fmt){
-        case IMGFMT_YV12:
-        case IMGFMT_I420:
-        case IMGFMT_IYUV:
-        case IMGFMT_Y800:
-        case IMGFMT_Y8:
-            return ff_vf_next_query_format(vf,fmt);
-    }
-    return 0;
-}
-
-static int control(struct vf_instance *vf, int request, void* data){
-    switch(request){
-    case VFCTRL_QUERY_MAX_PP_LEVEL:
-        return 8;
-    case VFCTRL_SET_PP_LEVEL:
-        vf->priv->log2_count= *((unsigned int*)data);
-        //FIXME we have to realloc a few things here
-        return CONTROL_TRUE;
-    }
-    return ff_vf_next_control(vf,request,data);
-}
-
-static int vf_open(vf_instance_t *vf, char *args){
-
-    int log2c=-1;
-
-    vf->config=config;
-    vf->put_image=put_image;
-    vf->get_image=get_image;
-    vf->query_format=query_format;
-    vf->uninit=uninit;
-    vf->control= control;
-    vf->priv=malloc(sizeof(struct vf_priv_s));
-    memset(vf->priv, 0, sizeof(struct vf_priv_s));
-
-    ff_init_avcodec();
-
-    vf->priv->log2_count= 4;
-
-    if (args) sscanf(args, "%d:%d:%d", &log2c, &vf->priv->qp, &vf->priv->mode);
-
-    if( log2c >=0 && log2c <=8 )
-        vf->priv->log2_count = log2c;
-
-    if(vf->priv->qp < 0)
-        vf->priv->qp = 0;
-
-// #if HAVE_MMX
-//     if(ff_gCpuCaps.hasMMX){
-//         store_slice= store_slice_mmx;
-//     }
-// #endif
-
-    return 1;
-}
-
-const vf_info_t ff_vf_info_uspp = {
-    "ultra simple/slow postprocess",
-    "uspp",
-    "Michael Niedermayer",
-    "",
-    vf_open,
-    NULL
-};
diff --git a/libavfilter/libmpcodecs/vfcap.h b/libavfilter/libmpcodecs/vfcap.h
deleted file mode 100644
index 611d642..0000000
--- a/libavfilter/libmpcodecs/vfcap.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/* VFCAP_* values: they are flags, returned by query_format():
- *
- * This file is part of MPlayer.
- *
- * MPlayer is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * MPlayer is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with MPlayer; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#ifndef MPLAYER_VFCAP_H
-#define MPLAYER_VFCAP_H
-
-// set, if the given colorspace is supported (with or without conversion)
-#define VFCAP_CSP_SUPPORTED 0x1
-// set, if the given colorspace is supported _without_ conversion
-#define VFCAP_CSP_SUPPORTED_BY_HW 0x2
-// set if the driver/filter can draw OSD
-#define VFCAP_OSD 0x4
-// set if the driver/filter can handle compressed SPU stream
-#define VFCAP_SPU 0x8
-// scaling up/down by hardware, or software:
-#define VFCAP_HWSCALE_UP 0x10
-#define VFCAP_HWSCALE_DOWN 0x20
-#define VFCAP_SWSCALE 0x40
-// driver/filter can do vertical flip (upside-down)
-#define VFCAP_FLIP 0x80
-
-// driver/hardware handles timing (blocking)
-#define VFCAP_TIMER 0x100
-// driver _always_ flip image upside-down (for ve_vfw)
-#define VFCAP_FLIPPED 0x200
-// vf filter: accepts stride (put_image)
-// vo driver: has draw_slice() support for the given csp
-#define VFCAP_ACCEPT_STRIDE 0x400
-// filter does postprocessing (so you shouldn't scale/filter image before it)
-#define VFCAP_POSTPROC 0x800
-// filter cannot be reconfigured to different size & format
-#define VFCAP_CONSTANT 0x1000
-// filter can draw EOSD
-#define VFCAP_EOSD 0x2000
-// filter will draw EOSD at screen resolution (without scaling)
-#define VFCAP_EOSD_UNSCALED 0x4000
-// used by libvo and vf_vo, indicates the VO does not support draw_slice for this format
-#define VOCAP_NOSLICES 0x8000
-
-#endif /* MPLAYER_VFCAP_H */
diff --git a/libavfilter/vf_blackframe.c b/libavfilter/vf_blackframe.c
deleted file mode 100644
index 9b0c973..0000000
--- a/libavfilter/vf_blackframe.c
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * Copyright (c) 2010 Stefano Sabatini
- * Copyright (c) 2006 Ivo van Poorten
- * Copyright (c) 2006 Julian Hall
- * Copyright (c) 2002-2003 Brian J. Murrell
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with FFmpeg; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-/**
- * @file
- * Search for black frames to detect scene transitions.
- * Ported from MPlayer libmpcodecs/vf_blackframe.c.
- */
-
-#include <stdio.h>
-#include <inttypes.h>
-
-#include "libavutil/internal.h"
-#include "libavutil/opt.h"
-#include "avfilter.h"
-#include "formats.h"
-#include "internal.h"
-#include "video.h"
-
-typedef struct {
-    const AVClass *class;
-    int bamount;          ///< black amount
-    int bthresh;          ///< black threshold
-    unsigned int frame;   ///< frame number
-    unsigned int nblack;  ///< number of black pixels counted so far
-    unsigned int last_keyframe; ///< frame number of the last received key-frame
-} BlackFrameContext;
-
-static int query_formats(AVFilterContext *ctx)
-{
-    static const enum AVPixelFormat pix_fmts[] = {
-        AV_PIX_FMT_YUV410P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_GRAY8, AV_PIX_FMT_NV12,
-        AV_PIX_FMT_NV21, AV_PIX_FMT_YUV444P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV411P,
-        AV_PIX_FMT_NONE
-    };
-
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-    return 0;
-}
-
-static int filter_frame(AVFilterLink *inlink, AVFrame *frame)
-{
-    AVFilterContext *ctx = inlink->dst;
-    BlackFrameContext *s = ctx->priv;
-    int x, i;
-    int pblack = 0;
-    uint8_t *p = frame->data[0];
-
-    for (i = 0; i < frame->height; i++) {
-        for (x = 0; x < inlink->w; x++)
-            s->nblack += p[x] < s->bthresh;
-        p += frame->linesize[0];
-    }
-
-    if (frame->key_frame)
-        s->last_keyframe = s->frame;
-
-    pblack = s->nblack * 100 / (inlink->w * inlink->h);
-    if (pblack >= s->bamount)
-        av_log(ctx, AV_LOG_INFO, "frame:%u pblack:%u pts:%"PRId64" t:%f "
-               "type:%c last_keyframe:%d\n",
-               s->frame, pblack, frame->pts,
-               frame->pts == AV_NOPTS_VALUE ? -1 : frame->pts * av_q2d(inlink->time_base),
-               av_get_picture_type_char(frame->pict_type), s->last_keyframe);
-
-    s->frame++;
-    s->nblack = 0;
-    return ff_filter_frame(inlink->dst->outputs[0], frame);
-}
-
-#define OFFSET(x) offsetof(BlackFrameContext, x)
-#define FLAGS AV_OPT_FLAG_VIDEO_PARAM|AV_OPT_FLAG_FILTERING_PARAM
-static const AVOption blackframe_options[] = {
-    { "amount", "Percentage of the pixels that have to be below the threshold "
-        "for the frame to be considered black.", OFFSET(bamount), AV_OPT_TYPE_INT, { .i64 = 98 }, 0, 100,     FLAGS },
-    { "threshold", "threshold below which a pixel value is considered black",
-                                                 OFFSET(bthresh), AV_OPT_TYPE_INT, { .i64 = 32 }, 0, 255,     FLAGS },
-    { "thresh", "threshold below which a pixel value is considered black",
-                                                 OFFSET(bthresh), AV_OPT_TYPE_INT, { .i64 = 32 }, 0, 255,     FLAGS },
-    { NULL }
-};
-
-AVFILTER_DEFINE_CLASS(blackframe);
-
-static const AVFilterPad avfilter_vf_blackframe_inputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .filter_frame = filter_frame,
-    },
-    { NULL }
-};
-
-static const AVFilterPad avfilter_vf_blackframe_outputs[] = {
-    {
-        .name = "default",
-        .type = AVMEDIA_TYPE_VIDEO
-    },
-    { NULL }
-};
-
-AVFilter ff_vf_blackframe = {
-    .name          = "blackframe",
-    .description   = NULL_IF_CONFIG_SMALL("Detect frames that are (almost) black."),
-    .priv_size     = sizeof(BlackFrameContext),
-    .priv_class    = &blackframe_class,
-    .query_formats = query_formats,
-    .inputs        = avfilter_vf_blackframe_inputs,
-    .outputs       = avfilter_vf_blackframe_outputs,
-};
diff --git a/libavfilter/vf_boxblur.c b/libavfilter/vf_boxblur.c
deleted file mode 100644
index 3183f43..0000000
--- a/libavfilter/vf_boxblur.c
+++ /dev/null
@@ -1,386 +0,0 @@
-/*
- * Copyright (c) 2002 Michael Niedermayer <michaelni@gmx.at>
- * Copyright (c) 2011 Stefano Sabatini
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with FFmpeg; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-/**
- * @file
- * Apply a boxblur filter to the input video.
- * Ported from MPlayer libmpcodecs/vf_boxblur.c.
- */
-
-#include "libavutil/avstring.h"
-#include "libavutil/common.h"
-#include "libavutil/eval.h"
-#include "libavutil/opt.h"
-#include "libavutil/pixdesc.h"
-#include "avfilter.h"
-#include "formats.h"
-#include "internal.h"
-#include "video.h"
-
-static const char *const var_names[] = {
-    "w",
-    "h",
-    "cw",
-    "ch",
-    "hsub",
-    "vsub",
-    NULL
-};
-
-enum var_name {
-    VAR_W,
-    VAR_H,
-    VAR_CW,
-    VAR_CH,
-    VAR_HSUB,
-    VAR_VSUB,
-    VARS_NB
-};
-
-typedef struct {
-    int radius;
-    int power;
-    char *radius_expr;
-} FilterParam;
-
-typedef struct {
-    const AVClass *class;
-    FilterParam luma_param;
-    FilterParam chroma_param;
-    FilterParam alpha_param;
-
-    int hsub, vsub;
-    int radius[4];
-    int power[4];
-    uint8_t *temp[2]; ///< temporary buffer used in blur_power()
-} BoxBlurContext;
-
-#define Y 0
-#define U 1
-#define V 2
-#define A 3
-
-static av_cold int init(AVFilterContext *ctx)
-{
-    BoxBlurContext *s = ctx->priv;
-
-    if (!s->luma_param.radius_expr) {
-        av_log(ctx, AV_LOG_ERROR, "Luma radius expression is not set.\n");
-        return AVERROR(EINVAL);
-    }
-
-    /* fill missing params */
-    if (!s->chroma_param.radius_expr) {
-        s->chroma_param.radius_expr = av_strdup(s->luma_param.radius_expr);
-        if (!s->chroma_param.radius_expr)
-            return AVERROR(ENOMEM);
-    }
-    if (s->chroma_param.power < 0)
-        s->chroma_param.power = s->luma_param.power;
-
-    if (!s->alpha_param.radius_expr) {
-        s->alpha_param.radius_expr = av_strdup(s->luma_param.radius_expr);
-        if (!s->alpha_param.radius_expr)
-            return AVERROR(ENOMEM);
-    }
-    if (s->alpha_param.power < 0)
-        s->alpha_param.power = s->luma_param.power;
-
-    return 0;
-}
-
-static av_cold void uninit(AVFilterContext *ctx)
-{
-    BoxBlurContext *s = ctx->priv;
-
-    av_freep(&s->temp[0]);
-    av_freep(&s->temp[1]);
-}
-
-static int query_formats(AVFilterContext *ctx)
-{
-    static const enum AVPixelFormat pix_fmts[] = {
-        AV_PIX_FMT_YUV444P,  AV_PIX_FMT_YUV422P,  AV_PIX_FMT_YUV420P,
-        AV_PIX_FMT_YUV411P,  AV_PIX_FMT_YUV410P,  AV_PIX_FMT_YUVA420P,
-        AV_PIX_FMT_YUV440P,  AV_PIX_FMT_GRAY8,
-        AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ420P,
-        AV_PIX_FMT_YUVJ440P,
-        AV_PIX_FMT_NONE
-    };
-
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-    return 0;
-}
-
-static int config_input(AVFilterLink *inlink)
-{
-    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);
-    AVFilterContext    *ctx = inlink->dst;
-    BoxBlurContext *s = ctx->priv;
-    int w = inlink->w, h = inlink->h;
-    int cw, ch;
-    double var_values[VARS_NB], res;
-    char *expr;
-    int ret;
-
-    if (!(s->temp[0] = av_malloc(FFMAX(w, h))) ||
-        !(s->temp[1] = av_malloc(FFMAX(w, h))))
-        return AVERROR(ENOMEM);
-
-    s->hsub = desc->log2_chroma_w;
-    s->vsub = desc->log2_chroma_h;
-
-    var_values[VAR_W]       = inlink->w;
-    var_values[VAR_H]       = inlink->h;
-    var_values[VAR_CW] = cw = w>>s->hsub;
-    var_values[VAR_CH] = ch = h>>s->vsub;
-    var_values[VAR_HSUB]    = 1<<s->hsub;
-    var_values[VAR_VSUB]    = 1<<s->vsub;
-
-#define EVAL_RADIUS_EXPR(comp)                                          \
-    expr = s->comp##_param.radius_expr;                                 \
-    ret = av_expr_parse_and_eval(&res, expr, var_names, var_values,     \
-                                 NULL, NULL, NULL, NULL, NULL, 0, ctx); \
-    s->comp##_param.radius = res;                                       \
-    if (ret < 0) {                                                      \
-        av_log(NULL, AV_LOG_ERROR,                                      \
-               "Error when evaluating " #comp " radius expression '%s'\n", expr); \
-        return ret;                                                     \
-    }
-    EVAL_RADIUS_EXPR(luma);
-    EVAL_RADIUS_EXPR(chroma);
-    EVAL_RADIUS_EXPR(alpha);
-
-    av_log(ctx, AV_LOG_VERBOSE,
-           "luma_radius:%d luma_power:%d "
-           "chroma_radius:%d chroma_power:%d "
-           "alpha_radius:%d alpha_power:%d "
-           "w:%d chroma_w:%d h:%d chroma_h:%d\n",
-           s->luma_param  .radius, s->luma_param  .power,
-           s->chroma_param.radius, s->chroma_param.power,
-           s->alpha_param .radius, s->alpha_param .power,
-           w, cw, h, ch);
-
-#define CHECK_RADIUS_VAL(w_, h_, comp)                                  \
-    if (s->comp##_param.radius < 0 ||                                   \
-        2*s->comp##_param.radius > FFMIN(w_, h_)) {                     \
-        av_log(ctx, AV_LOG_ERROR,                                       \
-               "Invalid " #comp " radius value %d, must be >= 0 and <= %d\n", \
-               s->comp##_param.radius, FFMIN(w_, h_)/2);                \
-        return AVERROR(EINVAL);                                         \
-    }
-    CHECK_RADIUS_VAL(w,  h,  luma);
-    CHECK_RADIUS_VAL(cw, ch, chroma);
-    CHECK_RADIUS_VAL(w,  h,  alpha);
-
-    s->radius[Y] = s->luma_param.radius;
-    s->radius[U] = s->radius[V] = s->chroma_param.radius;
-    s->radius[A] = s->alpha_param.radius;
-
-    s->power[Y] = s->luma_param.power;
-    s->power[U] = s->power[V] = s->chroma_param.power;
-    s->power[A] = s->alpha_param.power;
-
-    return 0;
-}
-
-static inline void blur(uint8_t *dst, int dst_step, const uint8_t *src, int src_step,
-                        int len, int radius)
-{
-    /* Naive boxblur would sum source pixels from x-radius .. x+radius
-     * for destination pixel x. That would be O(radius*width).
-     * If you now look at what source pixels represent 2 consecutive
-     * output pixels, then you see they are almost identical and only
-     * differ by 2 pixels, like:
-     * src0       111111111
-     * dst0           1
-     * src1        111111111
-     * dst1            1
-     * src0-src1  1       -1
-     * so when you know one output pixel you can find the next by just adding
-     * and subtracting 1 input pixel.
-     * The following code adopts this faster variant.
-     */
-    const int length = radius*2 + 1;
-    const int inv = ((1<<16) + length/2)/length;
-    int x, sum = 0;
-
-    for (x = 0; x < radius; x++)
-        sum += src[x*src_step]<<1;
-    sum += src[radius*src_step];
-
-    for (x = 0; x <= radius; x++) {
-        sum += src[(radius+x)*src_step] - src[(radius-x)*src_step];
-        dst[x*dst_step] = (sum*inv + (1<<15))>>16;
-    }
-
-    for (; x < len-radius; x++) {
-        sum += src[(radius+x)*src_step] - src[(x-radius-1)*src_step];
-        dst[x*dst_step] = (sum*inv + (1<<15))>>16;
-    }
-
-    for (; x < len; x++) {
-        sum += src[(2*len-radius-x-1)*src_step] - src[(x-radius-1)*src_step];
-        dst[x*dst_step] = (sum*inv + (1<<15))>>16;
-    }
-}
-
-static inline void blur_power(uint8_t *dst, int dst_step, const uint8_t *src, int src_step,
-                              int len, int radius, int power, uint8_t *temp[2])
-{
-    uint8_t *a = temp[0], *b = temp[1];
-
-    if (radius && power) {
-        blur(a, 1, src, src_step, len, radius);
-        for (; power > 2; power--) {
-            uint8_t *c;
-            blur(b, 1, a, 1, len, radius);
-            c = a; a = b; b = c;
-        }
-        if (power > 1) {
-            blur(dst, dst_step, a, 1, len, radius);
-        } else {
-            int i;
-            for (i = 0; i < len; i++)
-                dst[i*dst_step] = a[i];
-        }
-    } else {
-        int i;
-        for (i = 0; i < len; i++)
-            dst[i*dst_step] = src[i*src_step];
-    }
-}
-
-static void hblur(uint8_t *dst, int dst_linesize, const uint8_t *src, int src_linesize,
-                  int w, int h, int radius, int power, uint8_t *temp[2])
-{
-    int y;
-
-    if (radius == 0 && dst == src)
-        return;
-
-    for (y = 0; y < h; y++)
-        blur_power(dst + y*dst_linesize, 1, src + y*src_linesize, 1,
-                   w, radius, power, temp);
-}
-
-static void vblur(uint8_t *dst, int dst_linesize, const uint8_t *src, int src_linesize,
-                  int w, int h, int radius, int power, uint8_t *temp[2])
-{
-    int x;
-
-    if (radius == 0 && dst == src)
-        return;
-
-    for (x = 0; x < w; x++)
-        blur_power(dst + x, dst_linesize, src + x, src_linesize,
-                   h, radius, power, temp);
-}
-
-static int filter_frame(AVFilterLink *inlink, AVFrame *in)
-{
-    AVFilterContext *ctx = inlink->dst;
-    BoxBlurContext *s = ctx->priv;
-    AVFilterLink *outlink = inlink->dst->outputs[0];
-    AVFrame *out;
-    int plane;
-    int cw = FF_CEIL_RSHIFT(inlink->w, s->hsub), ch = FF_CEIL_RSHIFT(in->height, s->vsub);
-    int w[4] = { inlink->w, cw, cw, inlink->w };
-    int h[4] = { in->height, ch, ch, in->height };
-
-    out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
-    if (!out) {
-        av_frame_free(&in);
-        return AVERROR(ENOMEM);
-    }
-    av_frame_copy_props(out, in);
-
-    for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)
-        hblur(out->data[plane], out->linesize[plane],
-              in ->data[plane], in ->linesize[plane],
-              w[plane], h[plane], s->radius[plane], s->power[plane],
-              s->temp);
-
-    for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)
-        vblur(out->data[plane], out->linesize[plane],
-              out->data[plane], out->linesize[plane],
-              w[plane], h[plane], s->radius[plane], s->power[plane],
-              s->temp);
-
-    av_frame_free(&in);
-
-    return ff_filter_frame(outlink, out);
-}
-
-#define OFFSET(x) offsetof(BoxBlurContext, x)
-#define FLAGS AV_OPT_FLAG_VIDEO_PARAM|AV_OPT_FLAG_FILTERING_PARAM
-
-static const AVOption boxblur_options[] = {
-    { "luma_radius", "Radius of the luma blurring box", OFFSET(luma_param.radius_expr), AV_OPT_TYPE_STRING, {.str="2"}, .flags = FLAGS },
-    { "lr",          "Radius of the luma blurring box", OFFSET(luma_param.radius_expr), AV_OPT_TYPE_STRING, {.str="2"}, .flags = FLAGS },
-    { "luma_power",  "How many times should the boxblur be applied to luma",  OFFSET(luma_param.power), AV_OPT_TYPE_INT, {.i64=2}, 0, INT_MAX, .flags = FLAGS },
-    { "lp",          "How many times should the boxblur be applied to luma",  OFFSET(luma_param.power), AV_OPT_TYPE_INT, {.i64=2}, 0, INT_MAX, .flags = FLAGS },
-
-    { "chroma_radius", "Radius of the chroma blurring box", OFFSET(chroma_param.radius_expr), AV_OPT_TYPE_STRING, {.str=NULL}, .flags = FLAGS },
-    { "cr",            "Radius of the chroma blurring box", OFFSET(chroma_param.radius_expr), AV_OPT_TYPE_STRING, {.str=NULL}, .flags = FLAGS },
-    { "chroma_power",  "How many times should the boxblur be applied to chroma",  OFFSET(chroma_param.power), AV_OPT_TYPE_INT, {.i64=-1}, -1, INT_MAX, .flags = FLAGS },
-    { "cp",            "How many times should the boxblur be applied to chroma",  OFFSET(chroma_param.power), AV_OPT_TYPE_INT, {.i64=-1}, -1, INT_MAX, .flags = FLAGS },
-
-    { "alpha_radius", "Radius of the alpha blurring box", OFFSET(alpha_param.radius_expr), AV_OPT_TYPE_STRING, {.str=NULL}, .flags = FLAGS },
-    { "ar",           "Radius of the alpha blurring box", OFFSET(alpha_param.radius_expr), AV_OPT_TYPE_STRING, {.str=NULL}, .flags = FLAGS },
-    { "alpha_power",  "How many times should the boxblur be applied to alpha",  OFFSET(alpha_param.power), AV_OPT_TYPE_INT, {.i64=-1}, -1, INT_MAX, .flags = FLAGS },
-    { "ap",           "How many times should the boxblur be applied to alpha",  OFFSET(alpha_param.power), AV_OPT_TYPE_INT, {.i64=-1}, -1, INT_MAX, .flags = FLAGS },
-
-    { NULL }
-};
-
-AVFILTER_DEFINE_CLASS(boxblur);
-
-static const AVFilterPad avfilter_vf_boxblur_inputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .config_props = config_input,
-        .filter_frame = filter_frame,
-    },
-    { NULL }
-};
-
-static const AVFilterPad avfilter_vf_boxblur_outputs[] = {
-    {
-        .name = "default",
-        .type = AVMEDIA_TYPE_VIDEO,
-    },
-    { NULL }
-};
-
-AVFilter ff_vf_boxblur = {
-    .name          = "boxblur",
-    .description   = NULL_IF_CONFIG_SMALL("Blur the input."),
-    .priv_size     = sizeof(BoxBlurContext),
-    .priv_class    = &boxblur_class,
-    .init          = init,
-    .uninit        = uninit,
-    .query_formats = query_formats,
-    .inputs        = avfilter_vf_boxblur_inputs,
-    .outputs       = avfilter_vf_boxblur_outputs,
-    .flags         = AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC,
-};
diff --git a/libavfilter/vf_colormatrix.c b/libavfilter/vf_colormatrix.c
deleted file mode 100644
index 43654ae..0000000
--- a/libavfilter/vf_colormatrix.c
+++ /dev/null
@@ -1,410 +0,0 @@
-/*
- * ColorMatrix v2.2 for Avisynth 2.5.x
- *
- * Copyright (C) 2006-2007 Kevin Stone
- *
- * ColorMatrix 1.x is Copyright (C) Wilbert Dijkhof
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * OUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
- * License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * ColorMatrix 2.0 is based on the original ColorMatrix filter by Wilbert
- * Dijkhof.  It adds the ability to convert between any of: Rec.709, FCC,
- * Rec.601, and SMPTE 240M. It also makes pre and post clipping optional,
- * adds an option to use scaled or non-scaled coefficients, and more...
- */
-
-#include <float.h>
-#include "avfilter.h"
-#include "formats.h"
-#include "internal.h"
-#include "video.h"
-#include "libavutil/opt.h"
-#include "libavutil/pixdesc.h"
-#include "libavutil/avstring.h"
-
-#define NS(n) n < 0 ? (int)(n*65536.0-0.5+DBL_EPSILON) : (int)(n*65536.0+0.5)
-#define CB(n) av_clip_uint8(n)
-
-static const double yuv_coeff[4][3][3] = {
-    { { +0.7152, +0.0722, +0.2126 }, // Rec.709 (0)
-      { -0.3850, +0.5000, -0.1150 },
-      { -0.4540, -0.0460, +0.5000 } },
-    { { +0.5900, +0.1100, +0.3000 }, // FCC (1)
-      { -0.3310, +0.5000, -0.1690 },
-      { -0.4210, -0.0790, +0.5000 } },
-    { { +0.5870, +0.1140, +0.2990 }, // Rec.601 (ITU-R BT.470-2/SMPTE 170M) (2)
-      { -0.3313, +0.5000, -0.1687 },
-      { -0.4187, -0.0813, +0.5000 } },
-    { { +0.7010, +0.0870, +0.2120 }, // SMPTE 240M (3)
-      { -0.3840, +0.5000, -0.1160 },
-      { -0.4450, -0.0550, +0.5000 } },
-};
-
-enum ColorMode {
-    COLOR_MODE_NONE = -1,
-    COLOR_MODE_BT709,
-    COLOR_MODE_FCC,
-    COLOR_MODE_BT601,
-    COLOR_MODE_SMPTE240M,
-    COLOR_MODE_COUNT
-};
-
-typedef struct {
-    const AVClass *class;
-    int yuv_convert[16][3][3];
-    int interlaced;
-    enum ColorMode source, dest;
-    int mode;
-    int hsub, vsub;
-} ColorMatrixContext;
-
-#define OFFSET(x) offsetof(ColorMatrixContext, x)
-#define FLAGS AV_OPT_FLAG_VIDEO_PARAM|AV_OPT_FLAG_FILTERING_PARAM
-
-static const AVOption colormatrix_options[] = {
-    { "src", "set source color matrix",      OFFSET(source), AV_OPT_TYPE_INT, {.i64=COLOR_MODE_NONE}, COLOR_MODE_NONE, COLOR_MODE_COUNT-1, .flags=FLAGS, .unit="color_mode" },
-    { "dst", "set destination color matrix", OFFSET(dest),   AV_OPT_TYPE_INT, {.i64=COLOR_MODE_NONE}, COLOR_MODE_NONE, COLOR_MODE_COUNT-1, .flags=FLAGS, .unit="color_mode" },
-    { "bt709",     "set BT.709 colorspace",      0, AV_OPT_TYPE_CONST, {.i64=COLOR_MODE_BT709},       .flags=FLAGS, .unit="color_mode" },
-    { "fcc",       "set FCC colorspace   ",      0, AV_OPT_TYPE_CONST, {.i64=COLOR_MODE_FCC},         .flags=FLAGS, .unit="color_mode" },
-    { "bt601",     "set BT.601 colorspace",      0, AV_OPT_TYPE_CONST, {.i64=COLOR_MODE_BT601},       .flags=FLAGS, .unit="color_mode" },
-    { "smpte240m", "set SMPTE-240M colorspace",  0, AV_OPT_TYPE_CONST, {.i64=COLOR_MODE_SMPTE240M},   .flags=FLAGS, .unit="color_mode" },
-    { NULL }
-};
-
-AVFILTER_DEFINE_CLASS(colormatrix);
-
-#define ma m[0][0]
-#define mb m[0][1]
-#define mc m[0][2]
-#define md m[1][0]
-#define me m[1][1]
-#define mf m[1][2]
-#define mg m[2][0]
-#define mh m[2][1]
-#define mi m[2][2]
-
-#define ima im[0][0]
-#define imb im[0][1]
-#define imc im[0][2]
-#define imd im[1][0]
-#define ime im[1][1]
-#define imf im[1][2]
-#define img im[2][0]
-#define imh im[2][1]
-#define imi im[2][2]
-
-static void inverse3x3(double im[3][3], const double m[3][3])
-{
-    double det = ma * (me * mi - mf * mh) - mb * (md * mi - mf * mg) + mc * (md * mh - me * mg);
-    det = 1.0 / det;
-    ima = det * (me * mi - mf * mh);
-    imb = det * (mc * mh - mb * mi);
-    imc = det * (mb * mf - mc * me);
-    imd = det * (mf * mg - md * mi);
-    ime = det * (ma * mi - mc * mg);
-    imf = det * (mc * md - ma * mf);
-    img = det * (md * mh - me * mg);
-    imh = det * (mb * mg - ma * mh);
-    imi = det * (ma * me - mb * md);
-}
-
-static void solve_coefficients(double cm[3][3], double rgb[3][3], const double yuv[3][3])
-{
-    int i, j;
-    for (i = 0; i < 3; i++)
-        for (j = 0; j < 3; j++)
-            cm[i][j] = yuv[i][0] * rgb[0][j] + yuv[i][1] * rgb[1][j] + yuv[i][2] * rgb[2][j];
-}
-
-static void calc_coefficients(AVFilterContext *ctx)
-{
-    ColorMatrixContext *color = ctx->priv;
-    double rgb_coeffd[4][3][3];
-    double yuv_convertd[16][3][3];
-    int v = 0;
-    int i, j, k;
-
-    for (i = 0; i < 4; i++)
-        inverse3x3(rgb_coeffd[i], yuv_coeff[i]);
-    for (i = 0; i < 4; i++) {
-        for (j = 0; j < 4; j++) {
-            solve_coefficients(yuv_convertd[v], rgb_coeffd[i], yuv_coeff[j]);
-            for (k = 0; k < 3; k++) {
-                color->yuv_convert[v][k][0] = NS(yuv_convertd[v][k][0]);
-                color->yuv_convert[v][k][1] = NS(yuv_convertd[v][k][1]);
-                color->yuv_convert[v][k][2] = NS(yuv_convertd[v][k][2]);
-            }
-            if (color->yuv_convert[v][0][0] != 65536 || color->yuv_convert[v][1][0] != 0 ||
-                color->yuv_convert[v][2][0] != 0) {
-                av_log(ctx, AV_LOG_ERROR, "error calculating conversion coefficients\n");
-            }
-            v++;
-        }
-    }
-}
-
-static const char *color_modes[] = {"bt709", "fcc", "bt601", "smpte240m"};
-
-static av_cold int init(AVFilterContext *ctx)
-{
-    ColorMatrixContext *color = ctx->priv;
-
-    if (color->dest == COLOR_MODE_NONE) {
-        av_log(ctx, AV_LOG_ERROR, "Unspecified destination color space\n");
-        return AVERROR(EINVAL);
-    }
-
-    if (color->source == color->dest) {
-        av_log(ctx, AV_LOG_ERROR, "Source and destination color space must not be identical\n");
-        return AVERROR(EINVAL);
-    }
-
-    return 0;
-}
-
-static void process_frame_uyvy422(ColorMatrixContext *color,
-                                  AVFrame *dst, AVFrame *src)
-{
-    const unsigned char *srcp = src->data[0];
-    const int src_pitch = src->linesize[0];
-    const int height = src->height;
-    const int width = src->width*2;
-    unsigned char *dstp = dst->data[0];
-    const int dst_pitch = dst->linesize[0];
-    const int c2 = color->yuv_convert[color->mode][0][1];
-    const int c3 = color->yuv_convert[color->mode][0][2];
-    const int c4 = color->yuv_convert[color->mode][1][1];
-    const int c5 = color->yuv_convert[color->mode][1][2];
-    const int c6 = color->yuv_convert[color->mode][2][1];
-    const int c7 = color->yuv_convert[color->mode][2][2];
-    int x, y;
-
-    for (y = 0; y < height; y++) {
-        for (x = 0; x < width; x += 4) {
-            const int u = srcp[x + 0] - 128;
-            const int v = srcp[x + 2] - 128;
-            const int uvval = c2 * u + c3 * v + 1081344;
-            dstp[x + 0] = CB((c4 * u + c5 * v + 8421376) >> 16);
-            dstp[x + 1] = CB((65536 * (srcp[x + 1] - 16) + uvval) >> 16);
-            dstp[x + 2] = CB((c6 * u + c7 * v + 8421376) >> 16);
-            dstp[x + 3] = CB((65536 * (srcp[x + 3] - 16) + uvval) >> 16);
-        }
-        srcp += src_pitch;
-        dstp += dst_pitch;
-    }
-}
-
-static void process_frame_yuv422p(ColorMatrixContext *color,
-                                  AVFrame *dst, AVFrame *src)
-{
-    const unsigned char *srcpU = src->data[1];
-    const unsigned char *srcpV = src->data[2];
-    const unsigned char *srcpY = src->data[0];
-    const int src_pitchY  = src->linesize[0];
-    const int src_pitchUV = src->linesize[1];
-    const int height = src->height;
-    const int width = src->width;
-    unsigned char *dstpU = dst->data[1];
-    unsigned char *dstpV = dst->data[2];
-    unsigned char *dstpY = dst->data[0];
-    const int dst_pitchY  = dst->linesize[0];
-    const int dst_pitchUV = dst->linesize[1];
-    const int c2 = color->yuv_convert[color->mode][0][1];
-    const int c3 = color->yuv_convert[color->mode][0][2];
-    const int c4 = color->yuv_convert[color->mode][1][1];
-    const int c5 = color->yuv_convert[color->mode][1][2];
-    const int c6 = color->yuv_convert[color->mode][2][1];
-    const int c7 = color->yuv_convert[color->mode][2][2];
-    int x, y;
-
-    for (y = 0; y < height; y++) {
-        for (x = 0; x < width; x += 2) {
-            const int u = srcpU[x >> 1] - 128;
-            const int v = srcpV[x >> 1] - 128;
-            const int uvval = c2 * u + c3 * v + 1081344;
-            dstpY[x + 0] = CB((65536 * (srcpY[x + 0] - 16) + uvval) >> 16);
-            dstpY[x + 1] = CB((65536 * (srcpY[x + 1] - 16) + uvval) >> 16);
-            dstpU[x >> 1] = CB((c4 * u + c5 * v + 8421376) >> 16);
-            dstpV[x >> 1] = CB((c6 * u + c7 * v + 8421376) >> 16);
-        }
-        srcpY += src_pitchY;
-        dstpY += dst_pitchY;
-        srcpU += src_pitchUV;
-        srcpV += src_pitchUV;
-        dstpU += dst_pitchUV;
-        dstpV += dst_pitchUV;
-    }
-}
-
-static void process_frame_yuv420p(ColorMatrixContext *color,
-                                  AVFrame *dst, AVFrame *src)
-{
-    const unsigned char *srcpU = src->data[1];
-    const unsigned char *srcpV = src->data[2];
-    const unsigned char *srcpY = src->data[0];
-    const unsigned char *srcpN = src->data[0] + src->linesize[0];
-    const int src_pitchY  = src->linesize[0];
-    const int src_pitchUV = src->linesize[1];
-    const int height = src->height;
-    const int width = src->width;
-    unsigned char *dstpU = dst->data[1];
-    unsigned char *dstpV = dst->data[2];
-    unsigned char *dstpY = dst->data[0];
-    unsigned char *dstpN = dst->data[0] + dst->linesize[0];
-    const int dst_pitchY  = dst->linesize[0];
-    const int dst_pitchUV = dst->linesize[1];
-    const int c2 = color->yuv_convert[color->mode][0][1];
-    const int c3 = color->yuv_convert[color->mode][0][2];
-    const int c4 = color->yuv_convert[color->mode][1][1];
-    const int c5 = color->yuv_convert[color->mode][1][2];
-    const int c6 = color->yuv_convert[color->mode][2][1];
-    const int c7 = color->yuv_convert[color->mode][2][2];
-    int x, y;
-
-    for (y = 0; y < height; y += 2) {
-        for (x = 0; x < width; x += 2) {
-            const int u = srcpU[x >> 1] - 128;
-            const int v = srcpV[x >> 1] - 128;
-            const int uvval = c2 * u + c3 * v + 1081344;
-            dstpY[x + 0] = CB((65536 * (srcpY[x + 0] - 16) + uvval) >> 16);
-            dstpY[x + 1] = CB((65536 * (srcpY[x + 1] - 16) + uvval) >> 16);
-            dstpN[x + 0] = CB((65536 * (srcpN[x + 0] - 16) + uvval) >> 16);
-            dstpN[x + 1] = CB((65536 * (srcpN[x + 1] - 16) + uvval) >> 16);
-            dstpU[x >> 1] = CB((c4 * u + c5 * v + 8421376) >> 16);
-            dstpV[x >> 1] = CB((c6 * u + c7 * v + 8421376) >> 16);
-        }
-        srcpY += src_pitchY << 1;
-        dstpY += dst_pitchY << 1;
-        srcpN += src_pitchY << 1;
-        dstpN += dst_pitchY << 1;
-        srcpU += src_pitchUV;
-        srcpV += src_pitchUV;
-        dstpU += dst_pitchUV;
-        dstpV += dst_pitchUV;
-    }
-}
-
-static int config_input(AVFilterLink *inlink)
-{
-    AVFilterContext *ctx = inlink->dst;
-    ColorMatrixContext *color = ctx->priv;
-    const AVPixFmtDescriptor *pix_desc = av_pix_fmt_desc_get(inlink->format);
-
-    color->hsub = pix_desc->log2_chroma_w;
-    color->vsub = pix_desc->log2_chroma_h;
-
-    av_log(ctx, AV_LOG_VERBOSE, "%s -> %s\n",
-           color_modes[color->source], color_modes[color->dest]);
-
-    return 0;
-}
-
-static int query_formats(AVFilterContext *ctx)
-{
-    static const enum AVPixelFormat pix_fmts[] = {
-        AV_PIX_FMT_YUV422P,
-        AV_PIX_FMT_YUV420P,
-        AV_PIX_FMT_UYVY422,
-        AV_PIX_FMT_NONE
-    };
-
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-
-    return 0;
-}
-
-static int filter_frame(AVFilterLink *link, AVFrame *in)
-{
-    AVFilterContext *ctx = link->dst;
-    ColorMatrixContext *color = ctx->priv;
-    AVFilterLink *outlink = ctx->outputs[0];
-    AVFrame *out;
-
-    out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
-    if (!out) {
-        av_frame_free(&in);
-        return AVERROR(ENOMEM);
-    }
-    av_frame_copy_props(out, in);
-
-    if (color->source == COLOR_MODE_NONE) {
-        enum AVColorSpace cs = av_frame_get_colorspace(in);
-        enum ColorMode source;
-
-        switch(cs) {
-        case AVCOL_SPC_BT709     : source = COLOR_MODE_BT709     ; break;
-        case AVCOL_SPC_FCC       : source = COLOR_MODE_FCC       ; break;
-        case AVCOL_SPC_SMPTE240M : source = COLOR_MODE_SMPTE240M ; break;
-        case AVCOL_SPC_BT470BG   : source = COLOR_MODE_BT601     ; break;
-        default :
-            av_log(ctx, AV_LOG_ERROR, "Input frame does not specify a supported colorspace, and none has been specified as source either\n");
-            return AVERROR(EINVAL);
-        }
-        color->mode = source * 4 + color->dest;
-    } else
-        color->mode = color->source * 4 + color->dest;
-
-    switch(color->dest) {
-    case COLOR_MODE_BT709    : av_frame_set_colorspace(out, AVCOL_SPC_BT709)    ; break;
-    case COLOR_MODE_FCC      : av_frame_set_colorspace(out, AVCOL_SPC_FCC)      ; break;
-    case COLOR_MODE_SMPTE240M: av_frame_set_colorspace(out, AVCOL_SPC_SMPTE240M); break;
-    case COLOR_MODE_BT601    : av_frame_set_colorspace(out, AVCOL_SPC_BT470BG)  ; break;
-    }
-
-    calc_coefficients(ctx);
-
-    if (in->format == AV_PIX_FMT_YUV422P)
-        process_frame_yuv422p(color, out, in);
-    else if (in->format == AV_PIX_FMT_YUV420P)
-        process_frame_yuv420p(color, out, in);
-    else
-        process_frame_uyvy422(color, out, in);
-
-    av_frame_free(&in);
-    return ff_filter_frame(outlink, out);
-}
-
-static const AVFilterPad colormatrix_inputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .config_props = config_input,
-        .filter_frame = filter_frame,
-    },
-    { NULL }
-};
-
-static const AVFilterPad colormatrix_outputs[] = {
-    {
-        .name = "default",
-        .type = AVMEDIA_TYPE_VIDEO,
-    },
-    { NULL }
-};
-
-AVFilter ff_vf_colormatrix = {
-    .name          = "colormatrix",
-    .description   = NULL_IF_CONFIG_SMALL("Convert color matrix."),
-    .priv_size     = sizeof(ColorMatrixContext),
-    .init          = init,
-    .query_formats = query_formats,
-    .inputs        = colormatrix_inputs,
-    .outputs       = colormatrix_outputs,
-    .priv_class    = &colormatrix_class,
-    .flags         = AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC,
-};
diff --git a/libavfilter/vf_cropdetect.c b/libavfilter/vf_cropdetect.c
deleted file mode 100644
index 4a6b658..0000000
--- a/libavfilter/vf_cropdetect.c
+++ /dev/null
@@ -1,252 +0,0 @@
-/*
- * Copyright (c) 2002 A'rpi
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with FFmpeg; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-/**
- * @file
- * border detection filter
- * Ported from MPlayer libmpcodecs/vf_cropdetect.c.
- */
-
-#include "libavutil/imgutils.h"
-#include "libavutil/internal.h"
-#include "libavutil/opt.h"
-
-#include "avfilter.h"
-#include "formats.h"
-#include "internal.h"
-#include "video.h"
-
-typedef struct {
-    const AVClass *class;
-    int x1, y1, x2, y2;
-    int limit;
-    int round;
-    int reset_count;
-    int frame_nb;
-    int max_pixsteps[4];
-} CropDetectContext;
-
-static int query_formats(AVFilterContext *ctx)
-{
-    static const enum AVPixelFormat pix_fmts[] = {
-        AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUVJ420P,
-        AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUVJ422P,
-        AV_PIX_FMT_YUV444P, AV_PIX_FMT_YUVJ444P,
-        AV_PIX_FMT_YUV411P, AV_PIX_FMT_GRAY8,
-        AV_PIX_FMT_NV12,    AV_PIX_FMT_NV21,
-        AV_PIX_FMT_NONE
-    };
-
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-    return 0;
-}
-
-static int checkline(void *ctx, const unsigned char *src, int stride, int len, int bpp)
-{
-    int total = 0;
-    int div = len;
-
-    switch (bpp) {
-    case 1:
-        while (--len >= 0) {
-            total += src[0];
-            src += stride;
-        }
-        break;
-    case 3:
-    case 4:
-        while (--len >= 0) {
-            total += src[0] + src[1] + src[2];
-            src += stride;
-        }
-        div *= 3;
-        break;
-    }
-    total /= div;
-
-    av_log(ctx, AV_LOG_DEBUG, "total:%d\n", total);
-    return total;
-}
-
-static av_cold int init(AVFilterContext *ctx)
-{
-    CropDetectContext *s = ctx->priv;
-
-    s->frame_nb = -2;
-
-    av_log(ctx, AV_LOG_VERBOSE, "limit:%d round:%d reset_count:%d\n",
-           s->limit, s->round, s->reset_count);
-
-    return 0;
-}
-
-static int config_input(AVFilterLink *inlink)
-{
-    AVFilterContext *ctx = inlink->dst;
-    CropDetectContext *s = ctx->priv;
-
-    av_image_fill_max_pixsteps(s->max_pixsteps, NULL,
-                               av_pix_fmt_desc_get(inlink->format));
-
-    s->x1 = inlink->w - 1;
-    s->y1 = inlink->h - 1;
-    s->x2 = 0;
-    s->y2 = 0;
-
-    return 0;
-}
-
-#define SET_META(key, value) \
-    snprintf(buf, sizeof(buf), "%d", value);  \
-    av_dict_set(metadata, key, buf, 0)
-
-static int filter_frame(AVFilterLink *inlink, AVFrame *frame)
-{
-    AVFilterContext *ctx = inlink->dst;
-    CropDetectContext *s = ctx->priv;
-    int bpp = s->max_pixsteps[0];
-    int w, h, x, y, shrink_by;
-    AVDictionary **metadata;
-    char buf[32];
-
-    // ignore first 2 frames - they may be empty
-    if (++s->frame_nb > 0) {
-        metadata = avpriv_frame_get_metadatap(frame);
-
-        // Reset the crop area every reset_count frames, if reset_count is > 0
-        if (s->reset_count > 0 && s->frame_nb > s->reset_count) {
-            s->x1 = frame->width  - 1;
-            s->y1 = frame->height - 1;
-            s->x2 = 0;
-            s->y2 = 0;
-            s->frame_nb = 1;
-        }
-
-        for (y = 0; y < s->y1; y++) {
-            if (checkline(ctx, frame->data[0] + frame->linesize[0] * y, bpp, frame->width, bpp) > s->limit) {
-                s->y1 = y;
-                break;
-            }
-        }
-
-        for (y = frame->height - 1; y > s->y2; y--) {
-            if (checkline(ctx, frame->data[0] + frame->linesize[0] * y, bpp, frame->width, bpp) > s->limit) {
-                s->y2 = y;
-                break;
-            }
-        }
-
-        for (y = 0; y < s->x1; y++) {
-            if (checkline(ctx, frame->data[0] + bpp*y, frame->linesize[0], frame->height, bpp) > s->limit) {
-                s->x1 = y;
-                break;
-            }
-        }
-
-        for (y = frame->width - 1; y > s->x2; y--) {
-            if (checkline(ctx, frame->data[0] + bpp*y, frame->linesize[0], frame->height, bpp) > s->limit) {
-                s->x2 = y;
-                break;
-            }
-        }
-
-        // round x and y (up), important for yuv colorspaces
-        // make sure they stay rounded!
-        x = (s->x1+1) & ~1;
-        y = (s->y1+1) & ~1;
-
-        w = s->x2 - x + 1;
-        h = s->y2 - y + 1;
-
-        // w and h must be divisible by 2 as well because of yuv
-        // colorspace problems.
-        if (s->round <= 1)
-            s->round = 16;
-        if (s->round % 2)
-            s->round *= 2;
-
-        shrink_by = w % s->round;
-        w -= shrink_by;
-        x += (shrink_by/2 + 1) & ~1;
-
-        shrink_by = h % s->round;
-        h -= shrink_by;
-        y += (shrink_by/2 + 1) & ~1;
-
-        SET_META("lavfi.cropdetect.x1", s->x1);
-        SET_META("lavfi.cropdetect.x2", s->x2);
-        SET_META("lavfi.cropdetect.y1", s->y1);
-        SET_META("lavfi.cropdetect.y2", s->y2);
-        SET_META("lavfi.cropdetect.w",  w);
-        SET_META("lavfi.cropdetect.h",  h);
-        SET_META("lavfi.cropdetect.x",  x);
-        SET_META("lavfi.cropdetect.y",  y);
-
-        av_log(ctx, AV_LOG_INFO,
-               "x1:%d x2:%d y1:%d y2:%d w:%d h:%d x:%d y:%d pts:%"PRId64" t:%f crop=%d:%d:%d:%d\n",
-               s->x1, s->x2, s->y1, s->y2, w, h, x, y, frame->pts,
-               frame->pts == AV_NOPTS_VALUE ? -1 : frame->pts * av_q2d(inlink->time_base),
-               w, h, x, y);
-    }
-
-    return ff_filter_frame(inlink->dst->outputs[0], frame);
-}
-
-#define OFFSET(x) offsetof(CropDetectContext, x)
-#define FLAGS AV_OPT_FLAG_VIDEO_PARAM|AV_OPT_FLAG_FILTERING_PARAM
-
-static const AVOption cropdetect_options[] = {
-    { "limit", "Threshold below which the pixel is considered black", OFFSET(limit),       AV_OPT_TYPE_INT, { .i64 = 24 }, 0, 255, FLAGS },
-    { "round", "Value by which the width/height should be divisible", OFFSET(round),       AV_OPT_TYPE_INT, { .i64 = 16 }, 0, INT_MAX, FLAGS },
-    { "reset", "Recalculate the crop area after this many frames",    OFFSET(reset_count), AV_OPT_TYPE_INT, { .i64 = 0 },  0, INT_MAX, FLAGS },
-    { "reset_count", "Recalculate the crop area after this many frames",OFFSET(reset_count),AV_OPT_TYPE_INT,{ .i64 = 0 },  0, INT_MAX, FLAGS },
-    { NULL }
-};
-
-AVFILTER_DEFINE_CLASS(cropdetect);
-
-static const AVFilterPad avfilter_vf_cropdetect_inputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .config_props = config_input,
-        .filter_frame = filter_frame,
-    },
-    { NULL }
-};
-
-static const AVFilterPad avfilter_vf_cropdetect_outputs[] = {
-    {
-        .name = "default",
-        .type = AVMEDIA_TYPE_VIDEO
-    },
-    { NULL }
-};
-
-AVFilter ff_vf_cropdetect = {
-    .name          = "cropdetect",
-    .description   = NULL_IF_CONFIG_SMALL("Auto-detect crop size."),
-    .priv_size     = sizeof(CropDetectContext),
-    .priv_class    = &cropdetect_class,
-    .init          = init,
-    .query_formats = query_formats,
-    .inputs        = avfilter_vf_cropdetect_inputs,
-    .outputs       = avfilter_vf_cropdetect_outputs,
-    .flags         = AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC,
-};
diff --git a/libavfilter/vf_decimate.c b/libavfilter/vf_decimate.c
deleted file mode 100644
index 5efafe9..0000000
--- a/libavfilter/vf_decimate.c
+++ /dev/null
@@ -1,403 +0,0 @@
-/*
- * Copyright (c) 2012 Fredrik Mellbin
- * Copyright (c) 2013 Clment Bsch
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include "libavutil/opt.h"
-#include "libavutil/pixdesc.h"
-#include "libavutil/timestamp.h"
-#include "avfilter.h"
-#include "internal.h"
-
-#define INPUT_MAIN     0
-#define INPUT_CLEANSRC 1
-
-struct qitem {
-    AVFrame *frame;
-    int64_t maxbdiff;
-    int64_t totdiff;
-};
-
-typedef struct {
-    const AVClass *class;
-    struct qitem *queue;    ///< window of cycle frames and the associated data diff
-    int fid;                ///< current frame id in the queue
-    int filled;             ///< 1 if the queue is filled, 0 otherwise
-    AVFrame *last;          ///< last frame from the previous queue
-    AVFrame **clean_src;    ///< frame queue for the clean source
-    int got_frame[2];       ///< frame request flag for each input stream
-    double ts_unit;         ///< timestamp units for the output frames
-    int64_t start_pts;      ///< base for output timestamps
-    uint32_t eof;           ///< bitmask for end of stream
-    int hsub, vsub;         ///< chroma subsampling values
-    int depth;
-    int nxblocks, nyblocks;
-    int bdiffsize;
-    int64_t *bdiffs;
-
-    /* options */
-    int cycle;
-    double dupthresh_flt;
-    double scthresh_flt;
-    int64_t dupthresh;
-    int64_t scthresh;
-    int blockx, blocky;
-    int ppsrc;
-    int chroma;
-} DecimateContext;
-
-#define OFFSET(x) offsetof(DecimateContext, x)
-#define FLAGS AV_OPT_FLAG_VIDEO_PARAM|AV_OPT_FLAG_FILTERING_PARAM
-
-static const AVOption decimate_options[] = {
-    { "cycle",     "set the number of frame from which one will be dropped", OFFSET(cycle), AV_OPT_TYPE_INT, {.i64 = 5}, 2, 25, FLAGS },
-    { "dupthresh", "set duplicate threshold",    OFFSET(dupthresh_flt), AV_OPT_TYPE_DOUBLE, {.dbl =  1.1}, 0, 100, FLAGS },
-    { "scthresh",  "set scene change threshold", OFFSET(scthresh_flt),  AV_OPT_TYPE_DOUBLE, {.dbl = 15.0}, 0, 100, FLAGS },
-    { "blockx",    "set the size of the x-axis blocks used during metric calculations", OFFSET(blockx), AV_OPT_TYPE_INT, {.i64 = 32}, 4, 1<<9, FLAGS },
-    { "blocky",    "set the size of the y-axis blocks used during metric calculations", OFFSET(blocky), AV_OPT_TYPE_INT, {.i64 = 32}, 4, 1<<9, FLAGS },
-    { "ppsrc",     "mark main input as a pre-processed input and activate clean source input stream", OFFSET(ppsrc), AV_OPT_TYPE_INT, {.i64=0}, 0, 1, FLAGS },
-    { "chroma",    "set whether or not chroma is considered in the metric calculations", OFFSET(chroma), AV_OPT_TYPE_INT, {.i64=1}, 0, 1, FLAGS },
-    { NULL }
-};
-
-AVFILTER_DEFINE_CLASS(decimate);
-
-static void calc_diffs(const DecimateContext *dm, struct qitem *q,
-                       const AVFrame *f1, const AVFrame *f2)
-{
-    int64_t maxdiff = -1;
-    int64_t *bdiffs = dm->bdiffs;
-    int plane, i, j;
-
-    memset(bdiffs, 0, dm->bdiffsize * sizeof(*bdiffs));
-
-    for (plane = 0; plane < (dm->chroma && f1->data[2] ? 3 : 1); plane++) {
-        int x, y, xl;
-        const int linesize1 = f1->linesize[plane];
-        const int linesize2 = f2->linesize[plane];
-        const uint8_t *f1p = f1->data[plane];
-        const uint8_t *f2p = f2->data[plane];
-        int width    = plane ? FF_CEIL_RSHIFT(f1->width,  dm->hsub) : f1->width;
-        int height   = plane ? FF_CEIL_RSHIFT(f1->height, dm->vsub) : f1->height;
-        int hblockx  = dm->blockx / 2;
-        int hblocky  = dm->blocky / 2;
-
-        if (plane) {
-            hblockx >>= dm->hsub;
-            hblocky >>= dm->vsub;
-        }
-
-        for (y = 0; y < height; y++) {
-            int ydest = y / hblocky;
-            int xdest = 0;
-
-#define CALC_DIFF(nbits) do {                               \
-    for (x = 0; x < width; x += hblockx) {                  \
-        int64_t acc = 0;                                    \
-        int m = FFMIN(width, x + hblockx);                  \
-        for (xl = x; xl < m; xl++)                          \
-            acc += abs(((const uint##nbits##_t *)f1p)[xl] - \
-                       ((const uint##nbits##_t *)f2p)[xl]); \
-        bdiffs[ydest * dm->nxblocks + xdest] += acc;        \
-        xdest++;                                            \
-    }                                                       \
-} while (0)
-            if (dm->depth == 8) CALC_DIFF(8);
-            else                CALC_DIFF(16);
-
-            f1p += linesize1;
-            f2p += linesize2;
-        }
-    }
-
-    for (i = 0; i < dm->nyblocks - 1; i++) {
-        for (j = 0; j < dm->nxblocks - 1; j++) {
-            int64_t tmp = bdiffs[      i * dm->nxblocks + j    ]
-                        + bdiffs[      i * dm->nxblocks + j + 1]
-                        + bdiffs[(i + 1) * dm->nxblocks + j    ]
-                        + bdiffs[(i + 1) * dm->nxblocks + j + 1];
-            if (tmp > maxdiff)
-                maxdiff = tmp;
-        }
-    }
-
-    q->totdiff = 0;
-    for (i = 0; i < dm->bdiffsize; i++)
-        q->totdiff += bdiffs[i];
-    q->maxbdiff = maxdiff;
-}
-
-static int filter_frame(AVFilterLink *inlink, AVFrame *in)
-{
-    int scpos = -1, duppos = -1;
-    int drop = INT_MIN, i, lowest = 0, ret;
-    AVFilterContext *ctx  = inlink->dst;
-    AVFilterLink *outlink = ctx->outputs[0];
-    DecimateContext *dm   = ctx->priv;
-    AVFrame *prv;
-
-    /* update frames queue(s) */
-    if (FF_INLINK_IDX(inlink) == INPUT_MAIN) {
-        dm->queue[dm->fid].frame = in;
-        dm->got_frame[INPUT_MAIN] = 1;
-    } else {
-        dm->clean_src[dm->fid] = in;
-        dm->got_frame[INPUT_CLEANSRC] = 1;
-    }
-    if (!dm->got_frame[INPUT_MAIN] || (dm->ppsrc && !dm->got_frame[INPUT_CLEANSRC]))
-        return 0;
-    dm->got_frame[INPUT_MAIN] = dm->got_frame[INPUT_CLEANSRC] = 0;
-
-    if (in) {
-        /* update frame metrics */
-        prv = dm->fid ? dm->queue[dm->fid - 1].frame : dm->last;
-        if (!prv)
-            prv = in;
-        calc_diffs(dm, &dm->queue[dm->fid], prv, in);
-        if (++dm->fid != dm->cycle)
-            return 0;
-        av_frame_free(&dm->last);
-        dm->last = av_frame_clone(in);
-        dm->fid = 0;
-
-        /* we have a complete cycle, select the frame to drop */
-        lowest = 0;
-        for (i = 0; i < dm->cycle; i++) {
-            if (dm->queue[i].totdiff > dm->scthresh)
-                scpos = i;
-            if (dm->queue[i].maxbdiff < dm->queue[lowest].maxbdiff)
-                lowest = i;
-        }
-        if (dm->queue[lowest].maxbdiff < dm->dupthresh)
-            duppos = lowest;
-        drop = scpos >= 0 && duppos < 0 ? scpos : lowest;
-    }
-
-    /* metrics debug */
-    if (av_log_get_level() >= AV_LOG_DEBUG) {
-        av_log(ctx, AV_LOG_DEBUG, "1/%d frame drop:\n", dm->cycle);
-        for (i = 0; i < dm->cycle && dm->queue[i].frame; i++) {
-            av_log(ctx, AV_LOG_DEBUG,"  #%d: totdiff=%08"PRIx64" maxbdiff=%08"PRIx64"%s%s%s%s\n",
-                   i + 1, dm->queue[i].totdiff, dm->queue[i].maxbdiff,
-                   i == scpos  ? " sc"     : "",
-                   i == duppos ? " dup"    : "",
-                   i == lowest ? " lowest" : "",
-                   i == drop   ? " [DROP]" : "");
-        }
-    }
-
-    /* push all frames except the drop */
-    ret = 0;
-    for (i = 0; i < dm->cycle && dm->queue[i].frame; i++) {
-        if (i == drop) {
-            if (dm->ppsrc)
-                av_frame_free(&dm->clean_src[i]);
-            av_frame_free(&dm->queue[i].frame);
-        } else {
-            AVFrame *frame = dm->queue[i].frame;
-            if (frame->pts != AV_NOPTS_VALUE && dm->start_pts == AV_NOPTS_VALUE)
-                dm->start_pts = frame->pts;
-            if (dm->ppsrc) {
-                av_frame_free(&frame);
-                frame = dm->clean_src[i];
-            }
-            frame->pts = outlink->frame_count * dm->ts_unit +
-                         (dm->start_pts == AV_NOPTS_VALUE ? 0 : dm->start_pts);
-            ret = ff_filter_frame(outlink, frame);
-            if (ret < 0)
-                break;
-        }
-    }
-
-    return ret;
-}
-
-static int config_input(AVFilterLink *inlink)
-{
-    int max_value;
-    AVFilterContext *ctx = inlink->dst;
-    DecimateContext *dm = ctx->priv;
-    const AVPixFmtDescriptor *pix_desc = av_pix_fmt_desc_get(inlink->format);
-    const int w = inlink->w;
-    const int h = inlink->h;
-
-    dm->hsub      = pix_desc->log2_chroma_w;
-    dm->vsub      = pix_desc->log2_chroma_h;
-    dm->depth     = pix_desc->comp[0].depth_minus1 + 1;
-    max_value     = (1 << dm->depth) - 1;
-    dm->scthresh  = (int64_t)(((int64_t)max_value *          w * h          * dm->scthresh_flt)  / 100);
-    dm->dupthresh = (int64_t)(((int64_t)max_value * dm->blockx * dm->blocky * dm->dupthresh_flt) / 100);
-    dm->nxblocks  = (w + dm->blockx/2 - 1) / (dm->blockx/2);
-    dm->nyblocks  = (h + dm->blocky/2 - 1) / (dm->blocky/2);
-    dm->bdiffsize = dm->nxblocks * dm->nyblocks;
-    dm->bdiffs    = av_malloc(dm->bdiffsize * sizeof(*dm->bdiffs));
-    dm->queue     = av_calloc(dm->cycle, sizeof(*dm->queue));
-
-    if (!dm->bdiffs || !dm->queue)
-        return AVERROR(ENOMEM);
-
-    if (dm->ppsrc) {
-        dm->clean_src = av_calloc(dm->cycle, sizeof(*dm->clean_src));
-        if (!dm->clean_src)
-            return AVERROR(ENOMEM);
-    }
-
-    return 0;
-}
-
-static av_cold int decimate_init(AVFilterContext *ctx)
-{
-    DecimateContext *dm = ctx->priv;
-    AVFilterPad pad = {
-        .name         = av_strdup("main"),
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .filter_frame = filter_frame,
-        .config_props = config_input,
-    };
-
-    if (!pad.name)
-        return AVERROR(ENOMEM);
-    ff_insert_inpad(ctx, INPUT_MAIN, &pad);
-
-    if (dm->ppsrc) {
-        pad.name = av_strdup("clean_src");
-        pad.config_props = NULL;
-        if (!pad.name)
-            return AVERROR(ENOMEM);
-        ff_insert_inpad(ctx, INPUT_CLEANSRC, &pad);
-    }
-
-    if ((dm->blockx & (dm->blockx - 1)) ||
-        (dm->blocky & (dm->blocky - 1))) {
-        av_log(ctx, AV_LOG_ERROR, "blockx and blocky settings must be power of two\n");
-        return AVERROR(EINVAL);
-    }
-
-    dm->start_pts = AV_NOPTS_VALUE;
-
-    return 0;
-}
-
-static av_cold void decimate_uninit(AVFilterContext *ctx)
-{
-    int i;
-    DecimateContext *dm = ctx->priv;
-
-    av_frame_free(&dm->last);
-    av_freep(&dm->bdiffs);
-    av_freep(&dm->queue);
-    av_freep(&dm->clean_src);
-    for (i = 0; i < ctx->nb_inputs; i++)
-        av_freep(&ctx->input_pads[i].name);
-}
-
-static int request_inlink(AVFilterContext *ctx, int lid)
-{
-    int ret = 0;
-    DecimateContext *dm = ctx->priv;
-
-    if (!dm->got_frame[lid]) {
-        AVFilterLink *inlink = ctx->inputs[lid];
-        ret = ff_request_frame(inlink);
-        if (ret == AVERROR_EOF) { // flushing
-            dm->eof |= 1 << lid;
-            ret = filter_frame(inlink, NULL);
-        }
-    }
-    return ret;
-}
-
-static int request_frame(AVFilterLink *outlink)
-{
-    int ret;
-    AVFilterContext *ctx = outlink->src;
-    DecimateContext *dm = ctx->priv;
-    const uint32_t eof_mask = 1<<INPUT_MAIN | dm->ppsrc<<INPUT_CLEANSRC;
-
-    if ((dm->eof & eof_mask) == eof_mask) // flush done?
-        return AVERROR_EOF;
-    if ((ret = request_inlink(ctx, INPUT_MAIN)) < 0)
-        return ret;
-    if (dm->ppsrc && (ret = request_inlink(ctx, INPUT_CLEANSRC)) < 0)
-        return ret;
-    return 0;
-}
-
-static int query_formats(AVFilterContext *ctx)
-{
-    static const enum AVPixelFormat pix_fmts[] = {
-#define PF_NOALPHA(suf) AV_PIX_FMT_YUV420##suf,  AV_PIX_FMT_YUV422##suf,  AV_PIX_FMT_YUV444##suf
-#define PF_ALPHA(suf)   AV_PIX_FMT_YUVA420##suf, AV_PIX_FMT_YUVA422##suf, AV_PIX_FMT_YUVA444##suf
-#define PF(suf)         PF_NOALPHA(suf), PF_ALPHA(suf)
-        PF(P), PF(P9), PF(P10), PF_NOALPHA(P12), PF_NOALPHA(P14), PF(P16),
-        AV_PIX_FMT_YUV440P, AV_PIX_FMT_YUV411P, AV_PIX_FMT_YUV410P,
-        AV_PIX_FMT_GRAY8, AV_PIX_FMT_GRAY16,
-        AV_PIX_FMT_NONE
-    };
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-    return 0;
-}
-
-static int config_output(AVFilterLink *outlink)
-{
-    AVFilterContext *ctx = outlink->src;
-    DecimateContext *dm = ctx->priv;
-    const AVFilterLink *inlink =
-        ctx->inputs[dm->ppsrc ? INPUT_CLEANSRC : INPUT_MAIN];
-    AVRational fps = inlink->frame_rate;
-
-    if (!fps.num || !fps.den) {
-        av_log(ctx, AV_LOG_ERROR, "The input needs a constant frame rate; "
-               "current rate of %d/%d is invalid\n", fps.num, fps.den);
-        return AVERROR(EINVAL);
-    }
-    fps = av_mul_q(fps, (AVRational){dm->cycle - 1, dm->cycle});
-    av_log(ctx, AV_LOG_VERBOSE, "FPS: %d/%d -> %d/%d\n",
-           inlink->frame_rate.num, inlink->frame_rate.den, fps.num, fps.den);
-    outlink->flags |= FF_LINK_FLAG_REQUEST_LOOP;
-    outlink->time_base  = inlink->time_base;
-    outlink->frame_rate = fps;
-    outlink->sample_aspect_ratio = inlink->sample_aspect_ratio;
-    outlink->w = inlink->w;
-    outlink->h = inlink->h;
-    dm->ts_unit = av_q2d(av_inv_q(av_mul_q(fps, outlink->time_base)));
-    return 0;
-}
-
-static const AVFilterPad decimate_outputs[] = {
-    {
-        .name          = "default",
-        .type          = AVMEDIA_TYPE_VIDEO,
-        .request_frame = request_frame,
-        .config_props  = config_output,
-    },
-    { NULL }
-};
-
-AVFilter ff_vf_decimate = {
-    .name          = "decimate",
-    .description   = NULL_IF_CONFIG_SMALL("Decimate frames (post field matching filter)."),
-    .init          = decimate_init,
-    .uninit        = decimate_uninit,
-    .priv_size     = sizeof(DecimateContext),
-    .query_formats = query_formats,
-    .outputs       = decimate_outputs,
-    .priv_class    = &decimate_class,
-    .flags         = AVFILTER_FLAG_DYNAMIC_INPUTS,
-};
diff --git a/libavfilter/vf_delogo.c b/libavfilter/vf_delogo.c
deleted file mode 100644
index fbc8983..0000000
--- a/libavfilter/vf_delogo.c
+++ /dev/null
@@ -1,290 +0,0 @@
-/*
- * Copyright (c) 2002 Jindrich Makovicka <makovick@gmail.com>
- * Copyright (c) 2011 Stefano Sabatini
- * Copyright (c) 2013 Jean Delvare <khali@linux-fr.org>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with FFmpeg; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-/**
- * @file
- * A very simple tv station logo remover
- * Originally imported from MPlayer libmpcodecs/vf_delogo.c,
- * the algorithm was later improved.
- */
-
-#include "libavutil/common.h"
-#include "libavutil/imgutils.h"
-#include "libavutil/opt.h"
-#include "libavutil/pixdesc.h"
-#include "avfilter.h"
-#include "formats.h"
-#include "internal.h"
-#include "video.h"
-
-/**
- * Apply a simple delogo algorithm to the image in src and put the
- * result in dst.
- *
- * The algorithm is only applied to the region specified by the logo
- * parameters.
- *
- * @param w      width of the input image
- * @param h      height of the input image
- * @param logo_x x coordinate of the top left corner of the logo region
- * @param logo_y y coordinate of the top left corner of the logo region
- * @param logo_w width of the logo
- * @param logo_h height of the logo
- * @param band   the size of the band around the processed area
- * @param show   show a rectangle around the processed area, useful for
- *               parameters tweaking
- * @param direct if non-zero perform in-place processing
- */
-static void apply_delogo(uint8_t *dst, int dst_linesize,
-                         uint8_t *src, int src_linesize,
-                         int w, int h, AVRational sar,
-                         int logo_x, int logo_y, int logo_w, int logo_h,
-                         unsigned int band, int show, int direct)
-{
-    int x, y;
-    uint64_t interp, weightl, weightr, weightt, weightb;
-    uint8_t *xdst, *xsrc;
-
-    uint8_t *topleft, *botleft, *topright;
-    unsigned int left_sample, right_sample;
-    int xclipl, xclipr, yclipt, yclipb;
-    int logo_x1, logo_x2, logo_y1, logo_y2;
-
-    xclipl = FFMAX(-logo_x, 0);
-    xclipr = FFMAX(logo_x+logo_w-w, 0);
-    yclipt = FFMAX(-logo_y, 0);
-    yclipb = FFMAX(logo_y+logo_h-h, 0);
-
-    logo_x1 = logo_x + xclipl;
-    logo_x2 = logo_x + logo_w - xclipr;
-    logo_y1 = logo_y + yclipt;
-    logo_y2 = logo_y + logo_h - yclipb;
-
-    topleft  = src+logo_y1     * src_linesize+logo_x1;
-    topright = src+logo_y1     * src_linesize+logo_x2-1;
-    botleft  = src+(logo_y2-1) * src_linesize+logo_x1;
-
-    if (!direct)
-        av_image_copy_plane(dst, dst_linesize, src, src_linesize, w, h);
-
-    dst += (logo_y1 + 1) * dst_linesize;
-    src += (logo_y1 + 1) * src_linesize;
-
-    for (y = logo_y1+1; y < logo_y2-1; y++) {
-        left_sample = topleft[src_linesize*(y-logo_y1)]   +
-                      topleft[src_linesize*(y-logo_y1-1)] +
-                      topleft[src_linesize*(y-logo_y1+1)];
-        right_sample = topright[src_linesize*(y-logo_y1)]   +
-                       topright[src_linesize*(y-logo_y1-1)] +
-                       topright[src_linesize*(y-logo_y1+1)];
-
-        for (x = logo_x1+1,
-             xdst = dst+logo_x1+1,
-             xsrc = src+logo_x1+1; x < logo_x2-1; x++, xdst++, xsrc++) {
-
-            /* Weighted interpolation based on relative distances, taking SAR into account */
-            weightl = (uint64_t)              (logo_x2-1-x) * (y-logo_y1) * (logo_y2-1-y) * sar.den;
-            weightr = (uint64_t)(x-logo_x1)                 * (y-logo_y1) * (logo_y2-1-y) * sar.den;
-            weightt = (uint64_t)(x-logo_x1) * (logo_x2-1-x)               * (logo_y2-1-y) * sar.num;
-            weightb = (uint64_t)(x-logo_x1) * (logo_x2-1-x) * (y-logo_y1)                 * sar.num;
-
-            interp =
-                left_sample * weightl
-                +
-                right_sample * weightr
-                +
-                (topleft[x-logo_x1]    +
-                 topleft[x-logo_x1-1]  +
-                 topleft[x-logo_x1+1]) * weightt
-                +
-                (botleft[x-logo_x1]    +
-                 botleft[x-logo_x1-1]  +
-                 botleft[x-logo_x1+1]) * weightb;
-            interp /= (weightl + weightr + weightt + weightb) * 3U;
-
-            if (y >= logo_y+band && y < logo_y+logo_h-band &&
-                x >= logo_x+band && x < logo_x+logo_w-band) {
-                *xdst = interp;
-            } else {
-                unsigned dist = 0;
-
-                if      (x < logo_x+band)
-                    dist = FFMAX(dist, logo_x-x+band);
-                else if (x >= logo_x+logo_w-band)
-                    dist = FFMAX(dist, x-(logo_x+logo_w-1-band));
-
-                if      (y < logo_y+band)
-                    dist = FFMAX(dist, logo_y-y+band);
-                else if (y >= logo_y+logo_h-band)
-                    dist = FFMAX(dist, y-(logo_y+logo_h-1-band));
-
-                *xdst = (*xsrc*dist + interp*(band-dist))/band;
-                if (show && (dist == band-1))
-                    *xdst = 0;
-            }
-        }
-
-        dst += dst_linesize;
-        src += src_linesize;
-    }
-}
-
-typedef struct {
-    const AVClass *class;
-    int x, y, w, h, band, show;
-}  DelogoContext;
-
-#define OFFSET(x) offsetof(DelogoContext, x)
-#define FLAGS AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM
-
-static const AVOption delogo_options[]= {
-    { "x",    "set logo x position",       OFFSET(x),    AV_OPT_TYPE_INT, { .i64 = -1 }, -1, INT_MAX, FLAGS },
-    { "y",    "set logo y position",       OFFSET(y),    AV_OPT_TYPE_INT, { .i64 = -1 }, -1, INT_MAX, FLAGS },
-    { "w",    "set logo width",            OFFSET(w),    AV_OPT_TYPE_INT, { .i64 = -1 }, -1, INT_MAX, FLAGS },
-    { "h",    "set logo height",           OFFSET(h),    AV_OPT_TYPE_INT, { .i64 = -1 }, -1, INT_MAX, FLAGS },
-    { "band", "set delogo area band size", OFFSET(band), AV_OPT_TYPE_INT, { .i64 =  4 },  1, INT_MAX, FLAGS },
-    { "t",    "set delogo area band size", OFFSET(band), AV_OPT_TYPE_INT, { .i64 =  4 },  1, INT_MAX, FLAGS },
-    { "show", "show delogo area",          OFFSET(show), AV_OPT_TYPE_INT, { .i64 =  0 },  0, 1,       FLAGS },
-    { NULL }
-};
-
-AVFILTER_DEFINE_CLASS(delogo);
-
-static int query_formats(AVFilterContext *ctx)
-{
-    static const enum AVPixelFormat pix_fmts[] = {
-        AV_PIX_FMT_YUV444P,  AV_PIX_FMT_YUV422P,  AV_PIX_FMT_YUV420P,
-        AV_PIX_FMT_YUV411P,  AV_PIX_FMT_YUV410P,  AV_PIX_FMT_YUV440P,
-        AV_PIX_FMT_YUVA420P, AV_PIX_FMT_GRAY8,
-        AV_PIX_FMT_NONE
-    };
-
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-    return 0;
-}
-
-static av_cold int init(AVFilterContext *ctx)
-{
-    DelogoContext *s = ctx->priv;
-
-#define CHECK_UNSET_OPT(opt)                                            \
-    if (s->opt == -1) {                                            \
-        av_log(s, AV_LOG_ERROR, "Option %s was not set.\n", #opt); \
-        return AVERROR(EINVAL);                                         \
-    }
-    CHECK_UNSET_OPT(x);
-    CHECK_UNSET_OPT(y);
-    CHECK_UNSET_OPT(w);
-    CHECK_UNSET_OPT(h);
-
-    av_log(ctx, AV_LOG_VERBOSE, "x:%d y:%d, w:%d h:%d band:%d show:%d\n",
-           s->x, s->y, s->w, s->h, s->band, s->show);
-
-    s->w += s->band*2;
-    s->h += s->band*2;
-    s->x -= s->band;
-    s->y -= s->band;
-
-    return 0;
-}
-
-static int filter_frame(AVFilterLink *inlink, AVFrame *in)
-{
-    DelogoContext *s = inlink->dst->priv;
-    AVFilterLink *outlink = inlink->dst->outputs[0];
-    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);
-    AVFrame *out;
-    int hsub0 = desc->log2_chroma_w;
-    int vsub0 = desc->log2_chroma_h;
-    int direct = 0;
-    int plane;
-    AVRational sar;
-
-    if (av_frame_is_writable(in)) {
-        direct = 1;
-        out = in;
-    } else {
-        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
-        if (!out) {
-            av_frame_free(&in);
-            return AVERROR(ENOMEM);
-        }
-
-        av_frame_copy_props(out, in);
-    }
-
-    sar = in->sample_aspect_ratio;
-    /* Assume square pixels if SAR is unknown */
-    if (!sar.num)
-        sar.num = sar.den = 1;
-
-    for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++) {
-        int hsub = plane == 1 || plane == 2 ? hsub0 : 0;
-        int vsub = plane == 1 || plane == 2 ? vsub0 : 0;
-
-        apply_delogo(out->data[plane], out->linesize[plane],
-                     in ->data[plane], in ->linesize[plane],
-                     FF_CEIL_RSHIFT(inlink->w, hsub),
-                     FF_CEIL_RSHIFT(inlink->h, vsub),
-                     sar, s->x>>hsub, s->y>>vsub,
-                     /* Up and left borders were rounded down, inject lost bits
-                      * into width and height to avoid error accumulation */
-                     FF_CEIL_RSHIFT(s->w + (s->x & ((1<<hsub)-1)), hsub),
-                     FF_CEIL_RSHIFT(s->h + (s->y & ((1<<vsub)-1)), vsub),
-                     s->band>>FFMIN(hsub, vsub),
-                     s->show, direct);
-    }
-
-    if (!direct)
-        av_frame_free(&in);
-
-    return ff_filter_frame(outlink, out);
-}
-
-static const AVFilterPad avfilter_vf_delogo_inputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .filter_frame = filter_frame,
-    },
-    { NULL }
-};
-
-static const AVFilterPad avfilter_vf_delogo_outputs[] = {
-    {
-        .name = "default",
-        .type = AVMEDIA_TYPE_VIDEO,
-    },
-    { NULL }
-};
-
-AVFilter ff_vf_delogo = {
-    .name          = "delogo",
-    .description   = NULL_IF_CONFIG_SMALL("Remove logo from input video."),
-    .priv_size     = sizeof(DelogoContext),
-    .priv_class    = &delogo_class,
-    .init          = init,
-    .query_formats = query_formats,
-    .inputs        = avfilter_vf_delogo_inputs,
-    .outputs       = avfilter_vf_delogo_outputs,
-    .flags         = AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC,
-};
diff --git a/libavfilter/vf_geq.c b/libavfilter/vf_geq.c
deleted file mode 100644
index 49a3e62..0000000
--- a/libavfilter/vf_geq.c
+++ /dev/null
@@ -1,280 +0,0 @@
-/*
- * Copyright (C) 2006 Michael Niedermayer <michaelni@gmx.at>
- * Copyright (C) 2012 Clment Bsch <u pkh me>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with FFmpeg; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-/**
- * @file
- * Generic equation change filter
- * Originally written by Michael Niedermayer for the MPlayer project, and
- * ported by Clment Bsch for FFmpeg.
- */
-
-#include "libavutil/avstring.h"
-#include "libavutil/eval.h"
-#include "libavutil/opt.h"
-#include "libavutil/pixdesc.h"
-#include "internal.h"
-
-typedef struct {
-    const AVClass *class;
-    AVExpr *e[4];               ///< expressions for each plane
-    char *expr_str[4+3];        ///< expression strings for each plane
-    AVFrame *picref;            ///< current input buffer
-    int hsub, vsub;             ///< chroma subsampling
-    int planes;                 ///< number of planes
-    int is_rgb;
-} GEQContext;
-
-enum { Y = 0, U, V, A, G, B, R };
-
-#define OFFSET(x) offsetof(GEQContext, x)
-#define FLAGS AV_OPT_FLAG_VIDEO_PARAM|AV_OPT_FLAG_FILTERING_PARAM
-
-static const AVOption geq_options[] = {
-    { "lum_expr",   "set luminance expression",   OFFSET(expr_str[Y]), AV_OPT_TYPE_STRING, {.str=NULL}, CHAR_MIN, CHAR_MAX, FLAGS },
-    { "lum",        "set luminance expression",   OFFSET(expr_str[Y]), AV_OPT_TYPE_STRING, {.str=NULL}, CHAR_MIN, CHAR_MAX, FLAGS },
-    { "cb_expr",    "set chroma blue expression", OFFSET(expr_str[U]), AV_OPT_TYPE_STRING, {.str=NULL}, CHAR_MIN, CHAR_MAX, FLAGS },
-    { "cb",         "set chroma blue expression", OFFSET(expr_str[U]), AV_OPT_TYPE_STRING, {.str=NULL}, CHAR_MIN, CHAR_MAX, FLAGS },
-    { "cr_expr",    "set chroma red expression",  OFFSET(expr_str[V]), AV_OPT_TYPE_STRING, {.str=NULL}, CHAR_MIN, CHAR_MAX, FLAGS },
-    { "cr",         "set chroma red expression",  OFFSET(expr_str[V]), AV_OPT_TYPE_STRING, {.str=NULL}, CHAR_MIN, CHAR_MAX, FLAGS },
-    { "alpha_expr", "set alpha expression",       OFFSET(expr_str[A]), AV_OPT_TYPE_STRING, {.str=NULL}, CHAR_MIN, CHAR_MAX, FLAGS },
-    { "a",          "set alpha expression",       OFFSET(expr_str[A]), AV_OPT_TYPE_STRING, {.str=NULL}, CHAR_MIN, CHAR_MAX, FLAGS },
-    { "red_expr",   "set red expression",         OFFSET(expr_str[R]), AV_OPT_TYPE_STRING, {.str=NULL}, CHAR_MIN, CHAR_MAX, FLAGS },
-    { "r",          "set red expression",         OFFSET(expr_str[R]), AV_OPT_TYPE_STRING, {.str=NULL}, CHAR_MIN, CHAR_MAX, FLAGS },
-    { "green_expr", "set green expression",       OFFSET(expr_str[G]), AV_OPT_TYPE_STRING, {.str=NULL}, CHAR_MIN, CHAR_MAX, FLAGS },
-    { "g",          "set green expression",       OFFSET(expr_str[G]), AV_OPT_TYPE_STRING, {.str=NULL}, CHAR_MIN, CHAR_MAX, FLAGS },
-    { "blue_expr",  "set blue expression",        OFFSET(expr_str[B]), AV_OPT_TYPE_STRING, {.str=NULL}, CHAR_MIN, CHAR_MAX, FLAGS },
-    { "b",          "set blue expression",        OFFSET(expr_str[B]), AV_OPT_TYPE_STRING, {.str=NULL}, CHAR_MIN, CHAR_MAX, FLAGS },
-    {NULL},
-};
-
-AVFILTER_DEFINE_CLASS(geq);
-
-static inline double getpix(void *priv, double x, double y, int plane)
-{
-    int xi, yi;
-    GEQContext *geq = priv;
-    AVFrame *picref = geq->picref;
-    const uint8_t *src = picref->data[plane];
-    const int linesize = picref->linesize[plane];
-    const int w = (plane == 1 || plane == 2) ? FF_CEIL_RSHIFT(picref->width,  geq->hsub) : picref->width;
-    const int h = (plane == 1 || plane == 2) ? FF_CEIL_RSHIFT(picref->height, geq->vsub) : picref->height;
-
-    if (!src)
-        return 0;
-
-    xi = x = av_clipf(x, 0, w - 2);
-    yi = y = av_clipf(y, 0, h - 2);
-
-    x -= xi;
-    y -= yi;
-
-    return (1-y)*((1-x)*src[xi +  yi    * linesize] + x*src[xi + 1 +  yi    * linesize])
-          +   y *((1-x)*src[xi + (yi+1) * linesize] + x*src[xi + 1 + (yi+1) * linesize]);
-}
-
-//TODO: cubic interpolate
-//TODO: keep the last few frames
-static double lum(void *priv, double x, double y) { return getpix(priv, x, y, 0); }
-static double  cb(void *priv, double x, double y) { return getpix(priv, x, y, 1); }
-static double  cr(void *priv, double x, double y) { return getpix(priv, x, y, 2); }
-static double alpha(void *priv, double x, double y) { return getpix(priv, x, y, 3); }
-
-static const char *const var_names[] = {   "X",   "Y",   "W",   "H",   "N",   "SW",   "SH",   "T",        NULL };
-enum                                   { VAR_X, VAR_Y, VAR_W, VAR_H, VAR_N, VAR_SW, VAR_SH, VAR_T, VAR_VARS_NB };
-
-static av_cold int geq_init(AVFilterContext *ctx)
-{
-    GEQContext *geq = ctx->priv;
-    int plane, ret = 0;
-
-    if (!geq->expr_str[Y] && !geq->expr_str[G] && !geq->expr_str[B] && !geq->expr_str[R]) {
-        av_log(ctx, AV_LOG_ERROR, "A luminance or RGB expression is mandatory\n");
-        ret = AVERROR(EINVAL);
-        goto end;
-    }
-    geq->is_rgb = !geq->expr_str[Y];
-
-    if ((geq->expr_str[Y] || geq->expr_str[U] || geq->expr_str[V]) && (geq->expr_str[G] || geq->expr_str[B] || geq->expr_str[R])) {
-        av_log(ctx, AV_LOG_ERROR, "Either YCbCr or RGB but not both must be specified\n");
-        ret = AVERROR(EINVAL);
-        goto end;
-    }
-
-    if (!geq->expr_str[U] && !geq->expr_str[V]) {
-        /* No chroma at all: fallback on luma */
-        geq->expr_str[U] = av_strdup(geq->expr_str[Y]);
-        geq->expr_str[V] = av_strdup(geq->expr_str[Y]);
-    } else {
-        /* One chroma unspecified, fallback on the other */
-        if (!geq->expr_str[U]) geq->expr_str[U] = av_strdup(geq->expr_str[V]);
-        if (!geq->expr_str[V]) geq->expr_str[V] = av_strdup(geq->expr_str[U]);
-    }
-
-    if (!geq->expr_str[A])
-        geq->expr_str[A] = av_strdup("255");
-    if (!geq->expr_str[G])
-        geq->expr_str[G] = av_strdup("g(X,Y)");
-    if (!geq->expr_str[B])
-        geq->expr_str[B] = av_strdup("b(X,Y)");
-    if (!geq->expr_str[R])
-        geq->expr_str[R] = av_strdup("r(X,Y)");
-
-    if (geq->is_rgb ?
-            (!geq->expr_str[G] || !geq->expr_str[B] || !geq->expr_str[R])
-                    :
-            (!geq->expr_str[U] || !geq->expr_str[V] || !geq->expr_str[A])) {
-        ret = AVERROR(ENOMEM);
-        goto end;
-    }
-
-    for (plane = 0; plane < 4; plane++) {
-        static double (*p[])(void *, double, double) = { lum, cb, cr, alpha };
-        static const char *const func2_yuv_names[]    = { "lum", "cb", "cr", "alpha", "p", NULL };
-        static const char *const func2_rgb_names[]    = { "g", "b", "r", "alpha", "p", NULL };
-        const char *const *func2_names       = geq->is_rgb ? func2_rgb_names : func2_yuv_names;
-        double (*func2[])(void *, double, double) = { lum, cb, cr, alpha, p[plane], NULL };
-
-        ret = av_expr_parse(&geq->e[plane], geq->expr_str[plane < 3 && geq->is_rgb ? plane+4 : plane], var_names,
-                            NULL, NULL, func2_names, func2, 0, ctx);
-        if (ret < 0)
-            break;
-    }
-
-end:
-    return ret;
-}
-
-static int geq_query_formats(AVFilterContext *ctx)
-{
-    GEQContext *geq = ctx->priv;
-    static const enum PixelFormat yuv_pix_fmts[] = {
-        AV_PIX_FMT_YUV444P,  AV_PIX_FMT_YUV422P,  AV_PIX_FMT_YUV420P,
-        AV_PIX_FMT_YUV411P,  AV_PIX_FMT_YUV410P,  AV_PIX_FMT_YUV440P,
-        AV_PIX_FMT_YUVA444P, AV_PIX_FMT_YUVA422P, AV_PIX_FMT_YUVA420P,
-        AV_PIX_FMT_GRAY8,
-        AV_PIX_FMT_NONE
-    };
-    static const enum PixelFormat rgb_pix_fmts[] = {
-        AV_PIX_FMT_GBRP, AV_PIX_FMT_GBRAP,
-        AV_PIX_FMT_NONE
-    };
-    if (geq->is_rgb) {
-        ff_set_common_formats(ctx, ff_make_format_list(rgb_pix_fmts));
-    } else
-        ff_set_common_formats(ctx, ff_make_format_list(yuv_pix_fmts));
-    return 0;
-}
-
-static int geq_config_props(AVFilterLink *inlink)
-{
-    GEQContext *geq = inlink->dst->priv;
-    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);
-
-    geq->hsub = desc->log2_chroma_w;
-    geq->vsub = desc->log2_chroma_h;
-    geq->planes = desc->nb_components;
-    return 0;
-}
-
-static int geq_filter_frame(AVFilterLink *inlink, AVFrame *in)
-{
-    int plane;
-    GEQContext *geq = inlink->dst->priv;
-    AVFilterLink *outlink = inlink->dst->outputs[0];
-    AVFrame *out;
-    double values[VAR_VARS_NB] = {
-        [VAR_N] = inlink->frame_count,
-        [VAR_T] = in->pts == AV_NOPTS_VALUE ? NAN : in->pts * av_q2d(inlink->time_base),
-    };
-
-    geq->picref = in;
-    out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
-    if (!out) {
-        av_frame_free(&in);
-        return AVERROR(ENOMEM);
-    }
-    av_frame_copy_props(out, in);
-
-    for (plane = 0; plane < geq->planes && out->data[plane]; plane++) {
-        int x, y;
-        uint8_t *dst = out->data[plane];
-        const int linesize = out->linesize[plane];
-        const int w = (plane == 1 || plane == 2) ? FF_CEIL_RSHIFT(inlink->w, geq->hsub) : inlink->w;
-        const int h = (plane == 1 || plane == 2) ? FF_CEIL_RSHIFT(inlink->h, geq->vsub) : inlink->h;
-
-        values[VAR_W]  = w;
-        values[VAR_H]  = h;
-        values[VAR_SW] = w / (double)inlink->w;
-        values[VAR_SH] = h / (double)inlink->h;
-
-        for (y = 0; y < h; y++) {
-            values[VAR_Y] = y;
-            for (x = 0; x < w; x++) {
-                values[VAR_X] = x;
-                dst[x] = av_expr_eval(geq->e[plane], values, geq);
-            }
-            dst += linesize;
-        }
-    }
-
-    av_frame_free(&geq->picref);
-    return ff_filter_frame(outlink, out);
-}
-
-static av_cold void geq_uninit(AVFilterContext *ctx)
-{
-    int i;
-    GEQContext *geq = ctx->priv;
-
-    for (i = 0; i < FF_ARRAY_ELEMS(geq->e); i++)
-        av_expr_free(geq->e[i]);
-}
-
-static const AVFilterPad geq_inputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .config_props = geq_config_props,
-        .filter_frame = geq_filter_frame,
-    },
-    { NULL }
-};
-
-static const AVFilterPad geq_outputs[] = {
-    {
-        .name = "default",
-        .type = AVMEDIA_TYPE_VIDEO,
-    },
-    { NULL }
-};
-
-AVFilter ff_vf_geq = {
-    .name          = "geq",
-    .description   = NULL_IF_CONFIG_SMALL("Apply generic equation to each pixel."),
-    .priv_size     = sizeof(GEQContext),
-    .init          = geq_init,
-    .uninit        = geq_uninit,
-    .query_formats = geq_query_formats,
-    .inputs        = geq_inputs,
-    .outputs       = geq_outputs,
-    .priv_class    = &geq_class,
-    .flags         = AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC,
-};
diff --git a/libavfilter/vf_histeq.c b/libavfilter/vf_histeq.c
deleted file mode 100644
index 6fdb7be..0000000
--- a/libavfilter/vf_histeq.c
+++ /dev/null
@@ -1,281 +0,0 @@
-/*
- * Copyright (c) 2012 Jeremy Tran
- * Copyright (c) 2001 Donald A. Graft
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with FFmpeg; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-/**
- * @file
- * Histogram equalization filter, based on the VirtualDub filter by
- * Donald A. Graft  <neuron2 AT home DOT com>.
- * Implements global automatic contrast adjustment by means of
- * histogram equalization.
- */
-
-#include "libavutil/common.h"
-#include "libavutil/opt.h"
-#include "libavutil/pixdesc.h"
-
-#include "avfilter.h"
-#include "drawutils.h"
-#include "formats.h"
-#include "internal.h"
-#include "video.h"
-
-// #define DEBUG
-
-// Linear Congruential Generator, see "Numerical Recipes"
-#define LCG_A 4096
-#define LCG_C 150889
-#define LCG_M 714025
-#define LCG(x) (((x) * LCG_A + LCG_C) % LCG_M)
-#define LCG_SEED 739187
-
-enum HisteqAntibanding {
-    HISTEQ_ANTIBANDING_NONE   = 0,
-    HISTEQ_ANTIBANDING_WEAK   = 1,
-    HISTEQ_ANTIBANDING_STRONG = 2,
-    HISTEQ_ANTIBANDING_NB,
-};
-
-typedef struct {
-    const AVClass *class;
-    float strength;
-    float intensity;
-    enum HisteqAntibanding antibanding;
-    int in_histogram [256];        ///< input histogram
-    int out_histogram[256];        ///< output histogram
-    int LUT[256];                  ///< lookup table derived from histogram[]
-    uint8_t rgba_map[4];           ///< components position
-    int bpp;                       ///< bytes per pixel
-} HisteqContext;
-
-#define OFFSET(x) offsetof(HisteqContext, x)
-#define FLAGS AV_OPT_FLAG_VIDEO_PARAM|AV_OPT_FLAG_FILTERING_PARAM
-#define CONST(name, help, val, unit) { name, help, 0, AV_OPT_TYPE_CONST, {.i64=val}, INT_MIN, INT_MAX, FLAGS, unit }
-
-static const AVOption histeq_options[] = {
-    { "strength",    "set the strength", OFFSET(strength), AV_OPT_TYPE_FLOAT, {.dbl=0.2}, 0, 1, FLAGS },
-    { "intensity",   "set the intensity", OFFSET(intensity), AV_OPT_TYPE_FLOAT, {.dbl=0.21}, 0, 1, FLAGS },
-    { "antibanding", "set the antibanding level", OFFSET(antibanding), AV_OPT_TYPE_INT, {.i64=HISTEQ_ANTIBANDING_NONE}, 0, HISTEQ_ANTIBANDING_NB-1, FLAGS, "antibanding" },
-    CONST("none",    "apply no antibanding",     HISTEQ_ANTIBANDING_NONE,   "antibanding"),
-    CONST("weak",    "apply weak antibanding",   HISTEQ_ANTIBANDING_WEAK,   "antibanding"),
-    CONST("strong",  "apply strong antibanding", HISTEQ_ANTIBANDING_STRONG, "antibanding"),
-    { NULL }
-};
-
-AVFILTER_DEFINE_CLASS(histeq);
-
-static av_cold int init(AVFilterContext *ctx)
-{
-    HisteqContext *histeq = ctx->priv;
-
-    av_log(ctx, AV_LOG_VERBOSE,
-           "strength:%0.3f intensity:%0.3f antibanding:%d\n",
-           histeq->strength, histeq->intensity, histeq->antibanding);
-
-    return 0;
-}
-
-static int query_formats(AVFilterContext *ctx)
-{
-    static const enum PixelFormat pix_fmts[] = {
-        AV_PIX_FMT_ARGB, AV_PIX_FMT_RGBA, AV_PIX_FMT_ABGR, AV_PIX_FMT_BGRA,
-        AV_PIX_FMT_RGB24, AV_PIX_FMT_BGR24,
-        AV_PIX_FMT_NONE
-    };
-
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-    return 0;
-}
-
-static int config_input(AVFilterLink *inlink)
-{
-    AVFilterContext *ctx = inlink->dst;
-    HisteqContext *histeq = ctx->priv;
-    const AVPixFmtDescriptor *pix_desc = av_pix_fmt_desc_get(inlink->format);
-
-    histeq->bpp = av_get_bits_per_pixel(pix_desc) / 8;
-    ff_fill_rgba_map(histeq->rgba_map, inlink->format);
-
-    return 0;
-}
-
-#define R 0
-#define G 1
-#define B 2
-#define A 3
-
-#define GET_RGB_VALUES(r, g, b, src, map) do { \
-    r = src[x + map[R]];                       \
-    g = src[x + map[G]];                       \
-    b = src[x + map[B]];                       \
-} while (0)
-
-static int filter_frame(AVFilterLink *inlink, AVFrame *inpic)
-{
-    AVFilterContext   *ctx     = inlink->dst;
-    HisteqContext     *histeq  = ctx->priv;
-    AVFilterLink      *outlink = ctx->outputs[0];
-    int strength  = histeq->strength  * 1000;
-    int intensity = histeq->intensity * 1000;
-    int x, y, i, luthi, lutlo, lut, luma, oluma, m;
-    AVFrame *outpic;
-    unsigned int r, g, b, jran;
-    uint8_t *src, *dst;
-
-    outpic = ff_get_video_buffer(outlink, outlink->w, outlink->h);
-    if (!outpic) {
-        av_frame_free(&inpic);
-        return AVERROR(ENOMEM);
-    }
-    av_frame_copy_props(outpic, inpic);
-
-    /* Seed random generator for antibanding. */
-    jran = LCG_SEED;
-
-    /* Calculate and store the luminance and calculate the global histogram
-       based on the luminance. */
-    memset(histeq->in_histogram, 0, sizeof(histeq->in_histogram));
-    src = inpic->data[0];
-    dst = outpic->data[0];
-    for (y = 0; y < inlink->h; y++) {
-        for (x = 0; x < inlink->w * histeq->bpp; x += histeq->bpp) {
-            GET_RGB_VALUES(r, g, b, src, histeq->rgba_map);
-            luma = (55 * r + 182 * g + 19 * b) >> 8;
-            dst[x + histeq->rgba_map[A]] = luma;
-            histeq->in_histogram[luma]++;
-        }
-        src += inpic->linesize[0];
-        dst += outpic->linesize[0];
-    }
-
-#ifdef DEBUG
-    for (x = 0; x < 256; x++)
-        av_dlog(ctx, "in[%d]: %u\n", x, histeq->in_histogram[x]);
-#endif
-
-    /* Calculate the lookup table. */
-    histeq->LUT[0] = histeq->in_histogram[0];
-    /* Accumulate */
-    for (x = 1; x < 256; x++)
-        histeq->LUT[x] = histeq->LUT[x-1] + histeq->in_histogram[x];
-
-    /* Normalize */
-    for (x = 0; x < 256; x++)
-        histeq->LUT[x] = (histeq->LUT[x] * intensity) / (inlink->h * inlink->w);
-
-    /* Adjust the LUT based on the selected strength. This is an alpha
-       mix of the calculated LUT and a linear LUT with gain 1. */
-    for (x = 0; x < 256; x++)
-        histeq->LUT[x] = (strength * histeq->LUT[x]) / 255 +
-                         ((255 - strength) * x)      / 255;
-
-    /* Output the equalized frame. */
-    memset(histeq->out_histogram, 0, sizeof(histeq->out_histogram));
-
-    src = inpic->data[0];
-    dst = outpic->data[0];
-    for (y = 0; y < inlink->h; y++) {
-        for (x = 0; x < inlink->w * histeq->bpp; x += histeq->bpp) {
-            luma = dst[x + histeq->rgba_map[A]];
-            if (luma == 0) {
-                for (i = 0; i < histeq->bpp; ++i)
-                    dst[x + i] = 0;
-                histeq->out_histogram[0]++;
-            } else {
-                lut = histeq->LUT[luma];
-                if (histeq->antibanding != HISTEQ_ANTIBANDING_NONE) {
-                    if (luma > 0) {
-                        lutlo = histeq->antibanding == HISTEQ_ANTIBANDING_WEAK ?
-                                (histeq->LUT[luma] + histeq->LUT[luma - 1]) / 2 :
-                                 histeq->LUT[luma - 1];
-                    } else
-                        lutlo = lut;
-
-                    if (luma < 255) {
-                        luthi = (histeq->antibanding == HISTEQ_ANTIBANDING_WEAK) ?
-                            (histeq->LUT[luma] + histeq->LUT[luma + 1]) / 2 :
-                             histeq->LUT[luma + 1];
-                    } else
-                        luthi = lut;
-
-                    if (lutlo != luthi) {
-                        jran = LCG(jran);
-                        lut = lutlo + ((luthi - lutlo + 1) * jran) / LCG_M;
-                    }
-                }
-
-                GET_RGB_VALUES(r, g, b, src, histeq->rgba_map);
-                if (((m = FFMAX3(r, g, b)) * lut) / luma > 255) {
-                    r = (r * 255) / m;
-                    g = (g * 255) / m;
-                    b = (b * 255) / m;
-                } else {
-                    r = (r * lut) / luma;
-                    g = (g * lut) / luma;
-                    b = (b * lut) / luma;
-                }
-                dst[x + histeq->rgba_map[R]] = r;
-                dst[x + histeq->rgba_map[G]] = g;
-                dst[x + histeq->rgba_map[B]] = b;
-                oluma = av_clip_uint8((55 * r + 182 * g + 19 * b) >> 8);
-                histeq->out_histogram[oluma]++;
-            }
-        }
-        src += inpic->linesize[0];
-        dst += outpic->linesize[0];
-    }
-#ifdef DEBUG
-    for (x = 0; x < 256; x++)
-        av_dlog(ctx, "out[%d]: %u\n", x, histeq->out_histogram[x]);
-#endif
-
-    av_frame_free(&inpic);
-    return ff_filter_frame(outlink, outpic);
-}
-
-static const AVFilterPad histeq_inputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .config_props = config_input,
-        .filter_frame = filter_frame,
-    },
-    { NULL }
-};
-
-static const AVFilterPad histeq_outputs[] = {
-    {
-        .name = "default",
-        .type = AVMEDIA_TYPE_VIDEO,
-    },
-    { NULL }
-};
-
-AVFilter ff_vf_histeq = {
-    .name          = "histeq",
-    .description   = NULL_IF_CONFIG_SMALL("Apply global color histogram equalization."),
-    .priv_size     = sizeof(HisteqContext),
-    .init          = init,
-    .query_formats = query_formats,
-    .inputs        = histeq_inputs,
-    .outputs       = histeq_outputs,
-    .priv_class    = &histeq_class,
-    .flags         = AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC,
-};
diff --git a/libavfilter/vf_hqdn3d.c b/libavfilter/vf_hqdn3d.c
deleted file mode 100644
index f96f238..0000000
--- a/libavfilter/vf_hqdn3d.c
+++ /dev/null
@@ -1,364 +0,0 @@
-/*
- * Copyright (c) 2003 Daniel Moreno <comac AT comac DOT darktech DOT org>
- * Copyright (c) 2010 Baptiste Coudurier
- * Copyright (c) 2012 Loren Merritt
- *
- * This file is part of FFmpeg, ported from MPlayer.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with FFmpeg; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-/**
- * @file
- * high quality 3d video denoiser, ported from MPlayer
- * libmpcodecs/vf_hqdn3d.c.
- */
-
-#include <float.h>
-
-#include "config.h"
-#include "libavutil/attributes.h"
-#include "libavutil/common.h"
-#include "libavutil/pixdesc.h"
-#include "libavutil/intreadwrite.h"
-#include "libavutil/opt.h"
-
-#include "avfilter.h"
-#include "formats.h"
-#include "internal.h"
-#include "video.h"
-#include "vf_hqdn3d.h"
-
-#define LUT_BITS (depth==16 ? 8 : 4)
-#define LOAD(x) (((depth == 8 ? src[x] : AV_RN16A(src + (x) * 2)) << (16 - depth))\
-                 + (((1 << (16 - depth)) - 1) >> 1))
-#define STORE(x,val) (depth == 8 ? dst[x] = (val) >> (16 - depth) : \
-                                   AV_WN16A(dst + (x) * 2, (val) >> (16 - depth)))
-
-av_always_inline
-static uint32_t lowpass(int prev, int cur, int16_t *coef, int depth)
-{
-    int d = (prev - cur) >> (8 - LUT_BITS);
-    return cur + coef[d];
-}
-
-av_always_inline
-static void denoise_temporal(uint8_t *src, uint8_t *dst,
-                             uint16_t *frame_ant,
-                             int w, int h, int sstride, int dstride,
-                             int16_t *temporal, int depth)
-{
-    long x, y;
-    uint32_t tmp;
-
-    temporal += 256 << LUT_BITS;
-
-    for (y = 0; y < h; y++) {
-        for (x = 0; x < w; x++) {
-            frame_ant[x] = tmp = lowpass(frame_ant[x], LOAD(x), temporal, depth);
-            STORE(x, tmp);
-        }
-        src += sstride;
-        dst += dstride;
-        frame_ant += w;
-    }
-}
-
-av_always_inline
-static void denoise_spatial(HQDN3DContext *s,
-                            uint8_t *src, uint8_t *dst,
-                            uint16_t *line_ant, uint16_t *frame_ant,
-                            int w, int h, int sstride, int dstride,
-                            int16_t *spatial, int16_t *temporal, int depth)
-{
-    long x, y;
-    uint32_t pixel_ant;
-    uint32_t tmp;
-
-    spatial  += 256 << LUT_BITS;
-    temporal += 256 << LUT_BITS;
-
-    /* First line has no top neighbor. Only left one for each tmp and
-     * last frame */
-    pixel_ant = LOAD(0);
-    for (x = 0; x < w; x++) {
-        line_ant[x] = tmp = pixel_ant = lowpass(pixel_ant, LOAD(x), spatial, depth);
-        frame_ant[x] = tmp = lowpass(frame_ant[x], tmp, temporal, depth);
-        STORE(x, tmp);
-    }
-
-    for (y = 1; y < h; y++) {
-        src += sstride;
-        dst += dstride;
-        frame_ant += w;
-        if (s->denoise_row[depth]) {
-            s->denoise_row[depth](src, dst, line_ant, frame_ant, w, spatial, temporal);
-            continue;
-        }
-        pixel_ant = LOAD(0);
-        for (x = 0; x < w-1; x++) {
-            line_ant[x] = tmp = lowpass(line_ant[x], pixel_ant, spatial, depth);
-            pixel_ant = lowpass(pixel_ant, LOAD(x+1), spatial, depth);
-            frame_ant[x] = tmp = lowpass(frame_ant[x], tmp, temporal, depth);
-            STORE(x, tmp);
-        }
-        line_ant[x] = tmp = lowpass(line_ant[x], pixel_ant, spatial, depth);
-        frame_ant[x] = tmp = lowpass(frame_ant[x], tmp, temporal, depth);
-        STORE(x, tmp);
-    }
-}
-
-av_always_inline
-static void denoise_depth(HQDN3DContext *s,
-                          uint8_t *src, uint8_t *dst,
-                          uint16_t *line_ant, uint16_t **frame_ant_ptr,
-                          int w, int h, int sstride, int dstride,
-                          int16_t *spatial, int16_t *temporal, int depth)
-{
-    // FIXME: For 16bit depth, frame_ant could be a pointer to the previous
-    // filtered frame rather than a separate buffer.
-    long x, y;
-    uint16_t *frame_ant = *frame_ant_ptr;
-    if (!frame_ant) {
-        uint8_t *frame_src = src;
-        *frame_ant_ptr = frame_ant = av_malloc(w*h*sizeof(uint16_t));
-        for (y = 0; y < h; y++, src += sstride, frame_ant += w)
-            for (x = 0; x < w; x++)
-                frame_ant[x] = LOAD(x);
-        src = frame_src;
-        frame_ant = *frame_ant_ptr;
-    }
-
-    if (spatial[0])
-        denoise_spatial(s, src, dst, line_ant, frame_ant,
-                        w, h, sstride, dstride, spatial, temporal, depth);
-    else
-        denoise_temporal(src, dst, frame_ant,
-                         w, h, sstride, dstride, temporal, depth);
-    emms_c();
-}
-
-#define denoise(...) \
-    switch (s->depth) {\
-        case  8: denoise_depth(__VA_ARGS__,  8); break;\
-        case  9: denoise_depth(__VA_ARGS__,  9); break;\
-        case 10: denoise_depth(__VA_ARGS__, 10); break;\
-        case 16: denoise_depth(__VA_ARGS__, 16); break;\
-    }
-
-static int16_t *precalc_coefs(double dist25, int depth)
-{
-    int i;
-    double gamma, simil, C;
-    int16_t *ct = av_malloc((512<<LUT_BITS)*sizeof(int16_t));
-    if (!ct)
-        return NULL;
-
-    gamma = log(0.25) / log(1.0 - FFMIN(dist25,252.0)/255.0 - 0.00001);
-
-    for (i = -255<<LUT_BITS; i <= 255<<LUT_BITS; i++) {
-        double f = ((i<<(9-LUT_BITS)) + (1<<(8-LUT_BITS)) - 1) / 512.0; // midpoint of the bin
-        simil = 1.0 - FFABS(f) / 255.0;
-        C = pow(simil, gamma) * 256.0 * f;
-        ct[(256<<LUT_BITS)+i] = lrint(C);
-    }
-
-    ct[0] = !!dist25;
-    return ct;
-}
-
-#define PARAM1_DEFAULT 4.0
-#define PARAM2_DEFAULT 3.0
-#define PARAM3_DEFAULT 6.0
-
-static av_cold int init(AVFilterContext *ctx)
-{
-    HQDN3DContext *s = ctx->priv;
-
-    if (!s->strength[LUMA_SPATIAL])
-        s->strength[LUMA_SPATIAL] = PARAM1_DEFAULT;
-    if (!s->strength[CHROMA_SPATIAL])
-        s->strength[CHROMA_SPATIAL] = PARAM2_DEFAULT * s->strength[LUMA_SPATIAL] / PARAM1_DEFAULT;
-    if (!s->strength[LUMA_TMP])
-        s->strength[LUMA_TMP]   = PARAM3_DEFAULT * s->strength[LUMA_SPATIAL] / PARAM1_DEFAULT;
-    if (!s->strength[CHROMA_TMP])
-        s->strength[CHROMA_TMP] = s->strength[LUMA_TMP] * s->strength[CHROMA_SPATIAL] / s->strength[LUMA_SPATIAL];
-
-    av_log(ctx, AV_LOG_VERBOSE, "ls:%f cs:%f lt:%f ct:%f\n",
-           s->strength[LUMA_SPATIAL], s->strength[CHROMA_SPATIAL],
-           s->strength[LUMA_TMP], s->strength[CHROMA_TMP]);
-
-    return 0;
-}
-
-static av_cold void uninit(AVFilterContext *ctx)
-{
-    HQDN3DContext *s = ctx->priv;
-
-    av_freep(&s->coefs[0]);
-    av_freep(&s->coefs[1]);
-    av_freep(&s->coefs[2]);
-    av_freep(&s->coefs[3]);
-    av_freep(&s->line);
-    av_freep(&s->frame_prev[0]);
-    av_freep(&s->frame_prev[1]);
-    av_freep(&s->frame_prev[2]);
-}
-
-static int query_formats(AVFilterContext *ctx)
-{
-    static const enum AVPixelFormat pix_fmts[] = {
-        AV_PIX_FMT_YUV420P,
-        AV_PIX_FMT_YUV422P,
-        AV_PIX_FMT_YUV444P,
-        AV_PIX_FMT_YUV410P,
-        AV_PIX_FMT_YUV411P,
-        AV_PIX_FMT_YUV440P,
-        AV_PIX_FMT_YUVJ420P,
-        AV_PIX_FMT_YUVJ422P,
-        AV_PIX_FMT_YUVJ444P,
-        AV_PIX_FMT_YUVJ440P,
-        AV_PIX_FMT_YUV420P9,
-        AV_PIX_FMT_YUV422P9,
-        AV_PIX_FMT_YUV444P9,
-        AV_PIX_FMT_YUV420P10,
-        AV_PIX_FMT_YUV422P10,
-        AV_PIX_FMT_YUV444P10,
-        AV_PIX_FMT_YUV420P16,
-        AV_PIX_FMT_YUV422P16,
-        AV_PIX_FMT_YUV444P16,
-        AV_PIX_FMT_NONE
-    };
-
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-
-    return 0;
-}
-
-static int config_input(AVFilterLink *inlink)
-{
-    HQDN3DContext *s = inlink->dst->priv;
-    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);
-    int i;
-
-    uninit(inlink->dst);
-
-    s->hsub  = desc->log2_chroma_w;
-    s->vsub  = desc->log2_chroma_h;
-    s->depth = desc->comp[0].depth_minus1+1;
-
-    s->line = av_malloc(inlink->w * sizeof(*s->line));
-    if (!s->line)
-        return AVERROR(ENOMEM);
-
-    for (i = 0; i < 4; i++) {
-        s->coefs[i] = precalc_coefs(s->strength[i], s->depth);
-        if (!s->coefs[i])
-            return AVERROR(ENOMEM);
-    }
-
-    if (ARCH_X86)
-        ff_hqdn3d_init_x86(s);
-
-    return 0;
-}
-
-static int filter_frame(AVFilterLink *inlink, AVFrame *in)
-{
-    AVFilterContext *ctx  = inlink->dst;
-    HQDN3DContext *s = ctx->priv;
-    AVFilterLink *outlink = ctx->outputs[0];
-
-    AVFrame *out;
-    int direct, c;
-
-    if (av_frame_is_writable(in) && !ctx->is_disabled) {
-        direct = 1;
-        out = in;
-    } else {
-        direct = 0;
-        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
-        if (!out) {
-            av_frame_free(&in);
-            return AVERROR(ENOMEM);
-        }
-
-        av_frame_copy_props(out, in);
-    }
-
-    for (c = 0; c < 3; c++) {
-        denoise(s, in->data[c], out->data[c],
-                s->line, &s->frame_prev[c],
-                FF_CEIL_RSHIFT(in->width,  (!!c * s->hsub)),
-                FF_CEIL_RSHIFT(in->height, (!!c * s->vsub)),
-                in->linesize[c], out->linesize[c],
-                s->coefs[c ? CHROMA_SPATIAL : LUMA_SPATIAL],
-                s->coefs[c ? CHROMA_TMP     : LUMA_TMP]);
-    }
-
-    if (ctx->is_disabled) {
-        av_frame_free(&out);
-        return ff_filter_frame(outlink, in);
-    }
-
-    if (!direct)
-        av_frame_free(&in);
-
-    return ff_filter_frame(outlink, out);
-}
-
-#define OFFSET(x) offsetof(HQDN3DContext, x)
-#define FLAGS AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_FILTERING_PARAM
-static const AVOption hqdn3d_options[] = {
-    { "luma_spatial",   "spatial luma strength",    OFFSET(strength[LUMA_SPATIAL]),   AV_OPT_TYPE_DOUBLE, { .dbl = 0.0 }, 0, DBL_MAX, FLAGS },
-    { "chroma_spatial", "spatial chroma strength",  OFFSET(strength[CHROMA_SPATIAL]), AV_OPT_TYPE_DOUBLE, { .dbl = 0.0 }, 0, DBL_MAX, FLAGS },
-    { "luma_tmp",       "temporal luma strength",   OFFSET(strength[LUMA_TMP]),       AV_OPT_TYPE_DOUBLE, { .dbl = 0.0 }, 0, DBL_MAX, FLAGS },
-    { "chroma_tmp",     "temporal chroma strength", OFFSET(strength[CHROMA_TMP]),     AV_OPT_TYPE_DOUBLE, { .dbl = 0.0 }, 0, DBL_MAX, FLAGS },
-    { NULL }
-};
-
-AVFILTER_DEFINE_CLASS(hqdn3d);
-
-static const AVFilterPad avfilter_vf_hqdn3d_inputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .config_props = config_input,
-        .filter_frame = filter_frame,
-    },
-    { NULL }
-};
-
-
-static const AVFilterPad avfilter_vf_hqdn3d_outputs[] = {
-    {
-        .name = "default",
-        .type = AVMEDIA_TYPE_VIDEO
-    },
-    { NULL }
-};
-
-AVFilter ff_vf_hqdn3d = {
-    .name          = "hqdn3d",
-    .description   = NULL_IF_CONFIG_SMALL("Apply a High Quality 3D Denoiser."),
-    .priv_size     = sizeof(HQDN3DContext),
-    .priv_class    = &hqdn3d_class,
-    .init          = init,
-    .uninit        = uninit,
-    .query_formats = query_formats,
-    .inputs        = avfilter_vf_hqdn3d_inputs,
-    .outputs       = avfilter_vf_hqdn3d_outputs,
-    .flags         = AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL,
-};
diff --git a/libavfilter/vf_kerndeint.c b/libavfilter/vf_kerndeint.c
deleted file mode 100644
index 1f8e091..0000000
--- a/libavfilter/vf_kerndeint.c
+++ /dev/null
@@ -1,318 +0,0 @@
-/*
- * Copyright (c) 2012 Jeremy Tran
- * Copyright (c) 2004 Tobias Diedrich
- * Copyright (c) 2003 Donald A. Graft
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with FFmpeg; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-/**
- * @file
- * Kernel Deinterlacer
- * Ported from MPlayer libmpcodecs/vf_kerndeint.c.
- */
-
-#include "libavutil/imgutils.h"
-#include "libavutil/intreadwrite.h"
-#include "libavutil/opt.h"
-#include "libavutil/pixdesc.h"
-
-#include "avfilter.h"
-#include "formats.h"
-#include "internal.h"
-
-typedef struct {
-    const AVClass *class;
-    int           frame; ///< frame count, starting from 0
-    int           thresh, map, order, sharp, twoway;
-    int           vsub;
-    int           is_packed_rgb;
-    uint8_t       *tmp_data    [4];  ///< temporary plane data buffer
-    int            tmp_linesize[4];  ///< temporary plane byte linesize
-    int            tmp_bwidth  [4];  ///< temporary plane byte width
-} KerndeintContext;
-
-#define OFFSET(x) offsetof(KerndeintContext, x)
-#define FLAGS AV_OPT_FLAG_VIDEO_PARAM|AV_OPT_FLAG_FILTERING_PARAM
-static const AVOption kerndeint_options[] = {
-    { "thresh", "set the threshold", OFFSET(thresh), AV_OPT_TYPE_INT, {.i64=10}, 0, 255, FLAGS },
-    { "map",    "set the map", OFFSET(map), AV_OPT_TYPE_INT, {.i64=0}, 0, 1, FLAGS },
-    { "order",  "set the order", OFFSET(order), AV_OPT_TYPE_INT, {.i64=0}, 0, 1, FLAGS },
-    { "sharp",  "enable sharpening", OFFSET(sharp), AV_OPT_TYPE_INT, {.i64=0}, 0, 1, FLAGS },
-    { "twoway", "enable twoway", OFFSET(twoway), AV_OPT_TYPE_INT, {.i64=0}, 0, 1, FLAGS },
-    { NULL }
-};
-
-AVFILTER_DEFINE_CLASS(kerndeint);
-
-static av_cold void uninit(AVFilterContext *ctx)
-{
-    KerndeintContext *kerndeint = ctx->priv;
-
-    av_free(kerndeint->tmp_data[0]);
-}
-
-static int query_formats(AVFilterContext *ctx)
-{
-    static const enum PixelFormat pix_fmts[] = {
-        AV_PIX_FMT_YUV420P,
-        AV_PIX_FMT_YUYV422,
-        AV_PIX_FMT_ARGB, AV_PIX_FMT_0RGB,
-        AV_PIX_FMT_ABGR, AV_PIX_FMT_0BGR,
-        AV_PIX_FMT_RGBA, AV_PIX_FMT_RGB0,
-        AV_PIX_FMT_BGRA, AV_PIX_FMT_BGR0,
-        AV_PIX_FMT_NONE
-    };
-
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-
-    return 0;
-}
-
-static int config_props(AVFilterLink *inlink)
-{
-    KerndeintContext *kerndeint = inlink->dst->priv;
-    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);
-    int ret;
-
-    kerndeint->is_packed_rgb = av_pix_fmt_desc_get(inlink->format)->flags & AV_PIX_FMT_FLAG_RGB;
-    kerndeint->vsub = desc->log2_chroma_h;
-
-    ret = av_image_alloc(kerndeint->tmp_data, kerndeint->tmp_linesize,
-                         inlink->w, inlink->h, inlink->format, 16);
-    if (ret < 0)
-        return ret;
-    memset(kerndeint->tmp_data[0], 0, ret);
-
-    if ((ret = av_image_fill_linesizes(kerndeint->tmp_bwidth, inlink->format, inlink->w)) < 0)
-        return ret;
-
-    return 0;
-}
-
-static int filter_frame(AVFilterLink *inlink, AVFrame *inpic)
-{
-    KerndeintContext *kerndeint = inlink->dst->priv;
-    AVFilterLink *outlink = inlink->dst->outputs[0];
-    AVFrame *outpic;
-    const uint8_t *prvp;   ///< Previous field's pixel line number n
-    const uint8_t *prvpp;  ///< Previous field's pixel line number (n - 1)
-    const uint8_t *prvpn;  ///< Previous field's pixel line number (n + 1)
-    const uint8_t *prvppp; ///< Previous field's pixel line number (n - 2)
-    const uint8_t *prvpnn; ///< Previous field's pixel line number (n + 2)
-    const uint8_t *prvp4p; ///< Previous field's pixel line number (n - 4)
-    const uint8_t *prvp4n; ///< Previous field's pixel line number (n + 4)
-
-    const uint8_t *srcp;   ///< Current field's pixel line number n
-    const uint8_t *srcpp;  ///< Current field's pixel line number (n - 1)
-    const uint8_t *srcpn;  ///< Current field's pixel line number (n + 1)
-    const uint8_t *srcppp; ///< Current field's pixel line number (n - 2)
-    const uint8_t *srcpnn; ///< Current field's pixel line number (n + 2)
-    const uint8_t *srcp3p; ///< Current field's pixel line number (n - 3)
-    const uint8_t *srcp3n; ///< Current field's pixel line number (n + 3)
-    const uint8_t *srcp4p; ///< Current field's pixel line number (n - 4)
-    const uint8_t *srcp4n; ///< Current field's pixel line number (n + 4)
-
-    uint8_t *dstp, *dstp_saved;
-    const uint8_t *srcp_saved;
-
-    int src_linesize, psrc_linesize, dst_linesize, bwidth;
-    int x, y, plane, val, hi, lo, g, h, n = kerndeint->frame++;
-    double valf;
-
-    const int thresh = kerndeint->thresh;
-    const int order  = kerndeint->order;
-    const int map    = kerndeint->map;
-    const int sharp  = kerndeint->sharp;
-    const int twoway = kerndeint->twoway;
-
-    const int is_packed_rgb = kerndeint->is_packed_rgb;
-
-    outpic = ff_get_video_buffer(outlink, outlink->w, outlink->h);
-    if (!outpic) {
-        av_frame_free(&inpic);
-        return AVERROR(ENOMEM);
-    }
-    av_frame_copy_props(outpic, inpic);
-    outpic->interlaced_frame = 0;
-
-    for (plane = 0; plane < 4 && inpic->data[plane] && inpic->linesize[plane]; plane++) {
-        h = plane == 0 ? inlink->h : FF_CEIL_RSHIFT(inlink->h, kerndeint->vsub);
-        bwidth = kerndeint->tmp_bwidth[plane];
-
-        srcp = srcp_saved = inpic->data[plane];
-        src_linesize      = inpic->linesize[plane];
-        psrc_linesize     = kerndeint->tmp_linesize[plane];
-        dstp = dstp_saved = outpic->data[plane];
-        dst_linesize      = outpic->linesize[plane];
-        srcp              = srcp_saved + (1 - order) * src_linesize;
-        dstp              = dstp_saved + (1 - order) * dst_linesize;
-
-        for (y = 0; y < h; y += 2) {
-            memcpy(dstp, srcp, bwidth);
-            srcp += 2 * src_linesize;
-            dstp += 2 * dst_linesize;
-        }
-
-        // Copy through the lines that will be missed below.
-        memcpy(dstp_saved + order            * dst_linesize, srcp_saved + (1 -     order) * src_linesize, bwidth);
-        memcpy(dstp_saved + (2 + order    )  * dst_linesize, srcp_saved + (3 -     order) * src_linesize, bwidth);
-        memcpy(dstp_saved + (h - 2 + order)  * dst_linesize, srcp_saved + (h - 1 - order) * src_linesize, bwidth);
-        memcpy(dstp_saved + (h - 4 + order)  * dst_linesize, srcp_saved + (h - 3 - order) * src_linesize, bwidth);
-
-        /* For the other field choose adaptively between using the previous field
-           or the interpolant from the current field. */
-        prvp   = kerndeint->tmp_data[plane] + 5 * psrc_linesize - (1 - order) * psrc_linesize;
-        prvpp  = prvp - psrc_linesize;
-        prvppp = prvp - 2 * psrc_linesize;
-        prvp4p = prvp - 4 * psrc_linesize;
-        prvpn  = prvp + psrc_linesize;
-        prvpnn = prvp + 2 * psrc_linesize;
-        prvp4n = prvp + 4 * psrc_linesize;
-
-        srcp   = srcp_saved + 5 * src_linesize - (1 - order) * src_linesize;
-        srcpp  = srcp - src_linesize;
-        srcppp = srcp - 2 * src_linesize;
-        srcp3p = srcp - 3 * src_linesize;
-        srcp4p = srcp - 4 * src_linesize;
-
-        srcpn  = srcp + src_linesize;
-        srcpnn = srcp + 2 * src_linesize;
-        srcp3n = srcp + 3 * src_linesize;
-        srcp4n = srcp + 4 * src_linesize;
-
-        dstp   = dstp_saved + 5 * dst_linesize - (1 - order) * dst_linesize;
-
-        for (y = 5 - (1 - order); y <= h - 5 - (1 - order); y += 2) {
-            for (x = 0; x < bwidth; x++) {
-                if (thresh == 0 || n == 0 ||
-                    (abs((int)prvp[x]  - (int)srcp[x])  > thresh) ||
-                    (abs((int)prvpp[x] - (int)srcpp[x]) > thresh) ||
-                    (abs((int)prvpn[x] - (int)srcpn[x]) > thresh)) {
-                    if (map) {
-                        g = x & ~3;
-
-                        if (is_packed_rgb) {
-                            AV_WB32(dstp + g, 0xffffffff);
-                            x = g + 3;
-                        } else if (inlink->format == AV_PIX_FMT_YUYV422) {
-                            // y <- 235, u <- 128, y <- 235, v <- 128
-                            AV_WB32(dstp + g, 0xeb80eb80);
-                            x = g + 3;
-                        } else {
-                            dstp[x] = plane == 0 ? 235 : 128;
-                        }
-                    } else {
-                        if (is_packed_rgb) {
-                            hi = 255;
-                            lo = 0;
-                        } else if (inlink->format == AV_PIX_FMT_YUYV422) {
-                            hi = x & 1 ? 240 : 235;
-                            lo = 16;
-                        } else {
-                            hi = plane == 0 ? 235 : 240;
-                            lo = 16;
-                        }
-
-                        if (sharp) {
-                            if (twoway) {
-                                valf = + 0.526 * ((int)srcpp[x] + (int)srcpn[x])
-                                    + 0.170 * ((int)srcp[x] + (int)prvp[x])
-                                    - 0.116 * ((int)srcppp[x] + (int)srcpnn[x] + (int)prvppp[x] + (int)prvpnn[x])
-                                    - 0.026 * ((int)srcp3p[x] + (int)srcp3n[x])
-                                    + 0.031 * ((int)srcp4p[x] + (int)srcp4n[x] + (int)prvp4p[x] + (int)prvp4n[x]);
-                            } else {
-                                valf = + 0.526 * ((int)srcpp[x] + (int)srcpn[x])
-                                    + 0.170 * ((int)prvp[x])
-                                    - 0.116 * ((int)prvppp[x] + (int)prvpnn[x])
-                                    - 0.026 * ((int)srcp3p[x] + (int)srcp3n[x])
-                                    + 0.031 * ((int)prvp4p[x] + (int)prvp4p[x]);
-                            }
-                            dstp[x] = av_clip(valf, lo, hi);
-                        } else {
-                            if (twoway) {
-                                val = (8 * ((int)srcpp[x] + (int)srcpn[x]) + 2 * ((int)srcp[x] + (int)prvp[x])
-                                       - (int)(srcppp[x]) - (int)(srcpnn[x])
-                                       - (int)(prvppp[x]) - (int)(prvpnn[x])) >> 4;
-                            } else {
-                                val = (8 * ((int)srcpp[x] + (int)srcpn[x]) + 2 * ((int)prvp[x])
-                                       - (int)(prvppp[x]) - (int)(prvpnn[x])) >> 4;
-                            }
-                            dstp[x] = av_clip(val, lo, hi);
-                        }
-                    }
-                } else {
-                    dstp[x] = srcp[x];
-                }
-            }
-            prvp   += 2 * psrc_linesize;
-            prvpp  += 2 * psrc_linesize;
-            prvppp += 2 * psrc_linesize;
-            prvpn  += 2 * psrc_linesize;
-            prvpnn += 2 * psrc_linesize;
-            prvp4p += 2 * psrc_linesize;
-            prvp4n += 2 * psrc_linesize;
-            srcp   += 2 * src_linesize;
-            srcpp  += 2 * src_linesize;
-            srcppp += 2 * src_linesize;
-            srcp3p += 2 * src_linesize;
-            srcp4p += 2 * src_linesize;
-            srcpn  += 2 * src_linesize;
-            srcpnn += 2 * src_linesize;
-            srcp3n += 2 * src_linesize;
-            srcp4n += 2 * src_linesize;
-            dstp   += 2 * dst_linesize;
-        }
-
-        srcp = inpic->data[plane];
-        dstp = kerndeint->tmp_data[plane];
-        av_image_copy_plane(dstp, psrc_linesize, srcp, src_linesize, bwidth, h);
-    }
-
-    av_frame_free(&inpic);
-    return ff_filter_frame(outlink, outpic);
-}
-
-static const AVFilterPad kerndeint_inputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .filter_frame = filter_frame,
-        .config_props = config_props,
-    },
-    { NULL }
-};
-
-static const AVFilterPad kerndeint_outputs[] = {
-    {
-        .name = "default",
-        .type = AVMEDIA_TYPE_VIDEO,
-    },
-    { NULL }
-};
-
-
-AVFilter ff_vf_kerndeint = {
-    .name          = "kerndeint",
-    .description   = NULL_IF_CONFIG_SMALL("Apply kernel deinterlacing to the input."),
-    .priv_size     = sizeof(KerndeintContext),
-    .priv_class    = &kerndeint_class,
-    .uninit        = uninit,
-    .query_formats = query_formats,
-    .inputs        = kerndeint_inputs,
-    .outputs       = kerndeint_outputs,
-};
diff --git a/libavfilter/vf_mcdeint.c b/libavfilter/vf_mcdeint.c
deleted file mode 100644
index 2aa2e27..0000000
--- a/libavfilter/vf_mcdeint.c
+++ /dev/null
@@ -1,315 +0,0 @@
-/*
- * Copyright (c) 2006 Michael Niedermayer <michaelni@gmx.at>
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with FFmpeg; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-/**
- * @file
- * Motion Compensation Deinterlacer
- * Ported from MPlayer libmpcodecs/vf_mcdeint.c.
- *
- * Known Issues:
- *
- * The motion estimation is somewhat at the mercy of the input, if the
- * input frames are created purely based on spatial interpolation then
- * for example a thin black line or another random and not
- * interpolateable pattern will cause problems.
- * Note: completely ignoring the "unavailable" lines during motion
- * estimation did not look any better, so the most obvious solution
- * would be to improve tfields or penalize problematic motion vectors.
- *
- * If non iterative ME is used then snow currently ignores the OBMC
- * window and as a result sometimes creates artifacts.
- *
- * Only past frames are used, we should ideally use future frames too,
- * something like filtering the whole movie in forward and then
- * backward direction seems like a interesting idea but the current
- * filter framework is FAR from supporting such things.
- *
- * Combining the motion compensated image with the input image also is
- * not as trivial as it seems, simple blindly taking even lines from
- * one and odd ones from the other does not work at all as ME/MC
- * sometimes has nothing in the previous frames which matches the
- * current. The current algorithm has been found by trial and error
- * and almost certainly can be improved...
- */
-
-#include "libavutil/opt.h"
-#include "libavutil/pixdesc.h"
-#include "libavcodec/avcodec.h"
-#include "avfilter.h"
-#include "formats.h"
-#include "internal.h"
-
-enum MCDeintMode {
-    MODE_FAST = 0,
-    MODE_MEDIUM,
-    MODE_SLOW,
-    MODE_EXTRA_SLOW,
-    MODE_NB,
-};
-
-enum MCDeintParity {
-    PARITY_TFF  =  0, ///< top field first
-    PARITY_BFF  =  1, ///< bottom field first
-};
-
-typedef struct {
-    const AVClass *class;
-    enum MCDeintMode mode;
-    enum MCDeintParity parity;
-    int qp;
-    AVCodecContext *enc_ctx;
-} MCDeintContext;
-
-#define OFFSET(x) offsetof(MCDeintContext, x)
-#define FLAGS AV_OPT_FLAG_VIDEO_PARAM|AV_OPT_FLAG_FILTERING_PARAM
-#define CONST(name, help, val, unit) { name, help, 0, AV_OPT_TYPE_CONST, {.i64=val}, INT_MIN, INT_MAX, FLAGS, unit }
-
-static const AVOption mcdeint_options[] = {
-    { "mode", "set mode", OFFSET(mode), AV_OPT_TYPE_INT, {.i64=MODE_FAST}, 0, MODE_NB-1, FLAGS, .unit="mode" },
-    CONST("fast",       NULL, MODE_FAST,       "mode"),
-    CONST("medium",     NULL, MODE_MEDIUM,     "mode"),
-    CONST("slow",       NULL, MODE_SLOW,       "mode"),
-    CONST("extra_slow", NULL, MODE_EXTRA_SLOW, "mode"),
-
-    { "parity", "set the assumed picture field parity", OFFSET(parity), AV_OPT_TYPE_INT, {.i64=PARITY_BFF}, -1, 1, FLAGS, "parity" },
-    CONST("tff", "assume top field first",    PARITY_TFF, "parity"),
-    CONST("bff", "assume bottom field first", PARITY_BFF, "parity"),
-
-    { "qp", "set qp", OFFSET(qp), AV_OPT_TYPE_INT, {.i64=1}, INT_MIN, INT_MAX, FLAGS },
-    { NULL }
-};
-
-AVFILTER_DEFINE_CLASS(mcdeint);
-
-static int config_props(AVFilterLink *inlink)
-{
-    AVFilterContext *ctx = inlink->dst;
-    MCDeintContext *mcdeint = ctx->priv;
-    AVCodec *enc;
-    AVCodecContext *enc_ctx;
-    AVDictionary *opts = NULL;
-    int ret;
-
-    if (!(enc = avcodec_find_encoder(AV_CODEC_ID_SNOW))) {
-        av_log(ctx, AV_LOG_ERROR, "Snow encoder is not enabled in libavcodec\n");
-        return AVERROR(EINVAL);
-    }
-
-    mcdeint->enc_ctx = avcodec_alloc_context3(enc);
-    if (!mcdeint->enc_ctx)
-        return AVERROR(ENOMEM);
-    enc_ctx = mcdeint->enc_ctx;
-    enc_ctx->width  = inlink->w;
-    enc_ctx->height = inlink->h;
-    enc_ctx->time_base = (AVRational){1,25};  // meaningless
-    enc_ctx->gop_size = 300;
-    enc_ctx->max_b_frames = 0;
-    enc_ctx->pix_fmt = AV_PIX_FMT_YUV420P;
-    enc_ctx->flags = CODEC_FLAG_QSCALE | CODEC_FLAG_LOW_DELAY;
-    enc_ctx->strict_std_compliance = FF_COMPLIANCE_EXPERIMENTAL;
-    enc_ctx->global_quality = 1;
-    enc_ctx->me_cmp = enc_ctx->me_sub_cmp = FF_CMP_SAD;
-    enc_ctx->mb_cmp = FF_CMP_SSE;
-    av_dict_set(&opts, "memc_only", "1", 0);
-
-    switch (mcdeint->mode) {
-    case MODE_EXTRA_SLOW:
-        enc_ctx->refs = 3;
-    case MODE_SLOW:
-        enc_ctx->me_method = ME_ITER;
-    case MODE_MEDIUM:
-        enc_ctx->flags |= CODEC_FLAG_4MV;
-        enc_ctx->dia_size = 2;
-    case MODE_FAST:
-        enc_ctx->flags |= CODEC_FLAG_QPEL;
-    }
-
-    ret = avcodec_open2(enc_ctx, enc, &opts);
-    av_dict_free(&opts);
-    if (ret < 0)
-        return ret;
-
-    return 0;
-}
-
-static av_cold void uninit(AVFilterContext *ctx)
-{
-    MCDeintContext *mcdeint = ctx->priv;
-
-    if (mcdeint->enc_ctx) {
-        avcodec_close(mcdeint->enc_ctx);
-        av_freep(&mcdeint->enc_ctx);
-    }
-}
-
-static int query_formats(AVFilterContext *ctx)
-{
-    static const enum PixelFormat pix_fmts[] = {
-        AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE
-    };
-
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-
-    return 0;
-}
-
-static int filter_frame(AVFilterLink *inlink, AVFrame *inpic)
-{
-    MCDeintContext *mcdeint = inlink->dst->priv;
-    AVFilterLink *outlink = inlink->dst->outputs[0];
-    AVFrame *outpic, *frame_dec;
-    AVPacket pkt;
-    int x, y, i, ret, got_frame = 0;
-
-    outpic = ff_get_video_buffer(outlink, outlink->w, outlink->h);
-    if (!outpic) {
-        av_frame_free(&inpic);
-        return AVERROR(ENOMEM);
-    }
-    av_frame_copy_props(outpic, inpic);
-    inpic->quality = mcdeint->qp * FF_QP2LAMBDA;
-
-    av_init_packet(&pkt);
-    pkt.data = NULL;    // packet data will be allocated by the encoder
-    pkt.size = 0;
-
-    ret = avcodec_encode_video2(mcdeint->enc_ctx, &pkt, inpic, &got_frame);
-    if (ret < 0)
-        goto end;
-
-    frame_dec = mcdeint->enc_ctx->coded_frame;
-
-    for (i = 0; i < 3; i++) {
-        int is_chroma = !!i;
-        int w = FF_CEIL_RSHIFT(inlink->w, is_chroma);
-        int h = FF_CEIL_RSHIFT(inlink->h, is_chroma);
-        int fils = frame_dec->linesize[i];
-        int srcs = inpic    ->linesize[i];
-        int dsts = outpic   ->linesize[i];
-
-        for (y = 0; y < h; y++) {
-            if ((y ^ mcdeint->parity) & 1) {
-                for (x = 0; x < w; x++) {
-                    uint8_t *filp = &frame_dec->data[i][x + y*fils];
-                    uint8_t *srcp = &inpic    ->data[i][x + y*srcs];
-                    uint8_t *dstp = &outpic   ->data[i][x + y*dsts];
-
-                    if (y > 0 && y < h-1){
-                        int is_edge = x < 3 || x > w-4;
-                        int diff0 = filp[-fils] - srcp[-srcs];
-                        int diff1 = filp[+fils] - srcp[+srcs];
-                        int temp = filp[0];
-
-#define DELTA(j) av_clip(j, -x, w-1-x)
-
-#define GET_SCORE_EDGE(j)\
-   FFABS(srcp[-srcs+DELTA(-1+(j))] - srcp[+srcs+DELTA(-1-(j))])+\
-   FFABS(srcp[-srcs+DELTA(j)     ] - srcp[+srcs+DELTA(  -(j))])+\
-   FFABS(srcp[-srcs+DELTA(1+(j)) ] - srcp[+srcs+DELTA( 1-(j))])
-
-#define GET_SCORE(j)\
-   FFABS(srcp[-srcs-1+(j)] - srcp[+srcs-1-(j)])+\
-   FFABS(srcp[-srcs  +(j)] - srcp[+srcs  -(j)])+\
-   FFABS(srcp[-srcs+1+(j)] - srcp[+srcs+1-(j)])
-
-#define CHECK_EDGE(j)\
-    {   int score = GET_SCORE_EDGE(j);\
-        if (score < spatial_score){\
-            spatial_score = score;\
-            diff0 = filp[-fils+DELTA(j)]    - srcp[-srcs+DELTA(j)];\
-            diff1 = filp[+fils+DELTA(-(j))] - srcp[+srcs+DELTA(-(j))];\
-
-#define CHECK(j)\
-    {   int score = GET_SCORE(j);\
-        if (score < spatial_score){\
-            spatial_score= score;\
-            diff0 = filp[-fils+(j)] - srcp[-srcs+(j)];\
-            diff1 = filp[+fils-(j)] - srcp[+srcs-(j)];\
-
-                        if (is_edge) {
-                            int spatial_score = GET_SCORE_EDGE(0) - 1;
-                            CHECK_EDGE(-1) CHECK_EDGE(-2) }} }}
-                            CHECK_EDGE( 1) CHECK_EDGE( 2) }} }}
-                        } else {
-                            int spatial_score = GET_SCORE(0) - 1;
-                            CHECK(-1) CHECK(-2) }} }}
-                            CHECK( 1) CHECK( 2) }} }}
-                        }
-
-
-                        if (diff0 + diff1 > 0)
-                            temp -= (diff0 + diff1 - FFABS(FFABS(diff0) - FFABS(diff1)) / 2) / 2;
-                        else
-                            temp -= (diff0 + diff1 + FFABS(FFABS(diff0) - FFABS(diff1)) / 2) / 2;
-                        *filp = *dstp = temp > 255U ? ~(temp>>31) : temp;
-                    } else {
-                        *dstp = *filp;
-                    }
-                }
-            }
-        }
-
-        for (y = 0; y < h; y++) {
-            if (!((y ^ mcdeint->parity) & 1)) {
-                for (x = 0; x < w; x++) {
-                    frame_dec->data[i][x + y*fils] =
-                    outpic   ->data[i][x + y*dsts] = inpic->data[i][x + y*srcs];
-                }
-            }
-        }
-    }
-    mcdeint->parity ^= 1;
-
-end:
-    av_free_packet(&pkt);
-    av_frame_free(&inpic);
-    if (ret < 0) {
-        av_frame_free(&outpic);
-        return ret;
-    }
-    return ff_filter_frame(outlink, outpic);
-}
-
-static const AVFilterPad mcdeint_inputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .filter_frame = filter_frame,
-        .config_props = config_props,
-    },
-    { NULL }
-};
-
-static const AVFilterPad mcdeint_outputs[] = {
-    {
-        .name = "default",
-        .type = AVMEDIA_TYPE_VIDEO,
-    },
-    { NULL }
-};
-
-AVFilter ff_vf_mcdeint = {
-    .name          = "mcdeint",
-    .description   = NULL_IF_CONFIG_SMALL("Apply motion compensating deinterlacing."),
-    .priv_size     = sizeof(MCDeintContext),
-    .uninit        = uninit,
-    .query_formats = query_formats,
-    .inputs        = mcdeint_inputs,
-    .outputs       = mcdeint_outputs,
-    .priv_class    = &mcdeint_class,
-};
diff --git a/libavfilter/vf_mp.c b/libavfilter/vf_mp.c
deleted file mode 100644
index 2c145ab..0000000
--- a/libavfilter/vf_mp.c
+++ /dev/null
@@ -1,794 +0,0 @@
-/*
- * Copyright (c) 2011 Michael Niedermayer
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * Parts of this file have been stolen from mplayer
- */
-
-/**
- * @file
- */
-
-#include "avfilter.h"
-#include "video.h"
-#include "formats.h"
-#include "internal.h"
-#include "libavutil/avassert.h"
-#include "libavutil/pixdesc.h"
-#include "libavutil/intreadwrite.h"
-#include "libavutil/imgutils.h"
-#include "libavutil/opt.h"
-
-#include "libmpcodecs/vf.h"
-#include "libmpcodecs/img_format.h"
-#include "libmpcodecs/cpudetect.h"
-#include "libmpcodecs/av_helpers.h"
-#include "libmpcodecs/libvo/fastmemcpy.h"
-
-#include "libswscale/swscale.h"
-
-
-//FIXME maybe link the orig in
-//XXX: identical pix_fmt must be following with each others
-static const struct {
-    int fmt;
-    enum AVPixelFormat pix_fmt;
-} conversion_map[] = {
-    {IMGFMT_ARGB, AV_PIX_FMT_ARGB},
-    {IMGFMT_BGRA, AV_PIX_FMT_BGRA},
-    {IMGFMT_BGR24, AV_PIX_FMT_BGR24},
-    {IMGFMT_BGR16BE, AV_PIX_FMT_RGB565BE},
-    {IMGFMT_BGR16LE, AV_PIX_FMT_RGB565LE},
-    {IMGFMT_BGR15BE, AV_PIX_FMT_RGB555BE},
-    {IMGFMT_BGR15LE, AV_PIX_FMT_RGB555LE},
-    {IMGFMT_BGR12BE, AV_PIX_FMT_RGB444BE},
-    {IMGFMT_BGR12LE, AV_PIX_FMT_RGB444LE},
-    {IMGFMT_BGR8,  AV_PIX_FMT_RGB8},
-    {IMGFMT_BGR4,  AV_PIX_FMT_RGB4},
-    {IMGFMT_BGR1,  AV_PIX_FMT_MONOBLACK},
-    {IMGFMT_RGB1,  AV_PIX_FMT_MONOBLACK},
-    {IMGFMT_RG4B,  AV_PIX_FMT_BGR4_BYTE},
-    {IMGFMT_BG4B,  AV_PIX_FMT_RGB4_BYTE},
-    {IMGFMT_RGB48LE, AV_PIX_FMT_RGB48LE},
-    {IMGFMT_RGB48BE, AV_PIX_FMT_RGB48BE},
-    {IMGFMT_ABGR, AV_PIX_FMT_ABGR},
-    {IMGFMT_RGBA, AV_PIX_FMT_RGBA},
-    {IMGFMT_RGB24, AV_PIX_FMT_RGB24},
-    {IMGFMT_RGB16BE, AV_PIX_FMT_BGR565BE},
-    {IMGFMT_RGB16LE, AV_PIX_FMT_BGR565LE},
-    {IMGFMT_RGB15BE, AV_PIX_FMT_BGR555BE},
-    {IMGFMT_RGB15LE, AV_PIX_FMT_BGR555LE},
-    {IMGFMT_RGB12BE, AV_PIX_FMT_BGR444BE},
-    {IMGFMT_RGB12LE, AV_PIX_FMT_BGR444LE},
-    {IMGFMT_RGB8,  AV_PIX_FMT_BGR8},
-    {IMGFMT_RGB4,  AV_PIX_FMT_BGR4},
-    {IMGFMT_BGR8,  AV_PIX_FMT_PAL8},
-    {IMGFMT_YUY2,  AV_PIX_FMT_YUYV422},
-    {IMGFMT_UYVY,  AV_PIX_FMT_UYVY422},
-    {IMGFMT_NV12,  AV_PIX_FMT_NV12},
-    {IMGFMT_NV21,  AV_PIX_FMT_NV21},
-    {IMGFMT_Y800,  AV_PIX_FMT_GRAY8},
-    {IMGFMT_Y8,    AV_PIX_FMT_GRAY8},
-    {IMGFMT_YVU9,  AV_PIX_FMT_YUV410P},
-    {IMGFMT_IF09,  AV_PIX_FMT_YUV410P},
-    {IMGFMT_YV12,  AV_PIX_FMT_YUV420P},
-    {IMGFMT_I420,  AV_PIX_FMT_YUV420P},
-    {IMGFMT_IYUV,  AV_PIX_FMT_YUV420P},
-    {IMGFMT_411P,  AV_PIX_FMT_YUV411P},
-    {IMGFMT_422P,  AV_PIX_FMT_YUV422P},
-    {IMGFMT_444P,  AV_PIX_FMT_YUV444P},
-    {IMGFMT_440P,  AV_PIX_FMT_YUV440P},
-
-    {IMGFMT_420A,  AV_PIX_FMT_YUVA420P},
-
-    {IMGFMT_420P16_LE,  AV_PIX_FMT_YUV420P16LE},
-    {IMGFMT_420P16_BE,  AV_PIX_FMT_YUV420P16BE},
-    {IMGFMT_422P16_LE,  AV_PIX_FMT_YUV422P16LE},
-    {IMGFMT_422P16_BE,  AV_PIX_FMT_YUV422P16BE},
-    {IMGFMT_444P16_LE,  AV_PIX_FMT_YUV444P16LE},
-    {IMGFMT_444P16_BE,  AV_PIX_FMT_YUV444P16BE},
-
-    // YUVJ are YUV formats that use the full Y range and not just
-    // 16 - 235 (see colorspaces.txt).
-    // Currently they are all treated the same way.
-    {IMGFMT_YV12,  AV_PIX_FMT_YUVJ420P},
-    {IMGFMT_422P,  AV_PIX_FMT_YUVJ422P},
-    {IMGFMT_444P,  AV_PIX_FMT_YUVJ444P},
-    {IMGFMT_440P,  AV_PIX_FMT_YUVJ440P},
-
-#if FF_API_XVMC
-    {IMGFMT_XVMC_MOCO_MPEG2, AV_PIX_FMT_XVMC_MPEG2_MC},
-    {IMGFMT_XVMC_IDCT_MPEG2, AV_PIX_FMT_XVMC_MPEG2_IDCT},
-#endif /* FF_API_XVMC */
-
-    {IMGFMT_VDPAU_MPEG1,     AV_PIX_FMT_VDPAU_MPEG1},
-    {IMGFMT_VDPAU_MPEG2,     AV_PIX_FMT_VDPAU_MPEG2},
-    {IMGFMT_VDPAU_H264,      AV_PIX_FMT_VDPAU_H264},
-    {IMGFMT_VDPAU_WMV3,      AV_PIX_FMT_VDPAU_WMV3},
-    {IMGFMT_VDPAU_VC1,       AV_PIX_FMT_VDPAU_VC1},
-    {IMGFMT_VDPAU_MPEG4,     AV_PIX_FMT_VDPAU_MPEG4},
-    {0, AV_PIX_FMT_NONE}
-};
-
-extern const vf_info_t ff_vf_info_eq2;
-extern const vf_info_t ff_vf_info_eq;
-extern const vf_info_t ff_vf_info_fspp;
-extern const vf_info_t ff_vf_info_ilpack;
-extern const vf_info_t ff_vf_info_pp7;
-extern const vf_info_t ff_vf_info_softpulldown;
-extern const vf_info_t ff_vf_info_uspp;
-
-
-static const vf_info_t* const filters[]={
-    &ff_vf_info_eq2,
-    &ff_vf_info_eq,
-    &ff_vf_info_fspp,
-    &ff_vf_info_ilpack,
-    &ff_vf_info_pp7,
-    &ff_vf_info_softpulldown,
-    &ff_vf_info_uspp,
-
-    NULL
-};
-
-/*
-Unsupported filters
-1bpp
-ass
-bmovl
-crop
-dvbscale
-flip
-expand
-format
-halfpack
-lavc
-lavcdeint
-noformat
-pp
-scale
-tfields
-vo
-yadif
-zrmjpeg
-*/
-
-CpuCaps ff_gCpuCaps; //FIXME initialize this so optims work
-
-enum AVPixelFormat ff_mp2ff_pix_fmt(int mp){
-    int i;
-    for(i=0; conversion_map[i].fmt && mp != conversion_map[i].fmt; i++)
-        ;
-    return mp == conversion_map[i].fmt ? conversion_map[i].pix_fmt : AV_PIX_FMT_NONE;
-}
-
-typedef struct {
-    const AVClass *class;
-    vf_instance_t vf;
-    vf_instance_t next_vf;
-    AVFilterContext *avfctx;
-    int frame_returned;
-    char *filter;
-    enum AVPixelFormat in_pix_fmt;
-} MPContext;
-
-#define OFFSET(x) offsetof(MPContext, x)
-#define FLAGS AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM
-static const AVOption mp_options[] = {
-    { "filter", "set MPlayer filter name and parameters", OFFSET(filter), AV_OPT_TYPE_STRING, {.str=NULL}, .flags = FLAGS },
-    { NULL }
-};
-
-AVFILTER_DEFINE_CLASS(mp);
-
-void ff_mp_msg(int mod, int lev, const char *format, ... ){
-    va_list va;
-    va_start(va, format);
-    //FIXME convert lev/mod
-    av_vlog(NULL, AV_LOG_DEBUG, format, va);
-    va_end(va);
-}
-
-int ff_mp_msg_test(int mod, int lev){
-    return 123;
-}
-
-void ff_init_avcodec(void)
-{
-    //we maybe should init but its kinda 1. unneeded 2. a bit inpolite from here
-}
-
-//Exact copy of vf.c
-void ff_vf_clone_mpi_attributes(mp_image_t* dst, mp_image_t* src){
-    dst->pict_type= src->pict_type;
-    dst->fields = src->fields;
-    dst->qscale_type= src->qscale_type;
-    if(dst->width == src->width && dst->height == src->height){
-        dst->qstride= src->qstride;
-        dst->qscale= src->qscale;
-    }
-}
-
-//Exact copy of vf.c
-void ff_vf_next_draw_slice(struct vf_instance *vf,unsigned char** src, int * stride,int w, int h, int x, int y){
-    if (vf->next->draw_slice) {
-        vf->next->draw_slice(vf->next,src,stride,w,h,x,y);
-        return;
-    }
-    if (!vf->dmpi) {
-        ff_mp_msg(MSGT_VFILTER,MSGL_ERR,"draw_slice: dmpi not stored by vf_%s\n", vf->info->name);
-        return;
-    }
-    if (!(vf->dmpi->flags & MP_IMGFLAG_PLANAR)) {
-        memcpy_pic(vf->dmpi->planes[0]+y*vf->dmpi->stride[0]+vf->dmpi->bpp/8*x,
-            src[0], vf->dmpi->bpp/8*w, h, vf->dmpi->stride[0], stride[0]);
-        return;
-    }
-    memcpy_pic(vf->dmpi->planes[0]+y*vf->dmpi->stride[0]+x, src[0],
-        w, h, vf->dmpi->stride[0], stride[0]);
-    memcpy_pic(vf->dmpi->planes[1]+(y>>vf->dmpi->chroma_y_shift)*vf->dmpi->stride[1]+(x>>vf->dmpi->chroma_x_shift),
-        src[1], w>>vf->dmpi->chroma_x_shift, h>>vf->dmpi->chroma_y_shift, vf->dmpi->stride[1], stride[1]);
-    memcpy_pic(vf->dmpi->planes[2]+(y>>vf->dmpi->chroma_y_shift)*vf->dmpi->stride[2]+(x>>vf->dmpi->chroma_x_shift),
-        src[2], w>>vf->dmpi->chroma_x_shift, h>>vf->dmpi->chroma_y_shift, vf->dmpi->stride[2], stride[2]);
-}
-
-//Exact copy of vf.c
-void ff_vf_mpi_clear(mp_image_t* mpi,int x0,int y0,int w,int h){
-    int y;
-    if(mpi->flags&MP_IMGFLAG_PLANAR){
-        y0&=~1;h+=h&1;
-        if(x0==0 && w==mpi->width){
-            // full width clear:
-            memset(mpi->planes[0]+mpi->stride[0]*y0,0,mpi->stride[0]*h);
-            memset(mpi->planes[1]+mpi->stride[1]*(y0>>mpi->chroma_y_shift),128,mpi->stride[1]*(h>>mpi->chroma_y_shift));
-            memset(mpi->planes[2]+mpi->stride[2]*(y0>>mpi->chroma_y_shift),128,mpi->stride[2]*(h>>mpi->chroma_y_shift));
-        } else
-        for(y=y0;y<y0+h;y+=2){
-            memset(mpi->planes[0]+x0+mpi->stride[0]*y,0,w);
-            memset(mpi->planes[0]+x0+mpi->stride[0]*(y+1),0,w);
-            memset(mpi->planes[1]+(x0>>mpi->chroma_x_shift)+mpi->stride[1]*(y>>mpi->chroma_y_shift),128,(w>>mpi->chroma_x_shift));
-            memset(mpi->planes[2]+(x0>>mpi->chroma_x_shift)+mpi->stride[2]*(y>>mpi->chroma_y_shift),128,(w>>mpi->chroma_x_shift));
-        }
-        return;
-    }
-    // packed:
-    for(y=y0;y<y0+h;y++){
-        unsigned char* dst=mpi->planes[0]+mpi->stride[0]*y+(mpi->bpp>>3)*x0;
-        if(mpi->flags&MP_IMGFLAG_YUV){
-            unsigned int* p=(unsigned int*) dst;
-            int size=(mpi->bpp>>3)*w/4;
-            int i;
-#if HAVE_BIGENDIAN
-#define CLEAR_PACKEDYUV_PATTERN 0x00800080
-#define CLEAR_PACKEDYUV_PATTERN_SWAPPED 0x80008000
-#else
-#define CLEAR_PACKEDYUV_PATTERN 0x80008000
-#define CLEAR_PACKEDYUV_PATTERN_SWAPPED 0x00800080
-#endif
-            if(mpi->flags&MP_IMGFLAG_SWAPPED){
-                for(i=0;i<size-3;i+=4) p[i]=p[i+1]=p[i+2]=p[i+3]=CLEAR_PACKEDYUV_PATTERN_SWAPPED;
-                for(;i<size;i++) p[i]=CLEAR_PACKEDYUV_PATTERN_SWAPPED;
-            } else {
-                for(i=0;i<size-3;i+=4) p[i]=p[i+1]=p[i+2]=p[i+3]=CLEAR_PACKEDYUV_PATTERN;
-                for(;i<size;i++) p[i]=CLEAR_PACKEDYUV_PATTERN;
-            }
-        } else
-            memset(dst,0,(mpi->bpp>>3)*w);
-    }
-}
-
-int ff_vf_next_query_format(struct vf_instance *vf, unsigned int fmt){
-    return 1;
-}
-
-//used by delogo
-unsigned int ff_vf_match_csp(vf_instance_t** vfp,const unsigned int* list,unsigned int preferred){
-    return preferred;
-}
-
-mp_image_t* ff_vf_get_image(vf_instance_t* vf, unsigned int outfmt, int mp_imgtype, int mp_imgflag, int w, int h){
-    MPContext *m= (MPContext*)(((uint8_t*)vf) - offsetof(MPContext, next_vf));
-  mp_image_t* mpi=NULL;
-  int w2;
-  int number = mp_imgtype >> 16;
-
-  av_assert0(vf->next == NULL); // all existing filters call this just on next
-
-  //vf_dint needs these as it calls ff_vf_get_image() before configuring the output
-  if(vf->w==0 && w>0) vf->w=w;
-  if(vf->h==0 && h>0) vf->h=h;
-
-  av_assert0(w == -1 || w >= vf->w);
-  av_assert0(h == -1 || h >= vf->h);
-  av_assert0(vf->w > 0);
-  av_assert0(vf->h > 0);
-
-  av_log(m->avfctx, AV_LOG_DEBUG, "get_image: %d:%d, vf: %d:%d\n", w,h,vf->w,vf->h);
-
-  if (w == -1) w = vf->w;
-  if (h == -1) h = vf->h;
-
-  w2=(mp_imgflag&MP_IMGFLAG_ACCEPT_ALIGNED_STRIDE)?((w+15)&(~15)):w;
-
-  // Note: we should call libvo first to check if it supports direct rendering
-  // and if not, then fallback to software buffers:
-  switch(mp_imgtype & 0xff){
-  case MP_IMGTYPE_EXPORT:
-    if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=ff_new_mp_image(w2,h);
-    mpi=vf->imgctx.export_images[0];
-    break;
-  case MP_IMGTYPE_STATIC:
-    if(!vf->imgctx.static_images[0]) vf->imgctx.static_images[0]=ff_new_mp_image(w2,h);
-    mpi=vf->imgctx.static_images[0];
-    break;
-  case MP_IMGTYPE_TEMP:
-    if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=ff_new_mp_image(w2,h);
-    mpi=vf->imgctx.temp_images[0];
-    break;
-  case MP_IMGTYPE_IPB:
-    if(!(mp_imgflag&MP_IMGFLAG_READABLE)){ // B frame:
-      if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=ff_new_mp_image(w2,h);
-      mpi=vf->imgctx.temp_images[0];
-      break;
-    }
-  case MP_IMGTYPE_IP:
-    if(!vf->imgctx.static_images[vf->imgctx.static_idx]) vf->imgctx.static_images[vf->imgctx.static_idx]=ff_new_mp_image(w2,h);
-    mpi=vf->imgctx.static_images[vf->imgctx.static_idx];
-    vf->imgctx.static_idx^=1;
-    break;
-  case MP_IMGTYPE_NUMBERED:
-    if (number == -1) {
-      int i;
-      for (i = 0; i < NUM_NUMBERED_MPI; i++)
-        if (!vf->imgctx.numbered_images[i] || !vf->imgctx.numbered_images[i]->usage_count)
-          break;
-      number = i;
-    }
-    if (number < 0 || number >= NUM_NUMBERED_MPI) return NULL;
-    if (!vf->imgctx.numbered_images[number]) vf->imgctx.numbered_images[number] = ff_new_mp_image(w2,h);
-    mpi = vf->imgctx.numbered_images[number];
-    mpi->number = number;
-    break;
-  }
-  if(mpi){
-    mpi->type=mp_imgtype;
-    mpi->w=vf->w; mpi->h=vf->h;
-    // keep buffer allocation status & color flags only:
-//    mpi->flags&=~(MP_IMGFLAG_PRESERVE|MP_IMGFLAG_READABLE|MP_IMGFLAG_DIRECT);
-    mpi->flags&=MP_IMGFLAG_ALLOCATED|MP_IMGFLAG_TYPE_DISPLAYED|MP_IMGFLAGMASK_COLORS;
-    // accept restrictions, draw_slice and palette flags only:
-    mpi->flags|=mp_imgflag&(MP_IMGFLAGMASK_RESTRICTIONS|MP_IMGFLAG_DRAW_CALLBACK|MP_IMGFLAG_RGB_PALETTE);
-    if(!vf->draw_slice) mpi->flags&=~MP_IMGFLAG_DRAW_CALLBACK;
-    if(mpi->width!=w2 || mpi->height!=h){
-//      printf("vf.c: MPI parameters changed!  %dx%d -> %dx%d   \n", mpi->width,mpi->height,w2,h);
-        if(mpi->flags&MP_IMGFLAG_ALLOCATED){
-            if(mpi->width<w2 || mpi->height<h){
-                // need to re-allocate buffer memory:
-                av_free(mpi->planes[0]);
-                mpi->flags&=~MP_IMGFLAG_ALLOCATED;
-                ff_mp_msg(MSGT_VFILTER,MSGL_V,"vf.c: have to REALLOCATE buffer memory :(\n");
-            }
-//      } else {
-        } {
-            mpi->width=w2; mpi->chroma_width=(w2 + (1<<mpi->chroma_x_shift) - 1)>>mpi->chroma_x_shift;
-            mpi->height=h; mpi->chroma_height=(h + (1<<mpi->chroma_y_shift) - 1)>>mpi->chroma_y_shift;
-        }
-    }
-    if(!mpi->bpp) ff_mp_image_setfmt(mpi,outfmt);
-    if(!(mpi->flags&MP_IMGFLAG_ALLOCATED) && mpi->type>MP_IMGTYPE_EXPORT){
-
-        av_assert0(!vf->get_image);
-        // check libvo first!
-        if(vf->get_image) vf->get_image(vf,mpi);
-
-        if(!(mpi->flags&MP_IMGFLAG_DIRECT)){
-          // non-direct and not yet allocated image. allocate it!
-          if (!mpi->bpp) { // no way we can allocate this
-              ff_mp_msg(MSGT_DECVIDEO, MSGL_FATAL,
-                     "ff_vf_get_image: Tried to allocate a format that can not be allocated!\n");
-              return NULL;
-          }
-
-          // check if codec prefer aligned stride:
-          if(mp_imgflag&MP_IMGFLAG_PREFER_ALIGNED_STRIDE){
-              int align=(mpi->flags&MP_IMGFLAG_PLANAR &&
-                         mpi->flags&MP_IMGFLAG_YUV) ?
-                         (8<<mpi->chroma_x_shift)-1 : 15; // -- maybe FIXME
-              w2=((w+align)&(~align));
-              if(mpi->width!=w2){
-#if 0
-                  // we have to change width... check if we CAN co it:
-                  int flags=vf->query_format(vf,outfmt); // should not fail
-                  if(!(flags&3)) ff_mp_msg(MSGT_DECVIDEO,MSGL_WARN,"??? ff_vf_get_image{vf->query_format(outfmt)} failed!\n");
-//                printf("query -> 0x%X    \n",flags);
-                  if(flags&VFCAP_ACCEPT_STRIDE){
-#endif
-                      mpi->width=w2;
-                      mpi->chroma_width=(w2 + (1<<mpi->chroma_x_shift) - 1)>>mpi->chroma_x_shift;
-//                  }
-              }
-          }
-
-          ff_mp_image_alloc_planes(mpi);
-//        printf("clearing img!\n");
-          ff_vf_mpi_clear(mpi,0,0,mpi->width,mpi->height);
-        }
-    }
-    av_assert0(!vf->start_slice);
-    if(mpi->flags&MP_IMGFLAG_DRAW_CALLBACK)
-        if(vf->start_slice) vf->start_slice(vf,mpi);
-    if(!(mpi->flags&MP_IMGFLAG_TYPE_DISPLAYED)){
-            ff_mp_msg(MSGT_DECVIDEO,MSGL_V,"*** [%s] %s%s mp_image_t, %dx%dx%dbpp %s %s, %d bytes\n",
-                  "NULL"/*vf->info->name*/,
-                  (mpi->type==MP_IMGTYPE_EXPORT)?"Exporting":
-                  ((mpi->flags&MP_IMGFLAG_DIRECT)?"Direct Rendering":"Allocating"),
-                  (mpi->flags&MP_IMGFLAG_DRAW_CALLBACK)?" (slices)":"",
-                  mpi->width,mpi->height,mpi->bpp,
-                  (mpi->flags&MP_IMGFLAG_YUV)?"YUV":((mpi->flags&MP_IMGFLAG_SWAPPED)?"BGR":"RGB"),
-                  (mpi->flags&MP_IMGFLAG_PLANAR)?"planar":"packed",
-                  mpi->bpp*mpi->width*mpi->height/8);
-            ff_mp_msg(MSGT_DECVIDEO,MSGL_DBG2,"(imgfmt: %x, planes: %p,%p,%p strides: %d,%d,%d, chroma: %dx%d, shift: h:%d,v:%d)\n",
-                mpi->imgfmt, mpi->planes[0], mpi->planes[1], mpi->planes[2],
-                mpi->stride[0], mpi->stride[1], mpi->stride[2],
-                mpi->chroma_width, mpi->chroma_height, mpi->chroma_x_shift, mpi->chroma_y_shift);
-            mpi->flags|=MP_IMGFLAG_TYPE_DISPLAYED;
-    }
-
-  mpi->qscale = NULL;
-  mpi->usage_count++;
-  }
-//    printf("\rVF_MPI: %p %p %p %d %d %d    \n",
-//      mpi->planes[0],mpi->planes[1],mpi->planes[2],
-//      mpi->stride[0],mpi->stride[1],mpi->stride[2]);
-  return mpi;
-}
-
-int ff_vf_next_put_image(struct vf_instance *vf,mp_image_t *mpi, double pts){
-    MPContext *m= (MPContext*)(((uint8_t*)vf) - offsetof(MPContext, vf));
-    AVFilterLink *outlink     = m->avfctx->outputs[0];
-    AVFrame *picref = av_frame_alloc();
-    int i;
-
-    av_assert0(vf->next);
-
-    av_log(m->avfctx, AV_LOG_DEBUG, "ff_vf_next_put_image\n");
-
-    if (!picref)
-        goto fail;
-
-    picref->width  = mpi->w;
-    picref->height = mpi->h;
-
-    picref->type = AVMEDIA_TYPE_VIDEO;
-
-    for(i=0; conversion_map[i].fmt && mpi->imgfmt != conversion_map[i].fmt; i++);
-    picref->format = conversion_map[i].pix_fmt;
-
-    for(i=0; conversion_map[i].fmt && m->in_pix_fmt != conversion_map[i].pix_fmt; i++);
-    if (mpi->imgfmt == conversion_map[i].fmt)
-        picref->format = conversion_map[i].pix_fmt;
-
-    memcpy(picref->linesize, mpi->stride, FFMIN(sizeof(picref->linesize), sizeof(mpi->stride)));
-
-    for(i=0; i<4 && mpi->stride[i]; i++){
-        picref->data[i] = mpi->planes[i];
-    }
-
-    if(pts != MP_NOPTS_VALUE)
-        picref->pts= pts * av_q2d(outlink->time_base);
-
-    if(1) { // mp buffers are currently unsupported in libavfilter, we thus must copy
-        AVFrame *tofree = picref;
-        picref = av_frame_clone(picref);
-        av_frame_free(&tofree);
-    }
-
-    ff_filter_frame(outlink, picref);
-    m->frame_returned++;
-
-    return 1;
-fail:
-    av_frame_free(&picref);
-    return 0;
-}
-
-int ff_vf_next_config(struct vf_instance *vf,
-        int width, int height, int d_width, int d_height,
-        unsigned int voflags, unsigned int outfmt){
-
-    av_assert0(width>0 && height>0);
-    vf->next->w = width; vf->next->h = height;
-
-    return 1;
-#if 0
-    int flags=vf->next->query_format(vf->next,outfmt);
-    if(!flags){
-        // hmm. colorspace mismatch!!!
-        //this is fatal for us ATM
-        return 0;
-    }
-    ff_mp_msg(MSGT_VFILTER,MSGL_V,"REQ: flags=0x%X  req=0x%X  \n",flags,vf->default_reqs);
-    miss=vf->default_reqs - (flags&vf->default_reqs);
-    if(miss&VFCAP_ACCEPT_STRIDE){
-        // vf requires stride support but vf->next doesn't support it!
-        // let's insert the 'expand' filter, it does the job for us:
-        vf_instance_t* vf2=vf_open_filter(vf->next,"expand",NULL);
-        if(!vf2) return 0; // shouldn't happen!
-        vf->next=vf2;
-    }
-    vf->next->w = width; vf->next->h = height;
-    return 1;
-#endif
-}
-
-int ff_vf_next_control(struct vf_instance *vf, int request, void* data){
-    MPContext *m= (MPContext*)(((uint8_t*)vf) - offsetof(MPContext, vf));
-    av_log(m->avfctx, AV_LOG_DEBUG, "Received control %d\n", request);
-    return 0;
-}
-
-static int vf_default_query_format(struct vf_instance *vf, unsigned int fmt){
-    MPContext *m= (MPContext*)(((uint8_t*)vf) - offsetof(MPContext, vf));
-    int i;
-    av_log(m->avfctx, AV_LOG_DEBUG, "query %X\n", fmt);
-
-    for(i=0; conversion_map[i].fmt; i++){
-        if(fmt==conversion_map[i].fmt)
-            return 1; //we suport all
-    }
-    return 0;
-}
-
-
-static av_cold int init(AVFilterContext *ctx)
-{
-    MPContext *m = ctx->priv;
-    int cpu_flags = av_get_cpu_flags();
-    char name[256];
-    const char *args;
-    int i;
-
-    ff_gCpuCaps.hasMMX      = cpu_flags & AV_CPU_FLAG_MMX;
-    ff_gCpuCaps.hasMMX2     = cpu_flags & AV_CPU_FLAG_MMX2;
-    ff_gCpuCaps.hasSSE      = cpu_flags & AV_CPU_FLAG_SSE;
-    ff_gCpuCaps.hasSSE2     = cpu_flags & AV_CPU_FLAG_SSE2;
-    ff_gCpuCaps.hasSSE3     = cpu_flags & AV_CPU_FLAG_SSE3;
-    ff_gCpuCaps.hasSSSE3    = cpu_flags & AV_CPU_FLAG_SSSE3;
-    ff_gCpuCaps.hasSSE4     = cpu_flags & AV_CPU_FLAG_SSE4;
-    ff_gCpuCaps.hasSSE42    = cpu_flags & AV_CPU_FLAG_SSE42;
-    ff_gCpuCaps.hasAVX      = cpu_flags & AV_CPU_FLAG_AVX;
-    ff_gCpuCaps.has3DNow    = cpu_flags & AV_CPU_FLAG_3DNOW;
-    ff_gCpuCaps.has3DNowExt = cpu_flags & AV_CPU_FLAG_3DNOWEXT;
-
-    m->avfctx= ctx;
-
-    args = m->filter;
-    if(!args || 1!=sscanf(args, "%255[^:=]", name)){
-        av_log(ctx, AV_LOG_ERROR, "Invalid parameter.\n");
-        return AVERROR(EINVAL);
-    }
-    args += strlen(name);
-    if (args[0] == '=')
-        args++;
-
-    for(i=0; ;i++){
-        if(!filters[i] || !strcmp(name, filters[i]->name))
-            break;
-    }
-
-    if(!filters[i]){
-        av_log(ctx, AV_LOG_ERROR, "Unknown filter %s\n", name);
-        return AVERROR(EINVAL);
-    }
-
-    av_log(ctx, AV_LOG_WARNING,
-           "'%s' is a wrapped MPlayer filter (libmpcodecs). This filter may be removed\n"
-           "once it has been ported to a native libavfilter.\n", name);
-
-    memset(&m->vf,0,sizeof(m->vf));
-    m->vf.info= filters[i];
-
-    m->vf.next        = &m->next_vf;
-    m->vf.put_image   = ff_vf_next_put_image;
-    m->vf.config      = ff_vf_next_config;
-    m->vf.query_format= vf_default_query_format;
-    m->vf.control     = ff_vf_next_control;
-    m->vf.default_caps=VFCAP_ACCEPT_STRIDE;
-    m->vf.default_reqs=0;
-    if(m->vf.info->opts)
-        av_log(ctx, AV_LOG_ERROR, "opts / m_struct_set is unsupported\n");
-#if 0
-    if(vf->info->opts) { // vf_vo get some special argument
-      const m_struct_t* st = vf->info->opts;
-      void* vf_priv = m_struct_alloc(st);
-      int n;
-      for(n = 0 ; args && args[2*n] ; n++)
-        m_struct_set(st,vf_priv,args[2*n],args[2*n+1]);
-      vf->priv = vf_priv;
-      args = NULL;
-    } else // Otherwise we should have the '_oldargs_'
-      if(args && !strcmp(args[0],"_oldargs_"))
-        args = (char**)args[1];
-      else
-        args = NULL;
-#endif
-    if(m->vf.info->vf_open(&m->vf, (char*)args)<=0){
-        av_log(ctx, AV_LOG_ERROR, "vf_open() of %s with arg=%s failed\n", name, args);
-        return -1;
-    }
-
-    return 0;
-}
-
-static av_cold void uninit(AVFilterContext *ctx)
-{
-    MPContext *m = ctx->priv;
-    vf_instance_t *vf = &m->vf;
-
-    while(vf){
-        vf_instance_t *next = vf->next;
-        if(vf->uninit)
-            vf->uninit(vf);
-        ff_free_mp_image(vf->imgctx.static_images[0]);
-        ff_free_mp_image(vf->imgctx.static_images[1]);
-        ff_free_mp_image(vf->imgctx.temp_images[0]);
-        ff_free_mp_image(vf->imgctx.export_images[0]);
-        vf = next;
-    }
-}
-
-static int query_formats(AVFilterContext *ctx)
-{
-    AVFilterFormats *avfmts=NULL;
-    MPContext *m = ctx->priv;
-    enum AVPixelFormat lastpixfmt = AV_PIX_FMT_NONE;
-    int i;
-
-    for(i=0; conversion_map[i].fmt; i++){
-        av_log(ctx, AV_LOG_DEBUG, "query: %X\n", conversion_map[i].fmt);
-        if(m->vf.query_format(&m->vf, conversion_map[i].fmt)){
-            av_log(ctx, AV_LOG_DEBUG, "supported,adding\n");
-            if (conversion_map[i].pix_fmt != lastpixfmt) {
-                ff_add_format(&avfmts, conversion_map[i].pix_fmt);
-                lastpixfmt = conversion_map[i].pix_fmt;
-            }
-        }
-    }
-
-    if (!avfmts)
-        return -1;
-
-    //We assume all allowed input formats are also allowed output formats
-    ff_set_common_formats(ctx, avfmts);
-    return 0;
-}
-
-static int config_inprops(AVFilterLink *inlink)
-{
-    MPContext *m = inlink->dst->priv;
-    int i;
-    for(i=0; conversion_map[i].fmt && conversion_map[i].pix_fmt != inlink->format; i++);
-
-    av_assert0(conversion_map[i].fmt && inlink->w && inlink->h);
-
-    m->vf.fmt.have_configured = 1;
-    m->vf.fmt.orig_height     = inlink->h;
-    m->vf.fmt.orig_width      = inlink->w;
-    m->vf.fmt.orig_fmt        = conversion_map[i].fmt;
-
-    if(m->vf.config(&m->vf, inlink->w, inlink->h, inlink->w, inlink->h, 0, conversion_map[i].fmt)<=0)
-        return -1;
-
-    return 0;
-}
-
-static int config_outprops(AVFilterLink *outlink)
-{
-    MPContext *m = outlink->src->priv;
-
-    outlink->w = m->next_vf.w;
-    outlink->h = m->next_vf.h;
-
-    return 0;
-}
-
-static int request_frame(AVFilterLink *outlink)
-{
-    MPContext *m = outlink->src->priv;
-    int ret;
-
-    av_log(m->avfctx, AV_LOG_DEBUG, "mp request_frame\n");
-
-    for(m->frame_returned=0; !m->frame_returned;){
-        ret=ff_request_frame(outlink->src->inputs[0]);
-        if(ret<0)
-            break;
-    }
-
-    av_log(m->avfctx, AV_LOG_DEBUG, "mp request_frame ret=%d\n", ret);
-    return ret;
-}
-
-static int filter_frame(AVFilterLink *inlink, AVFrame *inpic)
-{
-    MPContext *m = inlink->dst->priv;
-    int i;
-    double pts= MP_NOPTS_VALUE;
-    mp_image_t* mpi = ff_new_mp_image(inpic->width, inpic->height);
-
-    if(inpic->pts != AV_NOPTS_VALUE)
-        pts= inpic->pts / av_q2d(inlink->time_base);
-
-    for(i=0; conversion_map[i].fmt && conversion_map[i].pix_fmt != inlink->format; i++);
-    ff_mp_image_setfmt(mpi,conversion_map[i].fmt);
-    m->in_pix_fmt = inlink->format;
-
-    memcpy(mpi->planes, inpic->data,     FFMIN(sizeof(inpic->data)    , sizeof(mpi->planes)));
-    memcpy(mpi->stride, inpic->linesize, FFMIN(sizeof(inpic->linesize), sizeof(mpi->stride)));
-
-    if (inpic->interlaced_frame)
-        mpi->fields |= MP_IMGFIELD_INTERLACED;
-    if (inpic->top_field_first)
-        mpi->fields |= MP_IMGFIELD_TOP_FIRST;
-    if (inpic->repeat_pict)
-        mpi->fields |= MP_IMGFIELD_REPEAT_FIRST;
-
-    // mpi->flags|=MP_IMGFLAG_ALLOCATED; ?
-    mpi->flags |= MP_IMGFLAG_READABLE;
-    if(!av_frame_is_writable(inpic))
-        mpi->flags |= MP_IMGFLAG_PRESERVE;
-    if(m->vf.put_image(&m->vf, mpi, pts) == 0){
-        av_log(m->avfctx, AV_LOG_DEBUG, "put_image() says skip\n");
-    }else{
-        av_frame_free(&inpic);
-    }
-    ff_free_mp_image(mpi);
-    return 0;
-}
-
-static const AVFilterPad mp_inputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .filter_frame = filter_frame,
-        .config_props = config_inprops,
-    },
-    { NULL }
-};
-
-static const AVFilterPad mp_outputs[] = {
-    {
-        .name          = "default",
-        .type          = AVMEDIA_TYPE_VIDEO,
-        .request_frame = request_frame,
-        .config_props  = config_outprops,
-    },
-    { NULL }
-};
-
-AVFilter ff_vf_mp = {
-    .name          = "mp",
-    .description   = NULL_IF_CONFIG_SMALL("Apply a libmpcodecs filter to the input video."),
-    .init          = init,
-    .uninit        = uninit,
-    .priv_size     = sizeof(MPContext),
-    .query_formats = query_formats,
-    .inputs        = mp_inputs,
-    .outputs       = mp_outputs,
-    .priv_class    = &mp_class,
-};
diff --git a/libavfilter/vf_owdenoise.c b/libavfilter/vf_owdenoise.c
deleted file mode 100644
index 95ba43b..0000000
--- a/libavfilter/vf_owdenoise.c
+++ /dev/null
@@ -1,342 +0,0 @@
-/*
- * Copyright (c) 2007 Michael Niedermayer <michaelni@gmx.at>
- * Copyright (c) 2013 Clment Bsch <u pkh me>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with FFmpeg; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-/**
- * @todo try to change to int
- * @todo try lifting based implementation
- * @todo optimize optimize optimize
- * @todo hard thresholding
- * @todo use QP to decide filter strength
- * @todo wavelet normalization / least squares optimal signal vs. noise thresholds
- */
-
-#include "libavutil/imgutils.h"
-#include "libavutil/opt.h"
-#include "libavutil/pixdesc.h"
-#include "avfilter.h"
-#include "internal.h"
-
-typedef struct {
-    const AVClass *class;
-    double luma_strength;
-    double chroma_strength;
-    int depth;
-    float *plane[16+1][4];
-    int linesize;
-    int hsub, vsub;
-} OWDenoiseContext;
-
-#define OFFSET(x) offsetof(OWDenoiseContext, x)
-#define FLAGS AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM
-static const AVOption owdenoise_options[] = {
-    { "depth",           "set depth",           OFFSET(depth),           AV_OPT_TYPE_INT,    {.i64 =   8}, 8,   16, FLAGS },
-    { "luma_strength",   "set luma strength",   OFFSET(luma_strength),   AV_OPT_TYPE_DOUBLE, {.dbl = 1.0}, 0, 1000, FLAGS },
-    { "ls",              "set luma strength",   OFFSET(luma_strength),   AV_OPT_TYPE_DOUBLE, {.dbl = 1.0}, 0, 1000, FLAGS },
-    { "chroma_strength", "set chroma strength", OFFSET(chroma_strength), AV_OPT_TYPE_DOUBLE, {.dbl = 1.0}, 0, 1000, FLAGS },
-    { "cs",              "set chroma strength", OFFSET(chroma_strength), AV_OPT_TYPE_DOUBLE, {.dbl = 1.0}, 0, 1000, FLAGS },
-    { NULL }
-};
-
-AVFILTER_DEFINE_CLASS(owdenoise);
-
-DECLARE_ALIGNED(8, static const uint8_t, dither)[8][8] = {
-    {  0,  48,  12,  60,   3,  51,  15,  63 },
-    { 32,  16,  44,  28,  35,  19,  47,  31 },
-    {  8,  56,   4,  52,  11,  59,   7,  55 },
-    { 40,  24,  36,  20,  43,  27,  39,  23 },
-    {  2,  50,  14,  62,   1,  49,  13,  61 },
-    { 34,  18,  46,  30,  33,  17,  45,  29 },
-    { 10,  58,   6,  54,   9,  57,   5,  53 },
-    { 42,  26,  38,  22,  41,  25,  37,  21 },
-};
-
-static const double coeff[2][5] = {
-    {
-         0.6029490182363579  * M_SQRT2,
-         0.2668641184428723  * M_SQRT2,
-        -0.07822326652898785 * M_SQRT2,
-        -0.01686411844287495 * M_SQRT2,
-         0.02674875741080976 * M_SQRT2,
-    },{
-         1.115087052456994   / M_SQRT2,
-        -0.5912717631142470  / M_SQRT2,
-        -0.05754352622849957 / M_SQRT2,
-         0.09127176311424948 / M_SQRT2,
-    }
-};
-
-static const double icoeff[2][5] = {
-    {
-         1.115087052456994   / M_SQRT2,
-         0.5912717631142470  / M_SQRT2,
-        -0.05754352622849957 / M_SQRT2,
-        -0.09127176311424948 / M_SQRT2,
-    },{
-         0.6029490182363579  * M_SQRT2,
-        -0.2668641184428723  * M_SQRT2,
-        -0.07822326652898785 * M_SQRT2,
-         0.01686411844287495 * M_SQRT2,
-         0.02674875741080976 * M_SQRT2,
-    }
-};
-
-static inline int mirror(int x, int w)
-{
-    while ((unsigned)x > (unsigned)w) {
-        x = -x;
-        if (x < 0)
-            x += 2 * w;
-    }
-    return x;
-}
-
-static inline void decompose(float *dst_l, float *dst_h, const float *src,
-                             int linesize, int w)
-{
-    int x, i;
-    for (x = 0; x < w; x++) {
-        double sum_l = src[x * linesize] * coeff[0][0];
-        double sum_h = src[x * linesize] * coeff[1][0];
-        for (i = 1; i <= 4; i++) {
-            const double s = src[mirror(x - i, w - 1) * linesize]
-                           + src[mirror(x + i, w - 1) * linesize];
-
-            sum_l += coeff[0][i] * s;
-            sum_h += coeff[1][i] * s;
-        }
-        dst_l[x * linesize] = sum_l;
-        dst_h[x * linesize] = sum_h;
-    }
-}
-
-static inline void compose(float *dst, const float *src_l, const float *src_h,
-                           int linesize, int w)
-{
-    int x, i;
-    for (x = 0; x < w; x++) {
-        double sum_l = src_l[x * linesize] * icoeff[0][0];
-        double sum_h = src_h[x * linesize] * icoeff[1][0];
-        for (i = 1; i <= 4; i++) {
-            const int x0 = mirror(x - i, w - 1) * linesize;
-            const int x1 = mirror(x + i, w - 1) * linesize;
-
-            sum_l += icoeff[0][i] * (src_l[x0] + src_l[x1]);
-            sum_h += icoeff[1][i] * (src_h[x0] + src_h[x1]);
-        }
-        dst[x * linesize] = (sum_l + sum_h) * 0.5;
-    }
-}
-
-static inline void decompose2D(float *dst_l, float *dst_h, const float *src,
-                               int xlinesize, int ylinesize,
-                               int step, int w, int h)
-{
-    int y, x;
-    for (y = 0; y < h; y++)
-        for (x = 0; x < step; x++)
-            decompose(dst_l + ylinesize*y + xlinesize*x,
-                      dst_h + ylinesize*y + xlinesize*x,
-                      src   + ylinesize*y + xlinesize*x,
-                      step * xlinesize, (w - x + step - 1) / step);
-}
-
-static inline void compose2D(float *dst, const float *src_l, const float *src_h,
-                             int xlinesize, int ylinesize,
-                             int step, int w, int h)
-{
-    int y, x;
-    for (y = 0; y < h; y++)
-        for (x = 0; x < step; x++)
-            compose(dst   + ylinesize*y + xlinesize*x,
-                    src_l + ylinesize*y + xlinesize*x,
-                    src_h + ylinesize*y + xlinesize*x,
-                    step * xlinesize, (w - x + step - 1) / step);
-}
-
-static void decompose2D2(float *dst[4], float *src, float *temp[2],
-                         int linesize, int step, int w, int h)
-{
-    decompose2D(temp[0], temp[1], src,     1, linesize, step, w, h);
-    decompose2D( dst[0],  dst[1], temp[0], linesize, 1, step, h, w);
-    decompose2D( dst[2],  dst[3], temp[1], linesize, 1, step, h, w);
-}
-
-static void compose2D2(float *dst, float *src[4], float *temp[2],
-                       int linesize, int step, int w, int h)
-{
-    compose2D(temp[0],  src[0],  src[1], linesize, 1, step, h, w);
-    compose2D(temp[1],  src[2],  src[3], linesize, 1, step, h, w);
-    compose2D(dst,     temp[0], temp[1], 1, linesize, step, w, h);
-}
-
-static void filter(OWDenoiseContext *s,
-                   uint8_t       *dst, int dst_linesize,
-                   const uint8_t *src, int src_linesize,
-                   int width, int height, double strength)
-{
-    int x, y, i, j, depth = s->depth;
-
-    while (1<<depth > width || 1<<depth > height)
-        depth--;
-
-    for (y = 0; y < height; y++)
-        for(x = 0; x < width; x++)
-            s->plane[0][0][y*s->linesize + x] = src[y*src_linesize + x];
-
-    for (i = 0; i < depth; i++)
-        decompose2D2(s->plane[i + 1], s->plane[i][0], s->plane[0] + 1, s->linesize, 1<<i, width, height);
-
-    for (i = 0; i < depth; i++) {
-        for (j = 1; j < 4; j++) {
-            for (y = 0; y < height; y++) {
-                for (x = 0; x < width; x++) {
-                    double v = s->plane[i + 1][j][y*s->linesize + x];
-                    if      (v >  strength) v -= strength;
-                    else if (v < -strength) v += strength;
-                    else                    v  = 0;
-                    s->plane[i + 1][j][x + y*s->linesize] = v;
-                }
-            }
-        }
-    }
-    for (i = depth-1; i >= 0; i--)
-        compose2D2(s->plane[i][0], s->plane[i + 1], s->plane[0] + 1, s->linesize, 1<<i, width, height);
-
-    for (y = 0; y < height; y++) {
-        for (x = 0; x < width; x++) {
-            i = s->plane[0][0][y*s->linesize + x] + dither[x&7][y&7]*(1.0/64) + 1.0/128; // yes the rounding is insane but optimal :)
-            if ((unsigned)i > 255U) i = ~(i >> 31);
-            dst[y*dst_linesize + x] = i;
-        }
-    }
-}
-
-static int filter_frame(AVFilterLink *inlink, AVFrame *in)
-{
-    int direct = 0;
-    AVFilterContext *ctx = inlink->dst;
-    OWDenoiseContext *s = ctx->priv;
-    AVFilterLink *outlink = ctx->outputs[0];
-    AVFrame *out;
-    const int cw = FF_CEIL_RSHIFT(inlink->w, s->hsub);
-    const int ch = FF_CEIL_RSHIFT(inlink->h, s->vsub);
-
-    if (av_frame_is_writable(in)) {
-        direct = 1;
-        out = in;
-    } else {
-        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
-        if (!out) {
-            av_frame_free(&in);
-            return AVERROR(ENOMEM);
-        }
-        av_frame_copy_props(out, in);
-    }
-
-    filter(s, out->data[0], out->linesize[0], in->data[0], in->linesize[0], inlink->w, inlink->h, s->luma_strength);
-    filter(s, out->data[1], out->linesize[1], in->data[1], in->linesize[1], cw,        ch,        s->chroma_strength);
-    filter(s, out->data[2], out->linesize[2], in->data[2], in->linesize[2], cw,        ch,        s->chroma_strength);
-
-    if (!direct) {
-        if (in->data[3])
-            av_image_copy_plane(out->data[3], out->linesize[3],
-                                in ->data[3], in ->linesize[3],
-                                inlink->w, inlink->h);
-        av_frame_free(&in);
-    }
-
-    return ff_filter_frame(outlink, out);
-}
-
-static int query_formats(AVFilterContext *ctx)
-{
-    static const enum AVPixelFormat pix_fmts[] = {
-        AV_PIX_FMT_YUV444P,      AV_PIX_FMT_YUV422P,
-        AV_PIX_FMT_YUV420P,      AV_PIX_FMT_YUV411P,
-        AV_PIX_FMT_YUV410P,      AV_PIX_FMT_YUV440P,
-        AV_PIX_FMT_YUVA444P,     AV_PIX_FMT_YUVA422P,
-        AV_PIX_FMT_YUVA420P,
-        AV_PIX_FMT_NONE
-    };
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-    return 0;
-}
-
-static int config_input(AVFilterLink *inlink)
-{
-    int i, j;
-    OWDenoiseContext *s = inlink->dst->priv;
-    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);
-    const int h = FFALIGN(inlink->h, 16);
-
-    s->hsub = desc->log2_chroma_w;
-    s->vsub = desc->log2_chroma_h;
-
-    s->linesize = FFALIGN(inlink->w, 16);
-    for (j = 0; j < 4; j++) {
-        for (i = 0; i <= s->depth; i++) {
-            s->plane[i][j] = av_malloc(s->linesize * h * sizeof(s->plane[0][0][0]));
-            if (!s->plane[i][j])
-                return AVERROR(ENOMEM);
-        }
-    }
-    return 0;
-}
-
-static av_cold void uninit(AVFilterContext *ctx)
-{
-    int i, j;
-    OWDenoiseContext *s = ctx->priv;
-
-    for (j = 0; j < 4; j++)
-        for (i = 0; i <= s->depth; i++)
-            av_freep(&s->plane[i][j]);
-}
-
-static const AVFilterPad owdenoise_inputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .filter_frame = filter_frame,
-        .config_props = config_input,
-    },
-    { NULL }
-};
-
-static const AVFilterPad owdenoise_outputs[] = {
-     {
-         .name = "default",
-         .type = AVMEDIA_TYPE_VIDEO,
-     },
-     { NULL }
-};
-
-AVFilter ff_vf_owdenoise = {
-    .name          = "owdenoise",
-    .description   = NULL_IF_CONFIG_SMALL("Denoise using wavelets."),
-    .priv_size     = sizeof(OWDenoiseContext),
-    .uninit        = uninit,
-    .query_formats = query_formats,
-    .inputs        = owdenoise_inputs,
-    .outputs       = owdenoise_outputs,
-    .priv_class    = &owdenoise_class,
-    .flags         = AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC,
-};
diff --git a/libavfilter/vf_perspective.c b/libavfilter/vf_perspective.c
deleted file mode 100644
index f433226..0000000
--- a/libavfilter/vf_perspective.c
+++ /dev/null
@@ -1,403 +0,0 @@
-/*
- * Copyright (c) 2002 Michael Niedermayer <michaelni@gmx.at>
- * Copyright (c) 2013 Paul B Mahol
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include "libavutil/eval.h"
-#include "libavutil/imgutils.h"
-#include "libavutil/pixdesc.h"
-#include "libavutil/opt.h"
-#include "avfilter.h"
-#include "formats.h"
-#include "internal.h"
-#include "video.h"
-
-#define SUB_PIXEL_BITS  8
-#define SUB_PIXELS      (1 << SUB_PIXEL_BITS)
-#define COEFF_BITS      11
-
-#define LINEAR 0
-#define CUBIC  1
-
-typedef struct PerspectiveContext {
-    const AVClass *class;
-    char *expr_str[4][2];
-    double ref[4][2];
-    int32_t (*pv)[2];
-    int32_t coeff[SUB_PIXELS][4];
-    int interpolation;
-    int linesize[4];
-    int height[4];
-    int hsub, vsub;
-    int nb_planes;
-
-    void (*perspective)(struct PerspectiveContext *s,
-                        uint8_t *dst, int dst_linesize,
-                        uint8_t *src, int src_linesize,
-                        int w, int h, int hsub, int vsub);
-} PerspectiveContext;
-
-#define OFFSET(x) offsetof(PerspectiveContext, x)
-#define FLAGS AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM
-
-static const AVOption perspective_options[] = {
-    { "x0", "set top left x coordinate",     OFFSET(expr_str[0][0]), AV_OPT_TYPE_STRING, {.str="0"}, 0, 0, FLAGS },
-    { "y0", "set top left y coordinate",     OFFSET(expr_str[0][1]), AV_OPT_TYPE_STRING, {.str="0"}, 0, 0, FLAGS },
-    { "x1", "set top right x coordinate",    OFFSET(expr_str[1][0]), AV_OPT_TYPE_STRING, {.str="W"}, 0, 0, FLAGS },
-    { "y1", "set top right y coordinate",    OFFSET(expr_str[1][1]), AV_OPT_TYPE_STRING, {.str="0"}, 0, 0, FLAGS },
-    { "x2", "set bottom left x coordinate",  OFFSET(expr_str[2][0]), AV_OPT_TYPE_STRING, {.str="0"}, 0, 0, FLAGS },
-    { "y2", "set bottom left y coordinate",  OFFSET(expr_str[2][1]), AV_OPT_TYPE_STRING, {.str="H"}, 0, 0, FLAGS },
-    { "x3", "set bottom right x coordinate", OFFSET(expr_str[3][0]), AV_OPT_TYPE_STRING, {.str="W"}, 0, 0, FLAGS },
-    { "y3", "set bottom right y coordinate", OFFSET(expr_str[3][1]), AV_OPT_TYPE_STRING, {.str="H"}, 0, 0, FLAGS },
-    { "interpolation", "set interpolation", OFFSET(interpolation), AV_OPT_TYPE_INT, {.i64=LINEAR}, 0, 1, FLAGS, "interpolation" },
-    {      "linear", "", 0, AV_OPT_TYPE_CONST, {.i64=LINEAR}, 0, 0, FLAGS, "interpolation" },
-    {       "cubic", "", 0, AV_OPT_TYPE_CONST, {.i64=CUBIC},  0, 0, FLAGS, "interpolation" },
-    { NULL }
-};
-
-AVFILTER_DEFINE_CLASS(perspective);
-
-static int query_formats(AVFilterContext *ctx)
-{
-    static const enum AVPixelFormat pix_fmts[] = {
-        AV_PIX_FMT_YUVA444P, AV_PIX_FMT_YUVA422P, AV_PIX_FMT_YUVA420P,
-        AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUVJ440P, AV_PIX_FMT_YUVJ422P,AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ411P,
-        AV_PIX_FMT_YUV444P, AV_PIX_FMT_YUV440P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV411P, AV_PIX_FMT_YUV410P,
-        AV_PIX_FMT_GBRP, AV_PIX_FMT_GBRAP, AV_PIX_FMT_GRAY8, AV_PIX_FMT_NONE
-    };
-
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-    return 0;
-}
-
-static inline double get_coeff(double d)
-{
-    double coeff, A = -0.60;
-
-    d = fabs(d);
-
-    if (d < 1.0)
-        coeff = (1.0 - (A + 3.0) * d * d + (A + 2.0) * d * d * d);
-    else if (d < 2.0)
-        coeff = (-4.0 * A + 8.0 * A * d - 5.0 * A * d * d + A * d * d * d);
-    else
-        coeff = 0.0;
-
-    return coeff;
-}
-
-static const char *const var_names[] = {   "W",   "H",        NULL };
-enum                                   { VAR_W, VAR_H, VAR_VARS_NB };
-
-static int config_input(AVFilterLink *inlink)
-{
-    double x0, x1, x2, x3, x4, x5, x6, x7, q;
-    AVFilterContext *ctx = inlink->dst;
-    PerspectiveContext *s = ctx->priv;
-    double (*ref)[2] = s->ref;
-    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);
-    double values[VAR_VARS_NB] = { [VAR_W] = inlink->w, [VAR_H] = inlink->h };
-    int h = inlink->h;
-    int w = inlink->w;
-    int x, y, i, j, ret;
-
-    for (i = 0; i < 4; i++) {
-        for (j = 0; j < 2; j++) {
-            if (!s->expr_str[i][j])
-                return AVERROR(EINVAL);
-            ret = av_expr_parse_and_eval(&s->ref[i][j], s->expr_str[i][j],
-                                         var_names, &values[0],
-                                         NULL, NULL, NULL, NULL,
-                                         0, 0, ctx);
-            if (ret < 0)
-                return ret;
-        }
-    }
-
-    s->hsub = desc->log2_chroma_w;
-    s->vsub = desc->log2_chroma_h;
-    s->nb_planes = av_pix_fmt_count_planes(inlink->format);
-    if ((ret = av_image_fill_linesizes(s->linesize, inlink->format, inlink->w)) < 0)
-        return ret;
-
-    s->height[1] = s->height[2] = FF_CEIL_RSHIFT(inlink->h, desc->log2_chroma_h);
-    s->height[0] = s->height[3] = inlink->h;
-
-    s->pv = av_realloc_f(s->pv, w * h, 2 * sizeof(*s->pv));
-    if (!s->pv)
-        return AVERROR(ENOMEM);
-
-    x6 = ((ref[0][0] - ref[1][0] - ref[2][0] + ref[3][0]) *
-          (ref[2][1] - ref[3][1]) -
-         ( ref[0][1] - ref[1][1] - ref[2][1] + ref[3][1]) *
-          (ref[2][0] - ref[3][0])) * h;
-    x7 = ((ref[0][1] - ref[1][1] - ref[2][1] + ref[3][1]) *
-          (ref[1][0] - ref[3][0]) -
-         ( ref[0][0] - ref[1][0] - ref[2][0] + ref[3][0]) *
-          (ref[1][1] - ref[3][1])) * w;
-    q =  ( ref[1][0] - ref[3][0]) * (ref[2][1] - ref[3][1]) -
-         ( ref[2][0] - ref[3][0]) * (ref[1][1] - ref[3][1]);
-
-    x0 = q * (ref[1][0] - ref[0][0]) * h + x6 * ref[1][0];
-    x1 = q * (ref[2][0] - ref[0][0]) * w + x7 * ref[2][0];
-    x2 = q *  ref[0][0] * w * h;
-    x3 = q * (ref[1][1] - ref[0][1]) * h + x6 * ref[1][1];
-    x4 = q * (ref[2][1] - ref[0][1]) * w + x7 * ref[2][1];
-    x5 = q *  ref[0][1] * w * h;
-
-    for (y = 0; y < h; y++){
-        for (x = 0; x < w; x++){
-            int u, v;
-
-            u = (int)floor(SUB_PIXELS * (x0 * x + x1 * y + x2) /
-                                        (x6 * x + x7 * y + q * w * h) + 0.5);
-            v = (int)floor(SUB_PIXELS * (x3 * x + x4 * y + x5) /
-                                        (x6 * x + x7 * y + q * w * h) + 0.5);
-
-            s->pv[x + y * w][0] = u;
-            s->pv[x + y * w][1] = v;
-        }
-    }
-
-    for (i = 0; i < SUB_PIXELS; i++){
-        double d = i / (double)SUB_PIXELS;
-        double temp[4];
-        double sum = 0;
-
-        for (j = 0; j < 4; j++)
-            temp[j] = get_coeff(j - d - 1);
-
-        for (j = 0; j < 4; j++)
-            sum += temp[j];
-
-        for (j = 0; j < 4; j++)
-            s->coeff[i][j] = (int)floor((1 << COEFF_BITS) * temp[j] / sum + 0.5);
-    }
-
-    return 0;
-}
-
-static void resample_cubic(PerspectiveContext *s,
-                           uint8_t *dst, int dst_linesize,
-                           uint8_t *src, int src_linesize,
-                           int w, int h, int hsub, int vsub)
-{
-    const int linesize = s->linesize[0];
-    int x, y;
-
-    for (y = 0; y < h; y++) {
-        int sy = y << vsub;
-        for (x = 0; x < w; x++) {
-            int u, v, subU, subV, sum, sx;
-
-            sx   = x << hsub;
-            u    = s->pv[sx + sy * linesize][0] >> hsub;
-            v    = s->pv[sx + sy * linesize][1] >> vsub;
-            subU = u & (SUB_PIXELS - 1);
-            subV = v & (SUB_PIXELS - 1);
-            u  >>= SUB_PIXEL_BITS;
-            v  >>= SUB_PIXEL_BITS;
-
-            if (u > 0 && v > 0 && u < w - 2 && v < h - 2){
-                const int index = u + v*src_linesize;
-                const int a = s->coeff[subU][0];
-                const int b = s->coeff[subU][1];
-                const int c = s->coeff[subU][2];
-                const int d = s->coeff[subU][3];
-
-                sum = s->coeff[subV][0] * (a * src[index - 1 -     src_linesize] + b * src[index - 0 -     src_linesize]  +
-                                      c *      src[index + 1 -     src_linesize] + d * src[index + 2 -     src_linesize]) +
-                      s->coeff[subV][1] * (a * src[index - 1                   ] + b * src[index - 0                   ]  +
-                                      c *      src[index + 1                   ] + d * src[index + 2                   ]) +
-                      s->coeff[subV][2] * (a * src[index - 1 +     src_linesize] + b * src[index - 0 +     src_linesize]  +
-                                      c *      src[index + 1 +     src_linesize] + d * src[index + 2 +     src_linesize]) +
-                      s->coeff[subV][3] * (a * src[index - 1 + 2 * src_linesize] + b * src[index - 0 + 2 * src_linesize]  +
-                                      c *      src[index + 1 + 2 * src_linesize] + d * src[index + 2 + 2 * src_linesize]);
-            } else {
-                int dx, dy;
-
-                sum = 0;
-
-                for (dy = 0; dy < 4; dy++) {
-                    int iy = v + dy - 1;
-
-                    if (iy < 0)
-                        iy = 0;
-                    else if (iy >= h)
-                        iy = h-1;
-                    for (dx = 0; dx < 4; dx++) {
-                        int ix = u + dx - 1;
-
-                        if (ix < 0)
-                            ix = 0;
-                        else if (ix >= w)
-                            ix = w - 1;
-
-                        sum += s->coeff[subU][dx] * s->coeff[subV][dy] * src[ ix + iy * src_linesize];
-                    }
-                }
-            }
-
-            sum = (sum + (1<<(COEFF_BITS * 2 - 1))) >> (COEFF_BITS * 2);
-            sum = av_clip(sum, 0, 255);
-            dst[x + y * dst_linesize] = sum;
-        }
-    }
-}
-
-static void resample_linear(PerspectiveContext *s,
-                            uint8_t *dst, int dst_linesize,
-                            uint8_t *src, int src_linesize,
-                            int w, int h, int hsub, int vsub)
-{
-    const int linesize = s->linesize[0];
-    int x, y;
-
-    for (y = 0; y < h; y++){
-        int sy = y << vsub;
-        for (x = 0; x < w; x++){
-            int u, v, subU, subV, sum, sx, index, subUI, subVI;
-
-            sx   = x << hsub;
-            u    = s->pv[sx + sy * linesize][0] >> hsub;
-            v    = s->pv[sx + sy * linesize][1] >> vsub;
-            subU = u & (SUB_PIXELS - 1);
-            subV = v & (SUB_PIXELS - 1);
-            u  >>= SUB_PIXEL_BITS;
-            v  >>= SUB_PIXEL_BITS;
-
-            index = u + v * src_linesize;
-            subUI = SUB_PIXELS - subU;
-            subVI = SUB_PIXELS - subV;
-
-            if ((unsigned)u < (unsigned)(w - 1)){
-                if((unsigned)v < (unsigned)(h - 1)){
-                    sum = subVI * (subUI * src[index] + subU * src[index + 1]) +
-                          subV  * (subUI * src[index + src_linesize] + subU * src[index + src_linesize + 1]);
-                    sum = (sum + (1 << (SUB_PIXEL_BITS * 2 - 1)))>> (SUB_PIXEL_BITS * 2);
-                } else {
-                    if (v < 0)
-                        v = 0;
-                    else
-                        v = h - 1;
-                    index = u + v * src_linesize;
-                    sum   = subUI * src[index] + subU * src[index + 1];
-                    sum   = (sum + (1 << (SUB_PIXEL_BITS - 1))) >> SUB_PIXEL_BITS;
-                }
-            } else {
-                if (u < 0)
-                    u = 0;
-                else
-                    u = w - 1;
-                if ((unsigned)v < (unsigned)(h - 1)){
-                    index = u + v * src_linesize;
-                    sum   = subVI * src[index] + subV * src[index + src_linesize];
-                    sum   = (sum + (1 << (SUB_PIXEL_BITS - 1))) >> SUB_PIXEL_BITS;
-                } else {
-                    if (v < 0)
-                        v = 0;
-                    else
-                        v = h - 1;
-                    index = u + v * src_linesize;
-                    sum   = src[index];
-                }
-            }
-
-            sum = av_clip(sum, 0, 255);
-            dst[x + y * dst_linesize] = sum;
-        }
-    }
-}
-
-static av_cold int init(AVFilterContext *ctx)
-{
-    PerspectiveContext *s = ctx->priv;
-
-    switch (s->interpolation) {
-    case LINEAR: s->perspective = resample_linear; break;
-    case CUBIC:  s->perspective = resample_cubic;  break;
-    }
-
-    return 0;
-}
-
-static int filter_frame(AVFilterLink *inlink, AVFrame *frame)
-{
-    AVFilterContext *ctx = inlink->dst;
-    AVFilterLink *outlink = ctx->outputs[0];
-    PerspectiveContext *s = ctx->priv;
-    AVFrame *out;
-    int plane;
-
-    out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
-    if (!out) {
-        av_frame_free(&frame);
-        return AVERROR(ENOMEM);
-    }
-    av_frame_copy_props(out, frame);
-
-    for (plane = 0; plane < s->nb_planes; plane++) {
-        int hsub = plane == 1 || plane == 2 ? s->hsub : 0;
-        int vsub = plane == 1 || plane == 2 ? s->vsub : 0;
-        s->perspective(s, out->data[plane], out->linesize[plane],
-                       frame->data[plane], frame->linesize[plane],
-                       s->linesize[plane], s->height[plane], hsub, vsub);
-    }
-
-    av_frame_free(&frame);
-    return ff_filter_frame(outlink, out);
-}
-
-static av_cold void uninit(AVFilterContext *ctx)
-{
-    PerspectiveContext *s = ctx->priv;
-
-    av_freep(&s->pv);
-}
-
-static const AVFilterPad perspective_inputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .filter_frame = filter_frame,
-        .config_props = config_input,
-    },
-    { NULL }
-};
-
-static const AVFilterPad perspective_outputs[] = {
-    {
-        .name = "default",
-        .type = AVMEDIA_TYPE_VIDEO,
-    },
-    { NULL }
-};
-
-AVFilter ff_vf_perspective = {
-    .name          = "perspective",
-    .description   = NULL_IF_CONFIG_SMALL("Correct the perspective of video."),
-    .priv_size     = sizeof(PerspectiveContext),
-    .init          = init,
-    .uninit        = uninit,
-    .query_formats = query_formats,
-    .inputs        = perspective_inputs,
-    .outputs       = perspective_outputs,
-    .priv_class    = &perspective_class,
-    .flags         = AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC,
-};
diff --git a/libavfilter/vf_phase.c b/libavfilter/vf_phase.c
deleted file mode 100644
index 2dcc6fa..0000000
--- a/libavfilter/vf_phase.c
+++ /dev/null
@@ -1,320 +0,0 @@
-/*
- * Copyright (c) 2004 Ville Saari
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include "libavutil/avassert.h"
-#include "libavutil/imgutils.h"
-#include "libavutil/pixdesc.h"
-#include "libavutil/opt.h"
-#include "avfilter.h"
-#include "formats.h"
-#include "internal.h"
-#include "video.h"
-
-enum PhaseMode {
-    PROGRESSIVE,
-    TOP_FIRST,
-    BOTTOM_FIRST,
-    TOP_FIRST_ANALYZE,
-    BOTTOM_FIRST_ANALYZE,
-    ANALYZE,
-    FULL_ANALYZE,
-    AUTO,
-    AUTO_ANALYZE
-};
-
-typedef struct PhaseContext {
-    const AVClass *class;
-    enum PhaseMode mode;
-    AVFrame *frame;
-    int nb_planes;
-    int planeheight[4];
-    int linesize[4];
-} PhaseContext;
-
-#define OFFSET(x) offsetof(PhaseContext, x)
-#define FLAGS AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM
-#define CONST(name, help, val, unit) { name, help, 0, AV_OPT_TYPE_CONST, {.i64=val}, 0, 0, FLAGS, unit }
-
-static const AVOption phase_options[] = {
-    { "mode", "set phase mode", OFFSET(mode), AV_OPT_TYPE_INT, {.i64=AUTO_ANALYZE}, PROGRESSIVE, AUTO_ANALYZE, FLAGS, "mode" },
-    CONST("p", "progressive",          PROGRESSIVE,          "mode"),
-    CONST("t", "top first",            TOP_FIRST,            "mode"),
-    CONST("b", "bottom first",         BOTTOM_FIRST,         "mode"),
-    CONST("T", "top first analyze",    TOP_FIRST_ANALYZE,    "mode"),
-    CONST("B", "bottom first analyze", BOTTOM_FIRST_ANALYZE, "mode"),
-    CONST("u", "analyze",              ANALYZE,              "mode"),
-    CONST("U", "full analyze",         FULL_ANALYZE,         "mode"),
-    CONST("a", "auto",                 AUTO,                 "mode"),
-    CONST("A", "auto analyze",         AUTO_ANALYZE,         "mode"),
-    { NULL }
-};
-
-AVFILTER_DEFINE_CLASS(phase);
-
-static int query_formats(AVFilterContext *ctx)
-{
-    static const enum AVPixelFormat pix_fmts[] = {
-        AV_PIX_FMT_YUVA444P, AV_PIX_FMT_YUVA422P, AV_PIX_FMT_YUVA420P,
-        AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUVJ440P, AV_PIX_FMT_YUVJ422P,AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ411P,
-        AV_PIX_FMT_YUV444P, AV_PIX_FMT_YUV440P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV411P, AV_PIX_FMT_YUV410P,
-        AV_PIX_FMT_GBRP, AV_PIX_FMT_GBRAP, AV_PIX_FMT_GRAY8, AV_PIX_FMT_NONE
-    };
-
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-    return 0;
-}
-
-static int config_input(AVFilterLink *inlink)
-{
-    PhaseContext *s = inlink->dst->priv;
-    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);
-    int ret;
-
-    if ((ret = av_image_fill_linesizes(s->linesize, inlink->format, inlink->w)) < 0)
-        return ret;
-
-    s->planeheight[1] = s->planeheight[2] = FF_CEIL_RSHIFT(inlink->h, desc->log2_chroma_h);
-    s->planeheight[0] = s->planeheight[3] = inlink->h;
-
-    s->nb_planes = av_pix_fmt_count_planes(inlink->format);
-
-    return 0;
-}
-
-/*
- * This macro interpolates the value of both fields at a point halfway
- * between lines and takes the squared difference. In field resolution
- * the point is a quarter pixel below a line in one field and a quarter
- * pixel above a line in other.
- *
- * (The result is actually multiplied by 25)
- */
-#define DIFF(a, as, b, bs) (t = ((*a - b[bs]) << 2) + a[as << 1] - b[-bs], t * t)
-
-/*
- * Find which field combination has the smallest average squared difference
- * between the fields.
- */
-static enum PhaseMode analyze_plane(AVFilterContext *ctx, PhaseContext *s,
-                                    AVFrame *old, AVFrame *new)
-{
-    double bdiff, tdiff, pdiff, scale;
-    const int ns = new->linesize[0];
-    const int os = old->linesize[0];
-    uint8_t *nptr = new->data[0];
-    uint8_t *optr = old->data[0];
-    const int h = new->height;
-    const int w = new->width;
-    int bdif, tdif, pdif;
-    enum PhaseMode mode = s->mode;
-    uint8_t *end, *rend;
-    int top, t;
-
-    if (mode == AUTO) {
-        mode = new->interlaced_frame ? new->top_field_first ?
-               TOP_FIRST : BOTTOM_FIRST : PROGRESSIVE;
-    } else if (mode == AUTO_ANALYZE) {
-        mode = new->interlaced_frame ? new->top_field_first ?
-               TOP_FIRST_ANALYZE : BOTTOM_FIRST_ANALYZE : FULL_ANALYZE;
-    }
-
-    if (mode <= BOTTOM_FIRST) {
-        bdiff = pdiff = tdiff = 65536.0;
-    } else {
-        bdiff = pdiff = tdiff = 0.0;
-
-        for (end = nptr + (h - 2) * ns, nptr += ns, optr += os, top = 0;
-             nptr < end; nptr += ns - w, optr += os - w, top ^= 1) {
-            pdif = tdif = bdif = 0;
-
-            switch (mode) {
-            case TOP_FIRST_ANALYZE:
-                if (top) {
-                    for (rend = nptr + w; nptr < rend; nptr++, optr++) {
-                        pdif += DIFF(nptr, ns, nptr, ns);
-                        tdif += DIFF(nptr, ns, optr, os);
-                    }
-                } else {
-                    for (rend = nptr + w; nptr < rend; nptr++, optr++) {
-                        pdif += DIFF(nptr, ns, nptr, ns);
-                        tdif += DIFF(optr, os, nptr, ns);
-                    }
-                }
-                break;
-            case BOTTOM_FIRST_ANALYZE:
-                if (top) {
-                    for (rend = nptr + w; nptr < rend; nptr++, optr++) {
-                        pdif += DIFF(nptr, ns, nptr, ns);
-                        bdif += DIFF(optr, os, nptr, ns);
-                    }
-                } else {
-                    for (rend = nptr + w; nptr < rend; nptr++, optr++) {
-                        pdif += DIFF(nptr, ns, nptr, ns);
-                        bdif += DIFF(nptr, ns, optr, os);
-                    }
-                }
-                break;
-            case ANALYZE:
-                if (top) {
-                    for (rend = nptr + w; nptr < rend; nptr++, optr++) {
-                        tdif += DIFF(nptr, ns, optr, os);
-                        bdif += DIFF(optr, os, nptr, ns);
-                    }
-                } else {
-                    for (rend = nptr + w; nptr < rend; nptr++, optr++) {
-                        bdif += DIFF(nptr, ns, optr, os);
-                        tdif += DIFF(optr, os, nptr, ns);
-                    }
-                }
-                break;
-            case FULL_ANALYZE:
-                if (top) {
-                    for (rend = nptr + w; nptr < rend; nptr++, optr++) {
-                        pdif += DIFF(nptr, ns, nptr, ns);
-                        tdif += DIFF(nptr, ns, optr, os);
-                        bdif += DIFF(optr, os, nptr, ns);
-                    }
-                } else {
-                    for (rend = nptr + w; nptr < rend; nptr++, optr++) {
-                        pdif += DIFF(nptr, ns, nptr, ns);
-                        bdif += DIFF(nptr, ns, optr, os);
-                        tdif += DIFF(optr, os, nptr, ns);
-                    }
-                }
-                break;
-            default:
-                av_assert0(0);
-            }
-
-            pdiff += (double)pdif;
-            tdiff += (double)tdif;
-            bdiff += (double)bdif;
-        }
-
-        scale = 1.0 / (w * (h - 3)) / 25.0;
-        pdiff *= scale;
-        tdiff *= scale;
-        bdiff *= scale;
-
-        if (mode == TOP_FIRST_ANALYZE) {
-            bdiff = 65536.0;
-        } else if (mode == BOTTOM_FIRST_ANALYZE) {
-            tdiff = 65536.0;
-        } else if (mode == ANALYZE) {
-            pdiff = 65536.0;
-        }
-
-        if (bdiff < pdiff && bdiff < tdiff) {
-            mode = BOTTOM_FIRST;
-        } else if (tdiff < pdiff && tdiff < bdiff) {
-            mode = TOP_FIRST;
-        } else {
-            mode = PROGRESSIVE;
-        }
-    }
-
-    av_log(ctx, AV_LOG_DEBUG, "mode=%c tdiff=%f bdiff=%f pdiff=%f\n",
-           mode == BOTTOM_FIRST ? 'b' : mode == TOP_FIRST ? 't' : 'p',
-           tdiff, bdiff, pdiff);
-    return mode;
-}
-
-static int filter_frame(AVFilterLink *inlink, AVFrame *in)
-{
-    AVFilterContext *ctx = inlink->dst;
-    AVFilterLink *outlink = ctx->outputs[0];
-    PhaseContext *s = ctx->priv;
-    enum PhaseMode mode;
-    int plane, top, y;
-    AVFrame *out;
-
-    out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
-    if (!out) {
-        av_frame_free(&in);
-        return AVERROR(ENOMEM);
-    }
-    av_frame_copy_props(out, in);
-
-    if (!s->frame) {
-        mode = PROGRESSIVE;
-        s->frame = ff_get_video_buffer(outlink, outlink->w, outlink->h);
-        if (!s->frame) {
-            av_frame_free(&in);
-            av_frame_free(&out);
-            return AVERROR(ENOMEM);
-        }
-    } else {
-        mode = analyze_plane(ctx, s, s->frame, in);
-    }
-
-    for (plane = 0; plane < s->nb_planes; plane++) {
-        uint8_t *buf = s->frame->data[plane];
-        uint8_t *from = in->data[plane];
-        uint8_t *to = out->data[plane];
-
-        for (y = 0, top = 1; y < s->planeheight[plane]; y++, top ^= 1) {
-            memcpy(to, mode == (top ? BOTTOM_FIRST : TOP_FIRST) ? buf : from, s->linesize[plane]);
-            memcpy(buf, from, s->linesize[plane]);
-
-            buf += s->frame->linesize[plane];
-            from += in->linesize[plane];
-            to += out->linesize[plane];
-        }
-    }
-
-    av_frame_free(&in);
-    return ff_filter_frame(outlink, out);
-}
-
-static av_cold void uninit(AVFilterContext *ctx)
-{
-    PhaseContext *s = ctx->priv;
-
-    av_frame_free(&s->frame);
-}
-
-static const AVFilterPad phase_inputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .filter_frame = filter_frame,
-        .config_props = config_input,
-    },
-    { NULL }
-};
-
-static const AVFilterPad phase_outputs[] = {
-    {
-        .name = "default",
-        .type = AVMEDIA_TYPE_VIDEO,
-    },
-    { NULL }
-};
-
-AVFilter ff_vf_phase = {
-    .name          = "phase",
-    .description   = NULL_IF_CONFIG_SMALL("Phase shift fields."),
-    .priv_size     = sizeof(PhaseContext),
-    .priv_class    = &phase_class,
-    .uninit        = uninit,
-    .query_formats = query_formats,
-    .inputs        = phase_inputs,
-    .outputs       = phase_outputs,
-};
diff --git a/libavfilter/vf_pp.c b/libavfilter/vf_pp.c
deleted file mode 100644
index c72fdc6..0000000
--- a/libavfilter/vf_pp.c
+++ /dev/null
@@ -1,186 +0,0 @@
-/*
- * Copyright (c) 2002 A'rpi
- * Copyright (C) 2012 Clment Bsch
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with FFmpeg; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-/**
- * @file
- * libpostproc filter, ported from MPlayer.
- */
-
-#include "libavutil/avassert.h"
-#include "libavutil/opt.h"
-#include "internal.h"
-
-#include "libpostproc/postprocess.h"
-
-typedef struct {
-    const AVClass *class;
-    char *subfilters;
-    int mode_id;
-    pp_mode *modes[PP_QUALITY_MAX + 1];
-    void *pp_ctx;
-} PPFilterContext;
-
-#define OFFSET(x) offsetof(PPFilterContext, x)
-#define FLAGS AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM
-static const AVOption pp_options[] = {
-    { "subfilters", "set postprocess subfilters", OFFSET(subfilters), AV_OPT_TYPE_STRING, {.str="de"}, .flags = FLAGS },
-    { NULL }
-};
-
-AVFILTER_DEFINE_CLASS(pp);
-
-static av_cold int pp_init(AVFilterContext *ctx)
-{
-    int i;
-    PPFilterContext *pp = ctx->priv;
-
-    for (i = 0; i <= PP_QUALITY_MAX; i++) {
-        pp->modes[i] = pp_get_mode_by_name_and_quality(pp->subfilters, i);
-        if (!pp->modes[i])
-            return AVERROR_EXTERNAL;
-    }
-    pp->mode_id = PP_QUALITY_MAX;
-    return 0;
-}
-
-static int pp_process_command(AVFilterContext *ctx, const char *cmd, const char *args,
-                              char *res, int res_len, int flags)
-{
-    PPFilterContext *pp = ctx->priv;
-
-    if (!strcmp(cmd, "quality")) {
-        pp->mode_id = av_clip(strtol(args, NULL, 10), 0, PP_QUALITY_MAX);
-        return 0;
-    }
-    return AVERROR(ENOSYS);
-}
-
-static int pp_query_formats(AVFilterContext *ctx)
-{
-    static const enum PixelFormat pix_fmts[] = {
-        AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUVJ420P,
-        AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUVJ422P,
-        AV_PIX_FMT_YUV411P,
-        AV_PIX_FMT_YUV444P, AV_PIX_FMT_YUVJ444P,
-        AV_PIX_FMT_NONE
-    };
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-    return 0;
-}
-
-static int pp_config_props(AVFilterLink *inlink)
-{
-    int flags = PP_CPU_CAPS_AUTO;
-    PPFilterContext *pp = inlink->dst->priv;
-
-    switch (inlink->format) {
-    case AV_PIX_FMT_YUVJ420P:
-    case AV_PIX_FMT_YUV420P: flags |= PP_FORMAT_420; break;
-    case AV_PIX_FMT_YUVJ422P:
-    case AV_PIX_FMT_YUV422P: flags |= PP_FORMAT_422; break;
-    case AV_PIX_FMT_YUV411P: flags |= PP_FORMAT_411; break;
-    case AV_PIX_FMT_YUVJ444P:
-    case AV_PIX_FMT_YUV444P: flags |= PP_FORMAT_444; break;
-    default: av_assert0(0);
-    }
-
-    pp->pp_ctx = pp_get_context(inlink->w, inlink->h, flags);
-    if (!pp->pp_ctx)
-        return AVERROR(ENOMEM);
-    return 0;
-}
-
-static int pp_filter_frame(AVFilterLink *inlink, AVFrame *inbuf)
-{
-    AVFilterContext *ctx = inlink->dst;
-    PPFilterContext *pp = ctx->priv;
-    AVFilterLink *outlink = ctx->outputs[0];
-    const int aligned_w = FFALIGN(outlink->w, 8);
-    const int aligned_h = FFALIGN(outlink->h, 8);
-    AVFrame *outbuf;
-    int qstride, qp_type;
-    int8_t *qp_table ;
-
-    outbuf = ff_get_video_buffer(outlink, aligned_w, aligned_h);
-    if (!outbuf) {
-        av_frame_free(&inbuf);
-        return AVERROR(ENOMEM);
-    }
-    av_frame_copy_props(outbuf, inbuf);
-    outbuf->width  = inbuf->width;
-    outbuf->height = inbuf->height;
-    qp_table = av_frame_get_qp_table(inbuf, &qstride, &qp_type);
-
-    pp_postprocess((const uint8_t **)inbuf->data, inbuf->linesize,
-                   outbuf->data,                 outbuf->linesize,
-                   aligned_w, outlink->h,
-                   qp_table,
-                   qstride,
-                   pp->modes[pp->mode_id],
-                   pp->pp_ctx,
-                   outbuf->pict_type | (qp_type ? PP_PICT_TYPE_QP2 : 0));
-
-    av_frame_free(&inbuf);
-    return ff_filter_frame(outlink, outbuf);
-}
-
-static av_cold void pp_uninit(AVFilterContext *ctx)
-{
-    int i;
-    PPFilterContext *pp = ctx->priv;
-
-    for (i = 0; i <= PP_QUALITY_MAX; i++)
-        pp_free_mode(pp->modes[i]);
-    if (pp->pp_ctx)
-        pp_free_context(pp->pp_ctx);
-}
-
-static const AVFilterPad pp_inputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .config_props = pp_config_props,
-        .filter_frame = pp_filter_frame,
-    },
-    { NULL }
-};
-
-static const AVFilterPad pp_outputs[] = {
-    {
-        .name = "default",
-        .type = AVMEDIA_TYPE_VIDEO,
-    },
-    { NULL }
-};
-
-AVFilter ff_vf_pp = {
-    .name            = "pp",
-    .description     = NULL_IF_CONFIG_SMALL("Filter video using libpostproc."),
-    .priv_size       = sizeof(PPFilterContext),
-    .init            = pp_init,
-    .uninit          = pp_uninit,
-    .query_formats   = pp_query_formats,
-    .inputs          = pp_inputs,
-    .outputs         = pp_outputs,
-    .process_command = pp_process_command,
-    .priv_class      = &pp_class,
-    .flags           = AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC,
-};
diff --git a/libavfilter/vf_pullup.c b/libavfilter/vf_pullup.c
deleted file mode 100644
index 58d4d7a..0000000
--- a/libavfilter/vf_pullup.c
+++ /dev/null
@@ -1,776 +0,0 @@
-/*
- * Copyright (c) 2003 Rich Felker
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include "libavutil/avassert.h"
-#include "libavutil/imgutils.h"
-#include "libavutil/opt.h"
-#include "libavutil/pixdesc.h"
-#include "avfilter.h"
-#include "formats.h"
-#include "internal.h"
-#include "video.h"
-#include "vf_pullup.h"
-
-#define F_HAVE_BREAKS   1
-#define F_HAVE_AFFINITY 2
-
-#define BREAK_LEFT  1
-#define BREAK_RIGHT 2
-
-#define OFFSET(x) offsetof(PullupContext, x)
-#define FLAGS AV_OPT_FLAG_VIDEO_PARAM|AV_OPT_FLAG_FILTERING_PARAM
-
-static const AVOption pullup_options[] = {
-    { "jl", "set left junk size",  OFFSET(junk_left),  AV_OPT_TYPE_INT, {.i64=1}, 0, INT_MAX, FLAGS },
-    { "jr", "set right junk size", OFFSET(junk_right), AV_OPT_TYPE_INT, {.i64=1}, 0, INT_MAX, FLAGS },
-    { "jt", "set top junk size",   OFFSET(junk_top),   AV_OPT_TYPE_INT, {.i64=4}, 1, INT_MAX, FLAGS },
-    { "jb", "set bottom junk size", OFFSET(junk_bottom), AV_OPT_TYPE_INT, {.i64=4}, 1, INT_MAX, FLAGS },
-    { "sb", "set strict breaks", OFFSET(strict_breaks), AV_OPT_TYPE_INT, {.i64=0},-1, 1, FLAGS },
-    { "mp", "set metric plane",  OFFSET(metric_plane),  AV_OPT_TYPE_INT, {.i64=0}, 0, 2, FLAGS, "mp" },
-    { "y", "luma",        0, AV_OPT_TYPE_CONST, {.i64=0}, 0, 0, FLAGS, "mp" },
-    { "u", "chroma blue", 0, AV_OPT_TYPE_CONST, {.i64=1}, 0, 0, FLAGS, "mp" },
-    { "v", "chroma red",  0, AV_OPT_TYPE_CONST, {.i64=2}, 0, 0, FLAGS, "mp" },
-    { NULL }
-};
-
-AVFILTER_DEFINE_CLASS(pullup);
-
-static int query_formats(AVFilterContext *ctx)
-{
-    static const enum AVPixelFormat pix_fmts[] = {
-        AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUVJ440P,
-        AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ420P,
-        AV_PIX_FMT_YUV444P,  AV_PIX_FMT_YUV440P,
-        AV_PIX_FMT_YUV422P,  AV_PIX_FMT_YUV420P,
-        AV_PIX_FMT_YUV411P,  AV_PIX_FMT_YUV410P,
-        AV_PIX_FMT_YUVJ411P, AV_PIX_FMT_GRAY8,
-        AV_PIX_FMT_NONE
-    };
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-    return 0;
-}
-
-#define ABS(a) (((a) ^ ((a) >> 31)) - ((a) >> 31))
-
-static int diff_c(const uint8_t *a, const uint8_t *b, int s)
-{
-    int i, j, diff = 0;
-
-    for (i = 0; i < 4; i++) {
-        for (j = 0; j < 8; j++)
-            diff += ABS(a[j] - b[j]);
-        a += s;
-        b += s;
-    }
-
-    return diff;
-}
-
-static int comb_c(const uint8_t *a, const uint8_t *b, int s)
-{
-    int i, j, comb = 0;
-
-    for (i = 0; i < 4; i++) {
-        for (j = 0; j < 8; j++)
-            comb += ABS((a[j] << 1) - b[j - s] - b[j    ]) +
-                    ABS((b[j] << 1) - a[j    ] - a[j + s]);
-        a += s;
-        b += s;
-    }
-
-    return comb;
-}
-
-static int var_c(const uint8_t *a, const uint8_t *b, int s)
-{
-    int i, j, var = 0;
-
-    for (i = 0; i < 3; i++) {
-        for (j = 0; j < 8; j++)
-            var += ABS(a[j] - a[j + s]);
-        a += s;
-    }
-
-    return 4 * var; /* match comb scaling */
-}
-
-static int alloc_metrics(PullupContext *s, PullupField *f)
-{
-    f->diffs = av_calloc(FFALIGN(s->metric_length, 16), sizeof(*f->diffs));
-    f->combs = av_calloc(FFALIGN(s->metric_length, 16), sizeof(*f->combs));
-    f->vars  = av_calloc(FFALIGN(s->metric_length, 16), sizeof(*f->vars));
-
-    if (!f->diffs || !f->combs || !f->vars) {
-        av_freep(&f->diffs);
-        av_freep(&f->combs);
-        av_freep(&f->vars);
-        return AVERROR(ENOMEM);
-    }
-    return 0;
-}
-
-static void free_field_queue(PullupField *head, PullupField **last)
-{
-    PullupField *f = head;
-    while (f) {
-        av_free(f->diffs);
-        av_free(f->combs);
-        av_free(f->vars);
-        if (f == *last) {
-            av_freep(last);
-            break;
-        }
-        f = f->next;
-        av_freep(&f->prev);
-    };
-}
-
-static PullupField *make_field_queue(PullupContext *s, int len)
-{
-    PullupField *head, *f;
-
-    f = head = av_mallocz(sizeof(*head));
-    if (!f)
-        return NULL;
-
-    if (alloc_metrics(s, f) < 0) {
-        av_free(f);
-        return NULL;
-    }
-
-    for (; len > 0; len--) {
-        f->next = av_mallocz(sizeof(*f->next));
-        if (!f->next) {
-            free_field_queue(head, &f);
-            return NULL;
-        }
-
-        f->next->prev = f;
-        f = f->next;
-        if (alloc_metrics(s, f) < 0) {
-            free_field_queue(head, &f);
-            return NULL;
-        }
-    }
-
-    f->next = head;
-    head->prev = f;
-
-    return head;
-}
-
-static int config_input(AVFilterLink *inlink)
-{
-    AVFilterContext *ctx = inlink->dst;
-    PullupContext *s = ctx->priv;
-    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);
-    int mp = s->metric_plane;
-
-    s->nb_planes = av_pix_fmt_count_planes(inlink->format);
-
-    if (mp + 1 > s->nb_planes) {
-        av_log(ctx, AV_LOG_ERROR, "input format does not have such plane\n");
-        return AVERROR(EINVAL);
-    }
-
-    s->planeheight[1] = s->planeheight[2] = FF_CEIL_RSHIFT(inlink->h, desc->log2_chroma_h);
-    s->planeheight[0] = s->planeheight[3] = inlink->h;
-    s->planewidth[1]  = s->planewidth[2]  = FF_CEIL_RSHIFT(inlink->w, desc->log2_chroma_w);
-    s->planewidth[0]  = s->planewidth[3]  = inlink->w;
-
-    s->metric_w      = (s->planewidth[mp]  - ((s->junk_left + s->junk_right)  << 3)) >> 3;
-    s->metric_h      = (s->planeheight[mp] - ((s->junk_top  + s->junk_bottom) << 1)) >> 3;
-    s->metric_offset = (s->junk_left << 3) + (s->junk_top << 1) * s->planewidth[mp];
-    s->metric_length = s->metric_w * s->metric_h;
-
-    av_log(ctx, AV_LOG_DEBUG, "w: %d h: %d\n", s->metric_w, s->metric_h);
-    av_log(ctx, AV_LOG_DEBUG, "offset: %d length: %d\n", s->metric_offset, s->metric_length);
-
-    s->head = make_field_queue(s, 8);
-    if (!s->head)
-        return AVERROR(ENOMEM);
-
-    s->diff = diff_c;
-    s->comb = comb_c;
-    s->var  = var_c;
-
-    if (ARCH_X86)
-        ff_pullup_init_x86(s);
-    return 0;
-}
-
-static int config_output(AVFilterLink *outlink)
-{
-    outlink->flags |= FF_LINK_FLAG_REQUEST_LOOP;
-    return 0;
-}
-
-static PullupBuffer *pullup_lock_buffer(PullupBuffer *b, int parity)
-{
-    if (!b)
-        return NULL;
-
-    if ((parity + 1) & 1)
-        b->lock[0]++;
-    if ((parity + 1) & 2)
-        b->lock[1]++;
-
-    return b;
-}
-
-static void pullup_release_buffer(PullupBuffer *b, int parity)
-{
-    if (!b)
-        return;
-
-    if ((parity + 1) & 1)
-        b->lock[0]--;
-    if ((parity + 1) & 2)
-        b->lock[1]--;
-}
-
-static int alloc_buffer(PullupContext *s, PullupBuffer *b)
-{
-    int i;
-
-    if (b->planes[0])
-        return 0;
-    for (i = 0; i < s->nb_planes; i++) {
-        b->planes[i] = av_malloc(s->planeheight[i] * s->planewidth[i]);
-    }
-
-    return 0;
-}
-
-static PullupBuffer *pullup_get_buffer(PullupContext *s, int parity)
-{
-    int i;
-
-    /* Try first to get the sister buffer for the previous field */
-    if (parity < 2 && s->last && parity != s->last->parity
-        && !s->last->buffer->lock[parity]) {
-        alloc_buffer(s, s->last->buffer);
-        return pullup_lock_buffer(s->last->buffer, parity);
-    }
-
-    /* Prefer a buffer with both fields open */
-    for (i = 0; i < FF_ARRAY_ELEMS(s->buffers); i++) {
-        if (s->buffers[i].lock[0])
-            continue;
-        if (s->buffers[i].lock[1])
-            continue;
-        alloc_buffer(s, &s->buffers[i]);
-        return pullup_lock_buffer(&s->buffers[i], parity);
-    }
-
-    if (parity == 2)
-        return 0;
-
-    /* Search for any half-free buffer */
-    for (i = 0; i < FF_ARRAY_ELEMS(s->buffers); i++) {
-        if (((parity + 1) & 1) && s->buffers[i].lock[0])
-            continue;
-        if (((parity + 1) & 2) && s->buffers[i].lock[1])
-            continue;
-        alloc_buffer(s, &s->buffers[i]);
-        return pullup_lock_buffer(&s->buffers[i], parity);
-    }
-
-    return NULL;
-}
-
-static int queue_length(PullupField *begin, PullupField *end)
-{
-    PullupField *f;
-    int count = 1;
-
-    if (!begin || !end)
-        return 0;
-
-    for (f = begin; f != end; f = f->next)
-        count++;
-
-    return count;
-}
-
-static int find_first_break(PullupField *f, int max)
-{
-    int i;
-
-    for (i = 0; i < max; i++) {
-        if (f->breaks & BREAK_RIGHT || f->next->breaks & BREAK_LEFT)
-            return i + 1;
-        f = f->next;
-    }
-
-    return 0;
-}
-
-static void compute_breaks(PullupContext *s, PullupField *f0)
-{
-    PullupField *f1 = f0->next;
-    PullupField *f2 = f1->next;
-    PullupField *f3 = f2->next;
-    int i, l, max_l = 0, max_r = 0;
-
-    if (f0->flags & F_HAVE_BREAKS)
-        return;
-
-    f0->flags |= F_HAVE_BREAKS;
-
-    /* Special case when fields are 100% identical */
-    if (f0->buffer == f2->buffer && f1->buffer != f3->buffer) {
-        f2->breaks |= BREAK_RIGHT;
-        return;
-    }
-
-    if (f0->buffer != f2->buffer && f1->buffer == f3->buffer) {
-        f1->breaks |= BREAK_LEFT;
-        return;
-    }
-
-    for (i = 0; i < s->metric_length; i++) {
-        l = f2->diffs[i] - f3->diffs[i];
-
-        if ( l > max_l)
-            max_l =  l;
-        if (-l > max_r)
-            max_r = -l;
-    }
-
-    /* Don't get tripped up when differences are mostly quant error */
-    if (max_l + max_r < 128)
-        return;
-    if (max_l > 4 * max_r)
-        f1->breaks |= BREAK_LEFT;
-    if (max_r > 4 * max_l)
-        f2->breaks |= BREAK_RIGHT;
-}
-
-static void compute_affinity(PullupContext *s, PullupField *f)
-{
-    int i, max_l = 0, max_r = 0, l;
-
-    if (f->flags & F_HAVE_AFFINITY)
-        return;
-
-    f->flags |= F_HAVE_AFFINITY;
-
-    if (f->buffer == f->next->next->buffer) {
-        f->affinity             =  1;
-        f->next->affinity       =  0;
-        f->next->next->affinity = -1;
-        f->next->flags         |= F_HAVE_AFFINITY;
-        f->next->next->flags   |= F_HAVE_AFFINITY;
-        return;
-    }
-
-    for (i = 0; i < s->metric_length; i++) {
-        int v  = f->vars[i];
-        int lv = f->prev->vars[i];
-        int rv = f->next->vars[i];
-        int lc = f->combs[i] - (v + lv) + ABS(v - lv);
-        int rc = f->next->combs[i] - (v + rv) + ABS(v - rv);
-
-        lc = FFMAX(lc, 0);
-        rc = FFMAX(rc, 0);
-        l  = lc - rc;
-
-        if ( l > max_l)
-            max_l =  l;
-        if (-l > max_r)
-            max_r = -l;
-    }
-
-    if (max_l + max_r < 64)
-        return;
-
-    if (max_r > 6 * max_l)
-        f->affinity = -1;
-    else if (max_l > 6 * max_r)
-        f->affinity =  1;
-}
-
-static int decide_frame_length(PullupContext *s)
-{
-    PullupField *f0 = s->first;
-    PullupField *f1 = f0->next;
-    PullupField *f2 = f1->next;
-    PullupField *f;
-    int i, l, n;
-
-    if (queue_length(s->first, s->last) < 4)
-        return 0;
-
-    f = s->first;
-    n = queue_length(f, s->last);
-    for (i = 0; i < n - 1; i++) {
-        if (i < n - 3)
-            compute_breaks(s, f);
-
-        compute_affinity(s, f);
-
-        f = f->next;
-    }
-
-    if (f0->affinity == -1)
-        return 1;
-
-    l = find_first_break(f0, 3);
-
-    if (l == 1 && s->strict_breaks < 0)
-        l = 0;
-
-    switch (l) {
-    case 1:
-        return 1 + (s->strict_breaks < 1 && f0->affinity == 1 && f1->affinity == -1);
-    case 2:
-        /* FIXME: strictly speaking, f0->prev is no longer valid... :) */
-        if (s->strict_pairs
-            && (f0->prev->breaks & BREAK_RIGHT) && (f2->breaks & BREAK_LEFT)
-            && (f0->affinity != 1 || f1->affinity != -1) )
-            return 1;
-        return 1 + (f1->affinity != 1);
-    case 3:
-        return 2 + (f2->affinity != 1);
-    default:
-        /* 9 possibilities covered before switch */
-        if (f1->affinity == 1)
-            return 1; /* covers 6 */
-        else if (f1->affinity == -1)
-            return 2; /* covers 6 */
-        else if (f2->affinity == -1) { /* covers 2 */
-            return (f0->affinity == 1) ? 3 : 1;
-        } else {
-            return 2; /* the remaining 6 */
-        }
-    }
-}
-
-static PullupFrame *pullup_get_frame(PullupContext *s)
-{
-    PullupFrame *fr = &s->frame;
-    int i, n = decide_frame_length(s);
-    int aff = s->first->next->affinity;
-
-    av_assert1(n < FF_ARRAY_ELEMS(fr->ifields));
-    if (!n || fr->lock)
-        return NULL;
-
-    fr->lock++;
-    fr->length = n;
-    fr->parity = s->first->parity;
-    fr->buffer = 0;
-
-    for (i = 0; i < n; i++) {
-        /* We cheat and steal the buffer without release+relock */
-        fr->ifields[i]   = s->first->buffer;
-        s->first->buffer = 0;
-        s->first         = s->first->next;
-    }
-
-    if (n == 1) {
-        fr->ofields[fr->parity    ] = fr->ifields[0];
-        fr->ofields[fr->parity ^ 1] = 0;
-    } else if (n == 2) {
-        fr->ofields[fr->parity    ] = fr->ifields[0];
-        fr->ofields[fr->parity ^ 1] = fr->ifields[1];
-    } else if (n == 3) {
-        if (!aff)
-            aff = (fr->ifields[0] == fr->ifields[1]) ? -1 : 1;
-        fr->ofields[fr->parity    ] = fr->ifields[1 + aff];
-        fr->ofields[fr->parity ^ 1] = fr->ifields[1      ];
-    }
-
-    pullup_lock_buffer(fr->ofields[0], 0);
-    pullup_lock_buffer(fr->ofields[1], 1);
-
-    if (fr->ofields[0] == fr->ofields[1]) {
-        fr->buffer = fr->ofields[0];
-        pullup_lock_buffer(fr->buffer, 2);
-        return fr;
-    }
-
-    return fr;
-}
-
-static void pullup_release_frame(PullupFrame *f)
-{
-    int i;
-
-    for (i = 0; i < f->length; i++)
-        pullup_release_buffer(f->ifields[i], f->parity ^ (i & 1));
-
-    pullup_release_buffer(f->ofields[0], 0);
-    pullup_release_buffer(f->ofields[1], 1);
-
-    if (f->buffer)
-        pullup_release_buffer(f->buffer, 2);
-    f->lock--;
-}
-
-static void compute_metric(PullupContext *s, int *dest,
-                           PullupField *fa, int pa, PullupField *fb, int pb,
-                           int (*func)(const uint8_t *, const uint8_t *, int))
-{
-    int mp = s->metric_plane;
-    int xstep = 8;
-    int ystep = s->planewidth[mp] << 3;
-    int stride = s->planewidth[mp] << 1; /* field stride */
-    int w = s->metric_w * xstep;
-    uint8_t *a, *b;
-    int x, y;
-
-    if (!fa->buffer || !fb->buffer)
-        return;
-
-    /* Shortcut for duplicate fields (e.g. from RFF flag) */
-    if (fa->buffer == fb->buffer && pa == pb) {
-        memset(dest, 0, s->metric_length * sizeof(*dest));
-        return;
-    }
-
-    a = fa->buffer->planes[mp] + pa * s->planewidth[mp] + s->metric_offset;
-    b = fb->buffer->planes[mp] + pb * s->planewidth[mp] + s->metric_offset;
-
-    for (y = 0; y < s->metric_h; y++) {
-        for (x = 0; x < w; x += xstep)
-            *dest++ = func(a + x, b + x, stride);
-        a += ystep; b += ystep;
-    }
-}
-
-static int check_field_queue(PullupContext *s)
-{
-    int ret;
-
-    if (s->head->next == s->first) {
-        PullupField *f = av_mallocz(sizeof(*f));
-
-        if (!f)
-            return AVERROR(ENOMEM);
-
-        if ((ret = alloc_metrics(s, f)) < 0) {
-            av_free(f);
-            return ret;
-        }
-
-        f->prev        = s->head;
-        f->next        = s->first;
-        s->head->next  = f;
-        s->first->prev = f;
-    }
-
-    return 0;
-}
-
-static void pullup_submit_field(PullupContext *s, PullupBuffer *b, int parity)
-{
-    PullupField *f;
-
-    /* Grow the circular list if needed */
-    if (check_field_queue(s) < 0)
-        return;
-
-    /* Cannot have two fields of same parity in a row; drop the new one */
-    if (s->last && s->last->parity == parity)
-        return;
-
-    f = s->head;
-    f->parity   = parity;
-    f->buffer   = pullup_lock_buffer(b, parity);
-    f->flags    = 0;
-    f->breaks   = 0;
-    f->affinity = 0;
-
-    compute_metric(s, f->diffs, f, parity, f->prev->prev, parity, s->diff);
-    compute_metric(s, f->combs, parity ? f->prev : f, 0, parity ? f : f->prev, 1, s->comb);
-    compute_metric(s, f->vars, f, parity, f, -1, s->var);
-    emms_c();
-
-    /* Advance the circular list */
-    if (!s->first)
-        s->first = s->head;
-
-    s->last = s->head;
-    s->head = s->head->next;
-}
-
-static void copy_field(PullupContext *s,
-                       PullupBuffer *dst, PullupBuffer *src, int parity)
-{
-    uint8_t *dd, *ss;
-    int i;
-
-    for (i = 0; i < s->nb_planes; i++) {
-        ss = src->planes[i] + parity * s->planewidth[i];
-        dd = dst->planes[i] + parity * s->planewidth[i];
-
-        av_image_copy_plane(dd, s->planewidth[i] << 1,
-                            ss, s->planewidth[i] << 1,
-                            s->planewidth[i], s->planeheight[i] >> 1);
-    }
-}
-
-static void pullup_pack_frame(PullupContext *s, PullupFrame *fr)
-{
-    int i;
-
-    if (fr->buffer)
-        return;
-
-    if (fr->length < 2)
-        return; /* FIXME: deal with this */
-
-    for (i = 0; i < 2; i++) {
-        if (fr->ofields[i]->lock[i^1])
-            continue;
-
-        fr->buffer = fr->ofields[i];
-        pullup_lock_buffer(fr->buffer, 2);
-        copy_field(s, fr->buffer, fr->ofields[i^1], i^1);
-        return;
-    }
-
-    fr->buffer = pullup_get_buffer(s, 2);
-
-    copy_field(s, fr->buffer, fr->ofields[0], 0);
-    copy_field(s, fr->buffer, fr->ofields[1], 1);
-}
-
-static int filter_frame(AVFilterLink *inlink, AVFrame *in)
-{
-    AVFilterContext *ctx = inlink->dst;
-    AVFilterLink *outlink = ctx->outputs[0];
-    PullupContext *s = ctx->priv;
-    PullupBuffer *b;
-    PullupFrame *f;
-    AVFrame *out;
-    int p, ret = 0;
-
-    b = pullup_get_buffer(s, 2);
-    if (!b) {
-        av_log(ctx, AV_LOG_WARNING, "Could not get buffer!\n");
-        f = pullup_get_frame(s);
-        pullup_release_frame(f);
-        goto end;
-    }
-
-    av_image_copy(b->planes, s->planewidth,
-                  (const uint8_t**)in->data, in->linesize,
-                  inlink->format, inlink->w, inlink->h);
-
-    p = in->interlaced_frame ? !in->top_field_first : 0;
-    pullup_submit_field(s, b, p  );
-    pullup_submit_field(s, b, p^1);
-
-    if (in->repeat_pict)
-        pullup_submit_field(s, b, p);
-
-    pullup_release_buffer(b, 2);
-
-    f = pullup_get_frame(s);
-    if (!f)
-        goto end;
-
-    if (f->length < 2) {
-        pullup_release_frame(f);
-        f = pullup_get_frame(s);
-        if (!f)
-            goto end;
-        if (f->length < 2) {
-            pullup_release_frame(f);
-            if (!in->repeat_pict)
-                goto end;
-            f = pullup_get_frame(s);
-            if (!f)
-                goto end;
-            if (f->length < 2) {
-                pullup_release_frame(f);
-                goto end;
-            }
-        }
-    }
-
-    /* If the frame isn't already exportable... */
-    if (!f->buffer)
-        pullup_pack_frame(s, f);
-
-    out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
-    if (!out) {
-        ret = AVERROR(ENOMEM);
-        goto end;
-    }
-    av_frame_copy_props(out, in);
-
-    av_image_copy(out->data, out->linesize,
-                  (const uint8_t**)f->buffer->planes, s->planewidth,
-                  inlink->format, inlink->w, inlink->h);
-
-    ret = ff_filter_frame(outlink, out);
-    pullup_release_frame(f);
-end:
-    av_frame_free(&in);
-    return ret;
-}
-
-static av_cold void uninit(AVFilterContext *ctx)
-{
-    PullupContext *s = ctx->priv;
-    int i;
-
-    free_field_queue(s->head, &s->last);
-
-    for (i = 0; i < FF_ARRAY_ELEMS(s->buffers); i++) {
-        av_freep(&s->buffers[i].planes[0]);
-        av_freep(&s->buffers[i].planes[1]);
-        av_freep(&s->buffers[i].planes[2]);
-    }
-}
-
-static const AVFilterPad pullup_inputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .filter_frame = filter_frame,
-        .config_props = config_input,
-    },
-    { NULL }
-};
-
-static const AVFilterPad pullup_outputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .config_props = config_output,
-    },
-    { NULL }
-};
-
-AVFilter ff_vf_pullup = {
-    .name          = "pullup",
-    .description   = NULL_IF_CONFIG_SMALL("Pullup from field sequence to frames."),
-    .priv_size     = sizeof(PullupContext),
-    .priv_class    = &pullup_class,
-    .uninit        = uninit,
-    .query_formats = query_formats,
-    .inputs        = pullup_inputs,
-    .outputs       = pullup_outputs,
-};
diff --git a/libavfilter/vf_sab.c b/libavfilter/vf_sab.c
deleted file mode 100644
index 51bbc5a..0000000
--- a/libavfilter/vf_sab.c
+++ /dev/null
@@ -1,339 +0,0 @@
-/*
- * Copyright (c) 2002 Michael Niedermayer <michaelni@gmx.at>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with FFmpeg; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-/**
- * @file
- * Shape Adaptive Blur filter, ported from MPlayer libmpcodecs/vf_sab.c
- */
-
-#include "libavutil/opt.h"
-#include "libavutil/pixdesc.h"
-#include "libswscale/swscale.h"
-
-#include "avfilter.h"
-#include "formats.h"
-#include "internal.h"
-
-typedef struct {
-    float radius;
-    float pre_filter_radius;
-    float strength;
-    float quality;
-    struct SwsContext *pre_filter_context;
-    uint8_t *pre_filter_buf;
-    int pre_filter_linesize;
-    int dist_width;
-    int dist_linesize;
-    int *dist_coeff;
-#define COLOR_DIFF_COEFF_SIZE 512
-    int color_diff_coeff[COLOR_DIFF_COEFF_SIZE];
-} FilterParam;
-
-typedef struct {
-    const AVClass *class;
-    FilterParam  luma;
-    FilterParam  chroma;
-    int          hsub;
-    int          vsub;
-    unsigned int sws_flags;
-} SabContext;
-
-static int query_formats(AVFilterContext *ctx)
-{
-    static const enum AVPixelFormat pix_fmts[] = {
-        AV_PIX_FMT_YUV420P,
-        AV_PIX_FMT_YUV410P,
-        AV_PIX_FMT_YUV444P,
-        AV_PIX_FMT_YUV422P,
-        AV_PIX_FMT_YUV411P,
-        AV_PIX_FMT_NONE
-    };
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-
-    return 0;
-}
-
-#define RADIUS_MIN 0.1
-#define RADIUS_MAX 4.0
-
-#define PRE_FILTER_RADIUS_MIN 0.1
-#define PRE_FILTER_RADIUS_MAX 2.0
-
-#define STRENGTH_MIN 0.1
-#define STRENGTH_MAX 100.0
-
-#define OFFSET(x) offsetof(SabContext, x)
-#define FLAGS AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM
-
-static const AVOption sab_options[] = {
-    { "luma_radius",            "set luma radius", OFFSET(luma.radius), AV_OPT_TYPE_FLOAT, {.dbl=1.0}, RADIUS_MIN, RADIUS_MAX, .flags=FLAGS },
-    { "lr"         ,            "set luma radius", OFFSET(luma.radius), AV_OPT_TYPE_FLOAT, {.dbl=1.0}, RADIUS_MIN, RADIUS_MAX, .flags=FLAGS },
-    { "luma_pre_filter_radius", "set luma pre-filter radius", OFFSET(luma.pre_filter_radius), AV_OPT_TYPE_FLOAT, {.dbl=1.0}, PRE_FILTER_RADIUS_MIN, PRE_FILTER_RADIUS_MAX, .flags=FLAGS },
-    { "lpfr",                   "set luma pre-filter radius", OFFSET(luma.pre_filter_radius), AV_OPT_TYPE_FLOAT, {.dbl=1.0}, PRE_FILTER_RADIUS_MIN, PRE_FILTER_RADIUS_MAX, .flags=FLAGS },
-    { "luma_strength",          "set luma strength", OFFSET(luma.strength), AV_OPT_TYPE_FLOAT, {.dbl=1.0}, STRENGTH_MIN, STRENGTH_MAX, .flags=FLAGS },
-    { "ls",                     "set luma strength", OFFSET(luma.strength), AV_OPT_TYPE_FLOAT, {.dbl=1.0}, STRENGTH_MIN, STRENGTH_MAX, .flags=FLAGS },
-
-    { "chroma_radius",            "set chroma radius", OFFSET(chroma.radius), AV_OPT_TYPE_FLOAT, {.dbl=RADIUS_MIN-1}, RADIUS_MIN-1, RADIUS_MAX, .flags=FLAGS },
-    { "cr",                       "set chroma radius", OFFSET(chroma.radius), AV_OPT_TYPE_FLOAT, {.dbl=RADIUS_MIN-1}, RADIUS_MIN-1, RADIUS_MAX, .flags=FLAGS },
-    { "chroma_pre_filter_radius", "set chroma pre-filter radius",  OFFSET(chroma.pre_filter_radius), AV_OPT_TYPE_FLOAT, {.dbl=PRE_FILTER_RADIUS_MIN-1},
-                                  PRE_FILTER_RADIUS_MIN-1, PRE_FILTER_RADIUS_MAX, .flags=FLAGS },
-    { "cpfr",                     "set chroma pre-filter radius",  OFFSET(chroma.pre_filter_radius), AV_OPT_TYPE_FLOAT, {.dbl=PRE_FILTER_RADIUS_MIN-1},
-                                  PRE_FILTER_RADIUS_MIN-1, PRE_FILTER_RADIUS_MAX, .flags=FLAGS },
-    { "chroma_strength",          "set chroma strength", OFFSET(chroma.strength), AV_OPT_TYPE_FLOAT, {.dbl=STRENGTH_MIN-1}, STRENGTH_MIN-1, STRENGTH_MAX, .flags=FLAGS },
-    { "cs",                       "set chroma strength", OFFSET(chroma.strength), AV_OPT_TYPE_FLOAT, {.dbl=STRENGTH_MIN-1}, STRENGTH_MIN-1, STRENGTH_MAX, .flags=FLAGS },
-
-    { NULL }
-};
-
-AVFILTER_DEFINE_CLASS(sab);
-
-static av_cold int init(AVFilterContext *ctx)
-{
-    SabContext *sab = ctx->priv;
-
-    /* make chroma default to luma values, if not explicitly set */
-    if (sab->chroma.radius < RADIUS_MIN)
-        sab->chroma.radius = sab->luma.radius;
-    if (sab->chroma.pre_filter_radius < PRE_FILTER_RADIUS_MIN)
-        sab->chroma.pre_filter_radius = sab->luma.pre_filter_radius;
-    if (sab->chroma.strength < STRENGTH_MIN)
-        sab->chroma.strength = sab->luma.strength;
-
-    sab->luma.quality = sab->chroma.quality = 3.0;
-    sab->sws_flags = SWS_POINT;
-
-    av_log(ctx, AV_LOG_VERBOSE,
-           "luma_radius:%f luma_pre_filter_radius::%f luma_strength:%f "
-           "chroma_radius:%f chroma_pre_filter_radius:%f chroma_strength:%f\n",
-           sab->luma  .radius, sab->luma  .pre_filter_radius, sab->luma  .strength,
-           sab->chroma.radius, sab->chroma.pre_filter_radius, sab->chroma.strength);
-    return 0;
-}
-
-static void close_filter_param(FilterParam *f)
-{
-    if (f->pre_filter_context) {
-        sws_freeContext(f->pre_filter_context);
-        f->pre_filter_context = NULL;
-    }
-    av_freep(&f->pre_filter_buf);
-    av_freep(&f->dist_coeff);
-}
-
-static av_cold void uninit(AVFilterContext *ctx)
-{
-    SabContext *sab = ctx->priv;
-
-    close_filter_param(&sab->luma);
-    close_filter_param(&sab->chroma);
-}
-
-static int open_filter_param(FilterParam *f, int width, int height, unsigned int sws_flags)
-{
-    SwsVector *vec;
-    SwsFilter sws_f;
-    int i, x, y;
-    int linesize = FFALIGN(width, 8);
-
-    f->pre_filter_buf = av_malloc(linesize * height);
-    if (!f->pre_filter_buf)
-        return AVERROR(ENOMEM);
-
-    f->pre_filter_linesize = linesize;
-    vec = sws_getGaussianVec(f->pre_filter_radius, f->quality);
-    sws_f.lumH = sws_f.lumV = vec;
-    sws_f.chrH = sws_f.chrV = NULL;
-    f->pre_filter_context = sws_getContext(width, height, AV_PIX_FMT_GRAY8,
-                                           width, height, AV_PIX_FMT_GRAY8,
-                                           sws_flags, &sws_f, NULL, NULL);
-    sws_freeVec(vec);
-
-    vec = sws_getGaussianVec(f->strength, 5.0);
-    for (i = 0; i < COLOR_DIFF_COEFF_SIZE; i++) {
-        double d;
-        int index = i-COLOR_DIFF_COEFF_SIZE/2 + vec->length/2;
-
-        if (index < 0 || index >= vec->length) d = 0.0;
-        else                                   d = vec->coeff[index];
-
-        f->color_diff_coeff[i] = (int)(d/vec->coeff[vec->length/2]*(1<<12) + 0.5);
-    }
-    sws_freeVec(vec);
-
-    vec = sws_getGaussianVec(f->radius, f->quality);
-    f->dist_width    = vec->length;
-    f->dist_linesize = FFALIGN(vec->length, 8);
-    f->dist_coeff    = av_malloc(f->dist_width * f->dist_linesize * sizeof(*f->dist_coeff));
-    if (!f->dist_coeff) {
-        sws_freeVec(vec);
-        return AVERROR(ENOMEM);
-    }
-
-    for (y = 0; y < vec->length; y++) {
-        for (x = 0; x < vec->length; x++) {
-            double d = vec->coeff[x] * vec->coeff[y];
-            f->dist_coeff[x + y*f->dist_linesize] = (int)(d*(1<<10) + 0.5);
-        }
-    }
-    sws_freeVec(vec);
-
-    return 0;
-}
-
-static int config_props(AVFilterLink *inlink)
-{
-    SabContext *sab = inlink->dst->priv;
-    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);
-    int ret;
-
-    sab->hsub = desc->log2_chroma_w;
-    sab->vsub = desc->log2_chroma_h;
-
-    close_filter_param(&sab->luma);
-    ret = open_filter_param(&sab->luma, inlink->w, inlink->h, sab->sws_flags);
-    if (ret < 0)
-        return ret;
-
-    close_filter_param(&sab->chroma);
-    ret = open_filter_param(&sab->chroma,
-                            FF_CEIL_RSHIFT(inlink->w, sab->hsub),
-                            FF_CEIL_RSHIFT(inlink->h, sab->vsub), sab->sws_flags);
-    return ret;
-}
-
-#define NB_PLANES 4
-
-static void blur(uint8_t       *dst, const int dst_linesize,
-                 const uint8_t *src, const int src_linesize,
-                 const int w, const int h, FilterParam *fp)
-{
-    int x, y;
-    FilterParam f = *fp;
-    const int radius = f.dist_width/2;
-
-    const uint8_t * const src2[NB_PLANES] = { src };
-    int          src2_linesize[NB_PLANES] = { src_linesize };
-    uint8_t     *dst2[NB_PLANES] = { f.pre_filter_buf };
-    int dst2_linesize[NB_PLANES] = { f.pre_filter_linesize };
-
-    sws_scale(f.pre_filter_context, src2, src2_linesize, 0, h, dst2, dst2_linesize);
-
-#define UPDATE_FACTOR do {                                              \
-        int factor;                                                     \
-        factor = f.color_diff_coeff[COLOR_DIFF_COEFF_SIZE/2 + pre_val - \
-                 f.pre_filter_buf[ix + iy*f.pre_filter_linesize]] * f.dist_coeff[dx + dy*f.dist_linesize]; \
-        sum += src[ix + iy*src_linesize] * factor;                      \
-        div += factor;                                                  \
-    } while (0)
-
-    for (y = 0; y < h; y++) {
-        for (x = 0; x < w; x++) {
-            int sum = 0;
-            int div = 0;
-            int dy;
-            const int pre_val = f.pre_filter_buf[x + y*f.pre_filter_linesize];
-            if (x >= radius && x < w - radius) {
-                for (dy = 0; dy < radius*2 + 1; dy++) {
-                    int dx;
-                    int iy = y+dy - radius;
-                    if      (iy < 0)  iy = -iy;
-                    else if (iy >= h) iy = h+h-iy-1;
-
-                    for (dx = 0; dx < radius*2 + 1; dx++) {
-                        const int ix = x+dx - radius;
-                        UPDATE_FACTOR;
-                    }
-                }
-            } else {
-                for (dy = 0; dy < radius*2+1; dy++) {
-                    int dx;
-                    int iy = y+dy - radius;
-                    if      (iy <  0) iy = -iy;
-                    else if (iy >= h) iy = h+h-iy-1;
-
-                    for (dx = 0; dx < radius*2 + 1; dx++) {
-                        int ix = x+dx - radius;
-                        if      (ix < 0)  ix = -ix;
-                        else if (ix >= w) ix = w+w-ix-1;
-                        UPDATE_FACTOR;
-                    }
-                }
-            }
-            dst[x + y*dst_linesize] = (sum + div/2) / div;
-        }
-    }
-}
-
-static int filter_frame(AVFilterLink *inlink, AVFrame *inpic)
-{
-    SabContext  *sab = inlink->dst->priv;
-    AVFilterLink *outlink = inlink->dst->outputs[0];
-    AVFrame *outpic;
-
-    outpic = ff_get_video_buffer(outlink, outlink->w, outlink->h);
-    if (!outpic) {
-        av_frame_free(&inpic);
-        return AVERROR(ENOMEM);
-    }
-    av_frame_copy_props(outpic, inpic);
-
-    blur(outpic->data[0], outpic->linesize[0], inpic->data[0],  inpic->linesize[0],
-         inlink->w, inlink->h, &sab->luma);
-    if (inpic->data[2]) {
-        int cw = FF_CEIL_RSHIFT(inlink->w, sab->hsub);
-        int ch = FF_CEIL_RSHIFT(inlink->h, sab->vsub);
-        blur(outpic->data[1], outpic->linesize[1], inpic->data[1], inpic->linesize[1], cw, ch, &sab->chroma);
-        blur(outpic->data[2], outpic->linesize[2], inpic->data[2], inpic->linesize[2], cw, ch, &sab->chroma);
-    }
-
-    av_frame_free(&inpic);
-    return ff_filter_frame(outlink, outpic);
-}
-
-static const AVFilterPad sab_inputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .filter_frame = filter_frame,
-        .config_props = config_props,
-    },
-    { NULL }
-};
-
-static const AVFilterPad sab_outputs[] = {
-    {
-        .name = "default",
-        .type = AVMEDIA_TYPE_VIDEO,
-    },
-    { NULL }
-};
-
-AVFilter ff_vf_sab = {
-    .name          = "sab",
-    .description   = NULL_IF_CONFIG_SMALL("Apply shape adaptive blur."),
-    .priv_size     = sizeof(SabContext),
-    .init          = init,
-    .uninit        = uninit,
-    .query_formats = query_formats,
-    .inputs        = sab_inputs,
-    .outputs       = sab_outputs,
-    .priv_class    = &sab_class,
-    .flags         = AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC,
-};
diff --git a/libavfilter/vf_smartblur.c b/libavfilter/vf_smartblur.c
deleted file mode 100644
index 114ac6f..0000000
--- a/libavfilter/vf_smartblur.c
+++ /dev/null
@@ -1,304 +0,0 @@
-/*
- * Copyright (c) 2002 Michael Niedermayer <michaelni@gmx.at>
- * Copyright (c) 2012 Jeremy Tran
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with FFmpeg; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-/**
- * @file
- * Apply a smartblur filter to the input video
- * Ported from MPlayer libmpcodecs/vf_smartblur.c by Michael Niedermayer.
- */
-
-#include "libavutil/opt.h"
-#include "libavutil/pixdesc.h"
-#include "libswscale/swscale.h"
-
-#include "avfilter.h"
-#include "formats.h"
-#include "internal.h"
-
-#define RADIUS_MIN 0.1
-#define RADIUS_MAX 5.0
-
-#define STRENGTH_MIN -1.0
-#define STRENGTH_MAX 1.0
-
-#define THRESHOLD_MIN -30
-#define THRESHOLD_MAX 30
-
-typedef struct {
-    float              radius;
-    float              strength;
-    int                threshold;
-    float              quality;
-    struct SwsContext *filter_context;
-} FilterParam;
-
-typedef struct {
-    const AVClass *class;
-    FilterParam  luma;
-    FilterParam  chroma;
-    int          hsub;
-    int          vsub;
-    unsigned int sws_flags;
-} SmartblurContext;
-
-#define OFFSET(x) offsetof(SmartblurContext, x)
-#define FLAGS AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM
-
-static const AVOption smartblur_options[] = {
-    { "luma_radius",    "set luma radius",    OFFSET(luma.radius),    AV_OPT_TYPE_FLOAT, {.dbl=1.0}, RADIUS_MIN, RADIUS_MAX, .flags=FLAGS },
-    { "lr"         ,    "set luma radius",    OFFSET(luma.radius),    AV_OPT_TYPE_FLOAT, {.dbl=1.0}, RADIUS_MIN, RADIUS_MAX, .flags=FLAGS },
-    { "luma_strength",  "set luma strength",  OFFSET(luma.strength),  AV_OPT_TYPE_FLOAT, {.dbl=1.0}, STRENGTH_MIN, STRENGTH_MAX, .flags=FLAGS },
-    { "ls",             "set luma strength",  OFFSET(luma.strength),  AV_OPT_TYPE_FLOAT, {.dbl=1.0}, STRENGTH_MIN, STRENGTH_MAX, .flags=FLAGS },
-    { "luma_threshold", "set luma threshold", OFFSET(luma.threshold), AV_OPT_TYPE_INT,   {.i64=0}, THRESHOLD_MIN, THRESHOLD_MAX, .flags=FLAGS },
-    { "lt",             "set luma threshold", OFFSET(luma.threshold), AV_OPT_TYPE_INT,   {.i64=0}, THRESHOLD_MIN, THRESHOLD_MAX, .flags=FLAGS },
-
-    { "chroma_radius",    "set chroma radius",    OFFSET(chroma.radius),    AV_OPT_TYPE_FLOAT, {.dbl=RADIUS_MIN-1},   RADIUS_MIN-1, RADIUS_MAX, .flags=FLAGS },
-    { "cr",               "set chroma radius",    OFFSET(chroma.radius),    AV_OPT_TYPE_FLOAT, {.dbl=RADIUS_MIN-1},   RADIUS_MIN-1, RADIUS_MAX, .flags=FLAGS },
-    { "chroma_strength",  "set chroma strength",  OFFSET(chroma.strength),  AV_OPT_TYPE_FLOAT, {.dbl=STRENGTH_MIN-1}, STRENGTH_MIN-1, STRENGTH_MAX, .flags=FLAGS },
-    { "cs",               "set chroma strength",  OFFSET(chroma.strength),  AV_OPT_TYPE_FLOAT, {.dbl=STRENGTH_MIN-1}, STRENGTH_MIN-1, STRENGTH_MAX, .flags=FLAGS },
-    { "chroma_threshold", "set chroma threshold", OFFSET(chroma.threshold), AV_OPT_TYPE_INT,   {.i64=THRESHOLD_MIN-1}, THRESHOLD_MIN-1, THRESHOLD_MAX, .flags=FLAGS },
-    { "ct",               "set chroma threshold", OFFSET(chroma.threshold), AV_OPT_TYPE_INT,   {.i64=THRESHOLD_MIN-1}, THRESHOLD_MIN-1, THRESHOLD_MAX, .flags=FLAGS },
-
-    { NULL }
-};
-
-AVFILTER_DEFINE_CLASS(smartblur);
-
-static av_cold int init(AVFilterContext *ctx)
-{
-    SmartblurContext *sblur = ctx->priv;
-
-    /* make chroma default to luma values, if not explicitly set */
-    if (sblur->chroma.radius < RADIUS_MIN)
-        sblur->chroma.radius = sblur->luma.radius;
-    if (sblur->chroma.strength < STRENGTH_MIN)
-        sblur->chroma.strength  = sblur->luma.strength;
-    if (sblur->chroma.threshold < THRESHOLD_MIN)
-        sblur->chroma.threshold = sblur->luma.threshold;
-
-    sblur->luma.quality = sblur->chroma.quality = 3.0;
-    sblur->sws_flags = SWS_BICUBIC;
-
-    av_log(ctx, AV_LOG_VERBOSE,
-           "luma_radius:%f luma_strength:%f luma_threshold:%d "
-           "chroma_radius:%f chroma_strength:%f chroma_threshold:%d\n",
-           sblur->luma.radius, sblur->luma.strength, sblur->luma.threshold,
-           sblur->chroma.radius, sblur->chroma.strength, sblur->chroma.threshold);
-
-    return 0;
-}
-
-static av_cold void uninit(AVFilterContext *ctx)
-{
-    SmartblurContext *sblur = ctx->priv;
-
-    sws_freeContext(sblur->luma.filter_context);
-    sws_freeContext(sblur->chroma.filter_context);
-}
-
-static int query_formats(AVFilterContext *ctx)
-{
-    static const enum AVPixelFormat pix_fmts[] = {
-        AV_PIX_FMT_YUV444P,      AV_PIX_FMT_YUV422P,
-        AV_PIX_FMT_YUV420P,      AV_PIX_FMT_YUV411P,
-        AV_PIX_FMT_YUV410P,      AV_PIX_FMT_YUV440P,
-        AV_PIX_FMT_GRAY8,
-        AV_PIX_FMT_NONE
-    };
-
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-
-    return 0;
-}
-
-static int alloc_sws_context(FilterParam *f, int width, int height, unsigned int flags)
-{
-    SwsVector *vec;
-    SwsFilter sws_filter;
-
-    vec = sws_getGaussianVec(f->radius, f->quality);
-
-    if (!vec)
-        return AVERROR(EINVAL);
-
-    sws_scaleVec(vec, f->strength);
-    vec->coeff[vec->length / 2] += 1.0 - f->strength;
-    sws_filter.lumH = sws_filter.lumV = vec;
-    sws_filter.chrH = sws_filter.chrV = NULL;
-    f->filter_context = sws_getCachedContext(NULL,
-                                             width, height, AV_PIX_FMT_GRAY8,
-                                             width, height, AV_PIX_FMT_GRAY8,
-                                             flags, &sws_filter, NULL, NULL);
-
-    sws_freeVec(vec);
-
-    if (!f->filter_context)
-        return AVERROR(EINVAL);
-
-    return 0;
-}
-
-static int config_props(AVFilterLink *inlink)
-{
-    SmartblurContext *sblur = inlink->dst->priv;
-    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);
-
-    sblur->hsub = desc->log2_chroma_w;
-    sblur->vsub = desc->log2_chroma_h;
-
-    alloc_sws_context(&sblur->luma, inlink->w, inlink->h, sblur->sws_flags);
-    alloc_sws_context(&sblur->chroma,
-                      FF_CEIL_RSHIFT(inlink->w, sblur->hsub),
-                      FF_CEIL_RSHIFT(inlink->h, sblur->vsub),
-                      sblur->sws_flags);
-
-    return 0;
-}
-
-static void blur(uint8_t       *dst, const int dst_linesize,
-                 const uint8_t *src, const int src_linesize,
-                 const int w, const int h, const int threshold,
-                 struct SwsContext *filter_context)
-{
-    int x, y;
-    int orig, filtered;
-    int diff;
-    /* Declare arrays of 4 to get aligned data */
-    const uint8_t* const src_array[4] = {src};
-    uint8_t *dst_array[4]             = {dst};
-    int src_linesize_array[4] = {src_linesize};
-    int dst_linesize_array[4] = {dst_linesize};
-
-    sws_scale(filter_context, src_array, src_linesize_array,
-              0, h, dst_array, dst_linesize_array);
-
-    if (threshold > 0) {
-        for (y = 0; y < h; ++y) {
-            for (x = 0; x < w; ++x) {
-                orig     = src[x + y * src_linesize];
-                filtered = dst[x + y * dst_linesize];
-                diff     = orig - filtered;
-
-                if (diff > 0) {
-                    if (diff > 2 * threshold)
-                        dst[x + y * dst_linesize] = orig;
-                    else if (diff > threshold)
-                        /* add 'diff' and substract 'threshold' from 'filtered' */
-                        dst[x + y * dst_linesize] = orig - threshold;
-                } else {
-                    if (-diff > 2 * threshold)
-                        dst[x + y * dst_linesize] = orig;
-                    else if (-diff > threshold)
-                        /* add 'diff' and 'threshold' to 'filtered' */
-                        dst[x + y * dst_linesize] = orig + threshold;
-                }
-            }
-        }
-    } else if (threshold < 0) {
-        for (y = 0; y < h; ++y) {
-            for (x = 0; x < w; ++x) {
-                orig     = src[x + y * src_linesize];
-                filtered = dst[x + y * dst_linesize];
-                diff     = orig - filtered;
-
-                if (diff > 0) {
-                    if (diff <= -threshold)
-                        dst[x + y * dst_linesize] = orig;
-                    else if (diff <= -2 * threshold)
-                        /* substract 'diff' and 'threshold' from 'orig' */
-                        dst[x + y * dst_linesize] = filtered - threshold;
-                } else {
-                    if (diff >= threshold)
-                        dst[x + y * dst_linesize] = orig;
-                    else if (diff >= 2 * threshold)
-                        /* add 'threshold' and substract 'diff' from 'orig' */
-                        dst[x + y * dst_linesize] = filtered + threshold;
-                }
-            }
-        }
-    }
-}
-
-static int filter_frame(AVFilterLink *inlink, AVFrame *inpic)
-{
-    SmartblurContext  *sblur  = inlink->dst->priv;
-    AVFilterLink *outlink     = inlink->dst->outputs[0];
-    AVFrame *outpic;
-    int cw = FF_CEIL_RSHIFT(inlink->w, sblur->hsub);
-    int ch = FF_CEIL_RSHIFT(inlink->h, sblur->vsub);
-
-    outpic = ff_get_video_buffer(outlink, outlink->w, outlink->h);
-    if (!outpic) {
-        av_frame_free(&inpic);
-        return AVERROR(ENOMEM);
-    }
-    av_frame_copy_props(outpic, inpic);
-
-    blur(outpic->data[0], outpic->linesize[0],
-         inpic->data[0],  inpic->linesize[0],
-         inlink->w, inlink->h, sblur->luma.threshold,
-         sblur->luma.filter_context);
-
-    if (inpic->data[2]) {
-        blur(outpic->data[1], outpic->linesize[1],
-             inpic->data[1],  inpic->linesize[1],
-             cw, ch, sblur->chroma.threshold,
-             sblur->chroma.filter_context);
-        blur(outpic->data[2], outpic->linesize[2],
-             inpic->data[2],  inpic->linesize[2],
-             cw, ch, sblur->chroma.threshold,
-             sblur->chroma.filter_context);
-    }
-
-    av_frame_free(&inpic);
-    return ff_filter_frame(outlink, outpic);
-}
-
-static const AVFilterPad smartblur_inputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .filter_frame = filter_frame,
-        .config_props = config_props,
-    },
-    { NULL }
-};
-
-static const AVFilterPad smartblur_outputs[] = {
-    {
-        .name = "default",
-        .type = AVMEDIA_TYPE_VIDEO,
-    },
-    { NULL }
-};
-
-AVFilter ff_vf_smartblur = {
-    .name          = "smartblur",
-    .description   = NULL_IF_CONFIG_SMALL("Blur the input video without impacting the outlines."),
-    .priv_size     = sizeof(SmartblurContext),
-    .init          = init,
-    .uninit        = uninit,
-    .query_formats = query_formats,
-    .inputs        = smartblur_inputs,
-    .outputs       = smartblur_outputs,
-    .priv_class    = &smartblur_class,
-    .flags         = AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC,
-};
diff --git a/libavfilter/vf_spp.c b/libavfilter/vf_spp.c
deleted file mode 100644
index 683e333..0000000
--- a/libavfilter/vf_spp.c
+++ /dev/null
@@ -1,437 +0,0 @@
-/*
- * Copyright (c) 2003 Michael Niedermayer <michaelni@gmx.at>
- * Copyright (c) 2013 Clment Bsch <u pkh me>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with FFmpeg; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-/**
- * @file
- * Simple post processing filter
- *
- * This implementation is based on an algorithm described in
- * "Aria Nosratinia Embedded Post-Processing for
- * Enhancement of Compressed Images (1999)"
- *
- * Originally written by Michael Niedermayer for the MPlayer project, and
- * ported by Clment Bsch for FFmpeg.
- */
-
-#include "libavcodec/dsputil.h"
-#include "libavutil/avassert.h"
-#include "libavutil/imgutils.h"
-#include "libavutil/opt.h"
-#include "libavutil/pixdesc.h"
-#include "internal.h"
-#include "vf_spp.h"
-
-enum mode {
-    MODE_HARD,
-    MODE_SOFT,
-    NB_MODES
-};
-
-#define OFFSET(x) offsetof(SPPContext, x)
-#define FLAGS AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM
-static const AVOption spp_options[] = {
-    { "quality", "set quality", OFFSET(log2_count), AV_OPT_TYPE_INT, {.i64 = 3}, 0, MAX_LEVEL, FLAGS },
-    { "qp", "force a constant quantizer parameter", OFFSET(qp), AV_OPT_TYPE_INT, {.i64 = 0}, 0, 63, FLAGS },
-    { "mode", "set thresholding mode", OFFSET(mode), AV_OPT_TYPE_INT, {.i64 = MODE_HARD}, 0, NB_MODES - 1, FLAGS, "mode" },
-        { "hard", "hard thresholding", 0, AV_OPT_TYPE_CONST, {.i64 = MODE_HARD}, INT_MIN, INT_MAX, FLAGS, "mode" },
-        { "soft", "soft thresholding", 0, AV_OPT_TYPE_CONST, {.i64 = MODE_SOFT}, INT_MIN, INT_MAX, FLAGS, "mode" },
-    { "use_bframe_qp", "use B-frames' QP", OFFSET(use_bframe_qp), AV_OPT_TYPE_INT, {.i64 = 0}, 0, 1, FLAGS },
-    { NULL }
-};
-
-AVFILTER_DEFINE_CLASS(spp);
-
-// XXX: share between filters?
-DECLARE_ALIGNED(8, static const uint8_t, ldither)[8][8] = {
-    {  0,  48,  12,  60,   3,  51,  15,  63 },
-    { 32,  16,  44,  28,  35,  19,  47,  31 },
-    {  8,  56,   4,  52,  11,  59,   7,  55 },
-    { 40,  24,  36,  20,  43,  27,  39,  23 },
-    {  2,  50,  14,  62,   1,  49,  13,  61 },
-    { 34,  18,  46,  30,  33,  17,  45,  29 },
-    { 10,  58,   6,  54,   9,  57,   5,  53 },
-    { 42,  26,  38,  22,  41,  25,  37,  21 },
-};
-
-static const uint8_t offset[127][2] = {
-    {0,0},
-    {0,0}, {4,4},                                           // quality = 1
-    {0,0}, {2,2}, {6,4}, {4,6},                             // quality = 2
-    {0,0}, {5,1}, {2,2}, {7,3}, {4,4}, {1,5}, {6,6}, {3,7}, // quality = 3
-
-    {0,0}, {4,0}, {1,1}, {5,1}, {3,2}, {7,2}, {2,3}, {6,3}, // quality = 4
-    {0,4}, {4,4}, {1,5}, {5,5}, {3,6}, {7,6}, {2,7}, {6,7},
-
-    {0,0}, {0,2}, {0,4}, {0,6}, {1,1}, {1,3}, {1,5}, {1,7}, // quality = 5
-    {2,0}, {2,2}, {2,4}, {2,6}, {3,1}, {3,3}, {3,5}, {3,7},
-    {4,0}, {4,2}, {4,4}, {4,6}, {5,1}, {5,3}, {5,5}, {5,7},
-    {6,0}, {6,2}, {6,4}, {6,6}, {7,1}, {7,3}, {7,5}, {7,7},
-
-    {0,0}, {4,4}, {0,4}, {4,0}, {2,2}, {6,6}, {2,6}, {6,2}, // quality = 6
-    {0,2}, {4,6}, {0,6}, {4,2}, {2,0}, {6,4}, {2,4}, {6,0},
-    {1,1}, {5,5}, {1,5}, {5,1}, {3,3}, {7,7}, {3,7}, {7,3},
-    {1,3}, {5,7}, {1,7}, {5,3}, {3,1}, {7,5}, {3,5}, {7,1},
-    {0,1}, {4,5}, {0,5}, {4,1}, {2,3}, {6,7}, {2,7}, {6,3},
-    {0,3}, {4,7}, {0,7}, {4,3}, {2,1}, {6,5}, {2,5}, {6,1},
-    {1,0}, {5,4}, {1,4}, {5,0}, {3,2}, {7,6}, {3,6}, {7,2},
-    {1,2}, {5,6}, {1,6}, {5,2}, {3,0}, {7,4}, {3,4}, {7,0},
-};
-
-static void hardthresh_c(int16_t dst[64], const int16_t src[64],
-                         int qp, const uint8_t *permutation)
-{
-    int i;
-    int bias = 0; // FIXME
-
-    unsigned threshold1 = qp * ((1<<4) - bias) - 1;
-    unsigned threshold2 = threshold1 << 1;
-
-    memset(dst, 0, 64 * sizeof(dst[0]));
-    dst[0] = (src[0] + 4) >> 3;
-
-    for (i = 1; i < 64; i++) {
-        int level = src[i];
-        if (((unsigned)(level + threshold1)) > threshold2) {
-            const int j = permutation[i];
-            dst[j] = (level + 4) >> 3;
-        }
-    }
-}
-
-static void softthresh_c(int16_t dst[64], const int16_t src[64],
-                         int qp, const uint8_t *permutation)
-{
-    int i;
-    int bias = 0; //FIXME
-
-    unsigned threshold1 = qp * ((1<<4) - bias) - 1;
-    unsigned threshold2 = threshold1 << 1;
-
-    memset(dst, 0, 64 * sizeof(dst[0]));
-    dst[0] = (src[0] + 4) >> 3;
-
-    for (i = 1; i < 64; i++) {
-        int level = src[i];
-        if (((unsigned)(level + threshold1)) > threshold2) {
-            const int j = permutation[i];
-            if (level > 0) dst[j] = (level - threshold1 + 4) >> 3;
-            else           dst[j] = (level + threshold1 + 4) >> 3;
-        }
-    }
-}
-
-static void store_slice_c(uint8_t *dst, const int16_t *src,
-                          int dst_linesize, int src_linesize,
-                          int width, int height, int log2_scale,
-                          const uint8_t dither[8][8])
-{
-    int y, x;
-
-#define STORE(pos) do {                                                     \
-    temp = ((src[x + y*src_linesize + pos] << log2_scale) + d[pos]) >> 6;   \
-    if (temp & 0x100)                                                       \
-        temp = ~(temp >> 31);                                               \
-    dst[x + y*dst_linesize + pos] = temp;                                   \
-} while (0)
-
-    for (y = 0; y < height; y++) {
-        const uint8_t *d = dither[y];
-        for (x = 0; x < width; x += 8) {
-            int temp;
-            STORE(0);
-            STORE(1);
-            STORE(2);
-            STORE(3);
-            STORE(4);
-            STORE(5);
-            STORE(6);
-            STORE(7);
-        }
-    }
-}
-
-static inline void add_block(int16_t *dst, int linesize, const int16_t block[64])
-{
-    int y;
-
-    for (y = 0; y < 8; y++) {
-        *(uint32_t *)&dst[0 + y*linesize] += *(uint32_t *)&block[0 + y*8];
-        *(uint32_t *)&dst[2 + y*linesize] += *(uint32_t *)&block[2 + y*8];
-        *(uint32_t *)&dst[4 + y*linesize] += *(uint32_t *)&block[4 + y*8];
-        *(uint32_t *)&dst[6 + y*linesize] += *(uint32_t *)&block[6 + y*8];
-    }
-}
-
-// XXX: export the function?
-static inline int norm_qscale(int qscale, int type)
-{
-    switch (type) {
-    case FF_QSCALE_TYPE_MPEG1: return qscale;
-    case FF_QSCALE_TYPE_MPEG2: return qscale >> 1;
-    case FF_QSCALE_TYPE_H264:  return qscale >> 2;
-    case FF_QSCALE_TYPE_VP56:  return (63 - qscale + 2) >> 2;
-    }
-    return qscale;
-}
-
-static void filter(SPPContext *p, uint8_t *dst, uint8_t *src,
-                   int dst_linesize, int src_linesize, int width, int height,
-                   const uint8_t *qp_table, int qp_stride, int is_luma)
-{
-    int x, y, i;
-    const int count = 1 << p->log2_count;
-    const int linesize = is_luma ? p->temp_linesize : FFALIGN(width+16, 16);
-    DECLARE_ALIGNED(16, uint64_t, block_align)[32];
-    int16_t *block  = (int16_t *)block_align;
-    int16_t *block2 = (int16_t *)(block_align + 16);
-
-    for (y = 0; y < height; y++) {
-        int index = 8 + 8*linesize + y*linesize;
-        memcpy(p->src + index, src + y*src_linesize, width);
-        for (x = 0; x < 8; x++) {
-            p->src[index         - x - 1] = p->src[index +         x    ];
-            p->src[index + width + x    ] = p->src[index + width - x - 1];
-        }
-    }
-    for (y = 0; y < 8; y++) {
-        memcpy(p->src + (       7-y)*linesize, p->src + (       y+8)*linesize, linesize);
-        memcpy(p->src + (height+8+y)*linesize, p->src + (height-y+7)*linesize, linesize);
-    }
-
-    for (y = 0; y < height + 8; y += 8) {
-        memset(p->temp + (8 + y) * linesize, 0, 8 * linesize * sizeof(*p->temp));
-        for (x = 0; x < width + 8; x += 8) {
-            int qp;
-
-            if (p->qp) {
-                qp = p->qp;
-            } else{
-                const int qps = 3 + is_luma;
-                qp = qp_table[(FFMIN(x, width - 1) >> qps) + (FFMIN(y, height - 1) >> qps) * qp_stride];
-                qp = FFMAX(1, norm_qscale(qp, p->qscale_type));
-            }
-            for (i = 0; i < count; i++) {
-                const int x1 = x + offset[i + count - 1][0];
-                const int y1 = y + offset[i + count - 1][1];
-                const int index = x1 + y1*linesize;
-                p->dsp.get_pixels(block, p->src + index, linesize);
-                p->dsp.fdct(block);
-                p->requantize(block2, block, qp, p->dsp.idct_permutation);
-                p->dsp.idct(block2);
-                add_block(p->temp + index, linesize, block2);
-            }
-        }
-        if (y)
-            p->store_slice(dst + (y - 8) * dst_linesize, p->temp + 8 + y*linesize,
-                           dst_linesize, linesize, width,
-                           FFMIN(8, height + 8 - y), MAX_LEVEL - p->log2_count,
-                           ldither);
-    }
-}
-
-static int query_formats(AVFilterContext *ctx)
-{
-    static const enum PixelFormat pix_fmts[] = {
-        AV_PIX_FMT_YUV444P,  AV_PIX_FMT_YUV422P,
-        AV_PIX_FMT_YUV420P,  AV_PIX_FMT_YUV411P,
-        AV_PIX_FMT_YUV410P,  AV_PIX_FMT_YUV440P,
-        AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUVJ422P,
-        AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ440P,
-        AV_PIX_FMT_NONE
-    };
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-    return 0;
-}
-
-static int config_input(AVFilterLink *inlink)
-{
-    SPPContext *spp = inlink->dst->priv;
-    const int h = FFALIGN(inlink->h + 16, 16);
-    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);
-
-    spp->hsub = desc->log2_chroma_w;
-    spp->vsub = desc->log2_chroma_h;
-    spp->temp_linesize = FFALIGN(inlink->w + 16, 16);
-    spp->temp = av_malloc(spp->temp_linesize * h * sizeof(*spp->temp));
-    spp->src  = av_malloc(spp->temp_linesize * h * sizeof(*spp->src));
-    if (!spp->use_bframe_qp) {
-        /* we are assuming here the qp blocks will not be smaller that 16x16 */
-        spp->non_b_qp_alloc_size = FF_CEIL_RSHIFT(inlink->w, 4) * FF_CEIL_RSHIFT(inlink->h, 4);
-        spp->non_b_qp_table = av_calloc(spp->non_b_qp_alloc_size, sizeof(*spp->non_b_qp_table));
-        if (!spp->non_b_qp_table)
-            return AVERROR(ENOMEM);
-    }
-    if (!spp->temp || !spp->src)
-        return AVERROR(ENOMEM);
-    return 0;
-}
-
-static int filter_frame(AVFilterLink *inlink, AVFrame *in)
-{
-    AVFilterContext *ctx = inlink->dst;
-    SPPContext *spp = ctx->priv;
-    AVFilterLink *outlink = ctx->outputs[0];
-    AVFrame *out = in;
-    int qp_stride = 0;
-    const int8_t *qp_table = NULL;
-
-    /* if we are not in a constant user quantizer mode and we don't want to use
-     * the quantizers from the B-frames (B-frames often have a higher QP), we
-     * need to save the qp table from the last non B-frame; this is what the
-     * following code block does */
-    if (!spp->qp) {
-        qp_table = av_frame_get_qp_table(in, &qp_stride, &spp->qscale_type);
-
-        if (qp_table && !spp->use_bframe_qp && in->pict_type != AV_PICTURE_TYPE_B) {
-            int w, h;
-
-            /* if the qp stride is not set, it means the QP are only defined on
-             * a line basis */
-            if (!qp_stride) {
-                w = FF_CEIL_RSHIFT(inlink->w, 4);
-                h = 1;
-            } else {
-                w = FF_CEIL_RSHIFT(qp_stride, 4);
-                h = FF_CEIL_RSHIFT(inlink->h, 4);
-            }
-            av_assert0(w * h <= spp->non_b_qp_alloc_size);
-            memcpy(spp->non_b_qp_table, qp_table, w * h);
-        }
-    }
-
-    if (spp->log2_count && !ctx->is_disabled) {
-        if (!spp->use_bframe_qp && spp->non_b_qp_table)
-            qp_table = spp->non_b_qp_table;
-
-        if (qp_table || spp->qp) {
-            const int cw = FF_CEIL_RSHIFT(inlink->w, spp->hsub);
-            const int ch = FF_CEIL_RSHIFT(inlink->h, spp->vsub);
-
-            /* get a new frame if in-place is not possible or if the dimensions
-             * are not multiple of 8 */
-            if (!av_frame_is_writable(in) || (inlink->w & 7) || (inlink->h & 7)) {
-                const int aligned_w = FFALIGN(inlink->w, 8);
-                const int aligned_h = FFALIGN(inlink->h, 8);
-
-                out = ff_get_video_buffer(outlink, aligned_w, aligned_h);
-                if (!out) {
-                    av_frame_free(&in);
-                    return AVERROR(ENOMEM);
-                }
-                av_frame_copy_props(out, in);
-                out->width  = in->width;
-                out->height = in->height;
-            }
-
-            filter(spp, out->data[0], in->data[0], out->linesize[0], in->linesize[0], inlink->w, inlink->h, qp_table, qp_stride, 1);
-            filter(spp, out->data[1], in->data[1], out->linesize[1], in->linesize[1], cw,        ch,        qp_table, qp_stride, 0);
-            filter(spp, out->data[2], in->data[2], out->linesize[2], in->linesize[2], cw,        ch,        qp_table, qp_stride, 0);
-            emms_c();
-        }
-    }
-
-    if (in != out) {
-        if (in->data[3])
-            av_image_copy_plane(out->data[3], out->linesize[3],
-                                in ->data[3], in ->linesize[3],
-                                inlink->w, inlink->h);
-        av_frame_free(&in);
-    }
-    return ff_filter_frame(outlink, out);
-}
-
-static int process_command(AVFilterContext *ctx, const char *cmd, const char *args,
-                           char *res, int res_len, int flags)
-{
-    SPPContext *spp = ctx->priv;
-
-    if (!strcmp(cmd, "level")) {
-        if (!strcmp(args, "max"))
-            spp->log2_count = MAX_LEVEL;
-        else
-            spp->log2_count = av_clip(strtol(args, NULL, 10), 0, MAX_LEVEL);
-        return 0;
-    }
-    return AVERROR(ENOSYS);
-}
-
-static av_cold int init(AVFilterContext *ctx)
-{
-    SPPContext *spp = ctx->priv;
-
-    spp->avctx = avcodec_alloc_context3(NULL);
-    if (!spp->avctx)
-        return AVERROR(ENOMEM);
-    avpriv_dsputil_init(&spp->dsp, spp->avctx);
-    spp->store_slice = store_slice_c;
-    switch (spp->mode) {
-    case MODE_HARD: spp->requantize = hardthresh_c; break;
-    case MODE_SOFT: spp->requantize = softthresh_c; break;
-    }
-    if (ARCH_X86)
-        ff_spp_init_x86(spp);
-    return 0;
-}
-
-static av_cold void uninit(AVFilterContext *ctx)
-{
-    SPPContext *spp = ctx->priv;
-
-    av_freep(&spp->temp);
-    av_freep(&spp->src);
-    if (spp->avctx) {
-        avcodec_close(spp->avctx);
-        av_freep(&spp->avctx);
-    }
-    av_freep(&spp->non_b_qp_table);
-}
-
-static const AVFilterPad spp_inputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .config_props = config_input,
-        .filter_frame = filter_frame,
-    },
-    { NULL }
-};
-
-static const AVFilterPad spp_outputs[] = {
-    {
-        .name = "default",
-        .type = AVMEDIA_TYPE_VIDEO,
-    },
-    { NULL }
-};
-
-AVFilter ff_vf_spp = {
-    .name            = "spp",
-    .description     = NULL_IF_CONFIG_SMALL("Apply a simple post processing filter."),
-    .priv_size       = sizeof(SPPContext),
-    .init            = init,
-    .uninit          = uninit,
-    .query_formats   = query_formats,
-    .inputs          = spp_inputs,
-    .outputs         = spp_outputs,
-    .process_command = process_command,
-    .priv_class      = &spp_class,
-    .flags           = AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL,
-};
diff --git a/libavfilter/vf_stereo3d.c b/libavfilter/vf_stereo3d.c
deleted file mode 100644
index 2140120..0000000
--- a/libavfilter/vf_stereo3d.c
+++ /dev/null
@@ -1,664 +0,0 @@
-/*
- * Copyright (c) 2010 Gordon Schmidt <gordon.schmidt <at> s2000.tu-chemnitz.de>
- * Copyright (c) 2013 Paul B Mahol
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include "libavutil/avassert.h"
-#include "libavutil/imgutils.h"
-#include "libavutil/opt.h"
-#include "libavutil/parseutils.h"
-#include "libavutil/pixdesc.h"
-#include "avfilter.h"
-#include "drawutils.h"
-#include "formats.h"
-#include "internal.h"
-#include "video.h"
-
-enum StereoCode {
-    ANAGLYPH_RC_GRAY,   // anaglyph red/cyan gray
-    ANAGLYPH_RC_HALF,   // anaglyph red/cyan half colored
-    ANAGLYPH_RC_COLOR,  // anaglyph red/cyan colored
-    ANAGLYPH_RC_DUBOIS, // anaglyph red/cyan dubois
-    ANAGLYPH_GM_GRAY,   // anaglyph green/magenta gray
-    ANAGLYPH_GM_HALF,   // anaglyph green/magenta half colored
-    ANAGLYPH_GM_COLOR,  // anaglyph green/magenta colored
-    ANAGLYPH_GM_DUBOIS, // anaglyph green/magenta dubois
-    ANAGLYPH_YB_GRAY,   // anaglyph yellow/blue gray
-    ANAGLYPH_YB_HALF,   // anaglyph yellow/blue half colored
-    ANAGLYPH_YB_COLOR,  // anaglyph yellow/blue colored
-    ANAGLYPH_YB_DUBOIS, // anaglyph yellow/blue dubois
-    ANAGLYPH_RB_GRAY,   // anaglyph red/blue gray
-    ANAGLYPH_RG_GRAY,   // anaglyph red/green gray
-    MONO_L,             // mono output for debugging (left eye only)
-    MONO_R,             // mono output for debugging (right eye only)
-    INTERLEAVE_ROWS_LR, // row-interleave (left eye has top row)
-    INTERLEAVE_ROWS_RL, // row-interleave (right eye has top row)
-    SIDE_BY_SIDE_LR,    // side by side parallel (left eye left, right eye right)
-    SIDE_BY_SIDE_RL,    // side by side crosseye (right eye left, left eye right)
-    SIDE_BY_SIDE_2_LR,  // side by side parallel with half width resolution
-    SIDE_BY_SIDE_2_RL,  // side by side crosseye with half width resolution
-    ABOVE_BELOW_LR,     // above-below (left eye above, right eye below)
-    ABOVE_BELOW_RL,     // above-below (right eye above, left eye below)
-    ABOVE_BELOW_2_LR,   // above-below with half height resolution
-    ABOVE_BELOW_2_RL,   // above-below with half height resolution
-    ALTERNATING_LR,     // alternating frames (left eye first, right eye second)
-    ALTERNATING_RL,     // alternating frames (right eye first, left eye second)
-    STEREO_CODE_COUNT   // TODO: needs autodetection
-};
-
-typedef struct StereoComponent {
-    enum StereoCode format;
-    int width, height;
-    int off_left, off_right;
-    int off_lstep, off_rstep;
-    int row_left, row_right;
-} StereoComponent;
-
-static const int ana_coeff[][3][6] = {
-  [ANAGLYPH_RB_GRAY]   =
-    {{19595, 38470,  7471,     0,     0,     0},
-     {    0,     0,     0,     0,     0,     0},
-     {    0,     0,     0, 19595, 38470,  7471}},
-  [ANAGLYPH_RG_GRAY]   =
-    {{19595, 38470,  7471,     0,     0,     0},
-     {    0,     0,     0, 19595, 38470,  7471},
-     {    0,     0,     0,     0,     0,     0}},
-  [ANAGLYPH_RC_GRAY]   =
-    {{19595, 38470,  7471,     0,     0,     0},
-     {    0,     0,     0, 19595, 38470,  7471},
-     {    0,     0,     0, 19595, 38470,  7471}},
-  [ANAGLYPH_RC_HALF]   =
-    {{19595, 38470,  7471,     0,     0,     0},
-     {    0,     0,     0,     0, 65536,     0},
-     {    0,     0,     0,     0,     0, 65536}},
-  [ANAGLYPH_RC_COLOR]  =
-    {{65536,     0,     0,     0,     0,     0},
-     {    0,     0,     0,     0, 65536,     0},
-     {    0,     0,     0,     0,     0, 65536}},
-  [ANAGLYPH_RC_DUBOIS] =
-    {{29891, 32800, 11559, -2849, -5763,  -102},
-     {-2627, -2479, -1033, 24804, 48080, -1209},
-     { -997, -1350,  -358, -4729, -7403, 80373}},
-  [ANAGLYPH_GM_GRAY]   =
-    {{    0,     0,     0, 19595, 38470,  7471},
-     {19595, 38470,  7471,     0,     0,     0},
-     {    0,     0,     0, 19595, 38470,  7471}},
-  [ANAGLYPH_GM_HALF]   =
-    {{    0,     0,     0, 65536,     0,     0},
-     {19595, 38470,  7471,     0,     0,     0},
-     {    0,     0,     0,     0,     0, 65536}},
-  [ANAGLYPH_GM_COLOR]  =
-    {{    0,     0,     0, 65536,     0,     0},
-     {    0, 65536,     0,     0,     0,     0},
-     {    0,     0,     0,     0,     0, 65536}},
-  [ANAGLYPH_GM_DUBOIS]  =
-    {{-4063,-10354, -2556, 34669, 46203,  1573},
-     {18612, 43778,  9372, -1049,  -983, -4260},
-     { -983, -1769,  1376,   590,  4915, 61407}},
-  [ANAGLYPH_YB_GRAY]   =
-    {{    0,     0,     0, 19595, 38470,  7471},
-     {    0,     0,     0, 19595, 38470,  7471},
-     {19595, 38470,  7471,     0,     0,     0}},
-  [ANAGLYPH_YB_HALF]   =
-    {{    0,     0,     0, 65536,     0,     0},
-     {    0,     0,     0,     0, 65536,     0},
-     {19595, 38470,  7471,     0,     0,     0}},
-  [ANAGLYPH_YB_COLOR]  =
-    {{    0,     0,     0, 65536,     0,     0},
-     {    0,     0,     0,     0, 65536,     0},
-     {    0,     0, 65536,     0,     0,     0}},
-  [ANAGLYPH_YB_DUBOIS] =
-    {{65535,-12650,18451,   -987, -7590, -1049},
-     {-1604, 56032, 4196,    370,  3826, -1049},
-     {-2345,-10676, 1358,   5801, 11416, 56217}},
-};
-
-typedef struct Stereo3DContext {
-    const AVClass *class;
-    StereoComponent in, out;
-    int width, height;
-    int row_step;
-    const int *ana_matrix[3];
-    int nb_planes;
-    int linesize[4];
-    int pheight[4];
-    int hsub, vsub;
-    int pixstep[4];
-    AVFrame *prev;
-    double ts_unit;
-} Stereo3DContext;
-
-#define OFFSET(x) offsetof(Stereo3DContext, x)
-#define FLAGS AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM
-
-static const AVOption stereo3d_options[] = {
-    { "in",    "set input format",  OFFSET(in.format),  AV_OPT_TYPE_INT, {.i64=SIDE_BY_SIDE_LR}, SIDE_BY_SIDE_LR, STEREO_CODE_COUNT-1, FLAGS, "in"},
-    { "ab2l",  "above below half height left first",  0, AV_OPT_TYPE_CONST, {.i64=ABOVE_BELOW_2_LR},  0, 0, FLAGS, "in" },
-    { "ab2r",  "above below half height right first", 0, AV_OPT_TYPE_CONST, {.i64=ABOVE_BELOW_2_RL},  0, 0, FLAGS, "in" },
-    { "abl",   "above below left first",              0, AV_OPT_TYPE_CONST, {.i64=ABOVE_BELOW_LR},    0, 0, FLAGS, "in" },
-    { "abr",   "above below right first",             0, AV_OPT_TYPE_CONST, {.i64=ABOVE_BELOW_RL},    0, 0, FLAGS, "in" },
-    { "al",    "alternating frames left first",       0, AV_OPT_TYPE_CONST, {.i64=ALTERNATING_LR},    0, 0, FLAGS, "in" },
-    { "ar",    "alternating frames right first",      0, AV_OPT_TYPE_CONST, {.i64=ALTERNATING_RL},    0, 0, FLAGS, "in" },
-    { "sbs2l", "side by side half width left first",  0, AV_OPT_TYPE_CONST, {.i64=SIDE_BY_SIDE_2_LR}, 0, 0, FLAGS, "in" },
-    { "sbs2r", "side by side half width right first", 0, AV_OPT_TYPE_CONST, {.i64=SIDE_BY_SIDE_2_RL}, 0, 0, FLAGS, "in" },
-    { "sbsl",  "side by side left first",             0, AV_OPT_TYPE_CONST, {.i64=SIDE_BY_SIDE_LR},   0, 0, FLAGS, "in" },
-    { "sbsr",  "side by side right first",            0, AV_OPT_TYPE_CONST, {.i64=SIDE_BY_SIDE_RL},   0, 0, FLAGS, "in" },
-    { "out",   "set output format", OFFSET(out.format), AV_OPT_TYPE_INT, {.i64=ANAGLYPH_RC_DUBOIS}, 0, STEREO_CODE_COUNT-1, FLAGS, "out"},
-    { "ab2l",  "above below half height left first",  0, AV_OPT_TYPE_CONST, {.i64=ABOVE_BELOW_2_LR},   0, 0, FLAGS, "out" },
-    { "ab2r",  "above below half height right first", 0, AV_OPT_TYPE_CONST, {.i64=ABOVE_BELOW_2_RL},   0, 0, FLAGS, "out" },
-    { "abl",   "above below left first",              0, AV_OPT_TYPE_CONST, {.i64=ABOVE_BELOW_LR},     0, 0, FLAGS, "out" },
-    { "abr",   "above below right first",             0, AV_OPT_TYPE_CONST, {.i64=ABOVE_BELOW_RL},     0, 0, FLAGS, "out" },
-    { "agmc",  "anaglyph green magenta color",        0, AV_OPT_TYPE_CONST, {.i64=ANAGLYPH_GM_COLOR},  0, 0, FLAGS, "out" },
-    { "agmd",  "anaglyph green magenta dubois",       0, AV_OPT_TYPE_CONST, {.i64=ANAGLYPH_GM_DUBOIS}, 0, 0, FLAGS, "out" },
-    { "agmg",  "anaglyph green magenta gray",         0, AV_OPT_TYPE_CONST, {.i64=ANAGLYPH_GM_GRAY},   0, 0, FLAGS, "out" },
-    { "agmh",  "anaglyph green magenta half color",   0, AV_OPT_TYPE_CONST, {.i64=ANAGLYPH_GM_HALF},   0, 0, FLAGS, "out" },
-    { "al",    "alternating frames left first",       0, AV_OPT_TYPE_CONST, {.i64=ALTERNATING_LR},     0, 0, FLAGS, "out" },
-    { "ar",    "alternating frames right first",      0, AV_OPT_TYPE_CONST, {.i64=ALTERNATING_RL},     0, 0, FLAGS, "out" },
-    { "arbg",  "anaglyph red blue gray",              0, AV_OPT_TYPE_CONST, {.i64=ANAGLYPH_RB_GRAY},   0, 0, FLAGS, "out" },
-    { "arcc",  "anaglyph red cyan color",             0, AV_OPT_TYPE_CONST, {.i64=ANAGLYPH_RC_COLOR},  0, 0, FLAGS, "out" },
-    { "arcd",  "anaglyph red cyan dubois",            0, AV_OPT_TYPE_CONST, {.i64=ANAGLYPH_RC_DUBOIS}, 0, 0, FLAGS, "out" },
-    { "arcg",  "anaglyph red cyan gray",              0, AV_OPT_TYPE_CONST, {.i64=ANAGLYPH_RC_GRAY},   0, 0, FLAGS, "out" },
-    { "arch",  "anaglyph red cyan half color",        0, AV_OPT_TYPE_CONST, {.i64=ANAGLYPH_RC_HALF},   0, 0, FLAGS, "out" },
-    { "argg",  "anaglyph red green gray",             0, AV_OPT_TYPE_CONST, {.i64=ANAGLYPH_RG_GRAY},   0, 0, FLAGS, "out" },
-    { "aybc",  "anaglyph yellow blue color",          0, AV_OPT_TYPE_CONST, {.i64=ANAGLYPH_YB_COLOR},  0, 0, FLAGS, "out" },
-    { "aybd",  "anaglyph yellow blue dubois",         0, AV_OPT_TYPE_CONST, {.i64=ANAGLYPH_YB_DUBOIS}, 0, 0, FLAGS, "out" },
-    { "aybg",  "anaglyph yellow blue gray",           0, AV_OPT_TYPE_CONST, {.i64=ANAGLYPH_YB_GRAY},   0, 0, FLAGS, "out" },
-    { "aybh",  "anaglyph yellow blue half color",     0, AV_OPT_TYPE_CONST, {.i64=ANAGLYPH_YB_HALF},   0, 0, FLAGS, "out" },
-    { "irl",   "interleave rows left first",          0, AV_OPT_TYPE_CONST, {.i64=INTERLEAVE_ROWS_LR}, 0, 0, FLAGS, "out" },
-    { "irr",   "interleave rows right first",         0, AV_OPT_TYPE_CONST, {.i64=INTERLEAVE_ROWS_RL}, 0, 0, FLAGS, "out" },
-    { "ml",    "mono left",                           0, AV_OPT_TYPE_CONST, {.i64=MONO_L},             0, 0, FLAGS, "out" },
-    { "mr",    "mono right",                          0, AV_OPT_TYPE_CONST, {.i64=MONO_R},             0, 0, FLAGS, "out" },
-    { "sbs2l", "side by side half width left first",  0, AV_OPT_TYPE_CONST, {.i64=SIDE_BY_SIDE_2_LR},  0, 0, FLAGS, "out" },
-    { "sbs2r", "side by side half width right first", 0, AV_OPT_TYPE_CONST, {.i64=SIDE_BY_SIDE_2_RL},  0, 0, FLAGS, "out" },
-    { "sbsl",  "side by side left first",             0, AV_OPT_TYPE_CONST, {.i64=SIDE_BY_SIDE_LR},    0, 0, FLAGS, "out" },
-    { "sbsr",  "side by side right first",            0, AV_OPT_TYPE_CONST, {.i64=SIDE_BY_SIDE_RL},    0, 0, FLAGS, "out" },
-    { NULL }
-};
-
-AVFILTER_DEFINE_CLASS(stereo3d);
-
-static const enum AVPixelFormat anaglyph_pix_fmts[] = {
-    AV_PIX_FMT_RGB24, AV_PIX_FMT_BGR24,
-    AV_PIX_FMT_NONE
-};
-
-static const enum AVPixelFormat other_pix_fmts[] = {
-    AV_PIX_FMT_RGB24, AV_PIX_FMT_BGR24,
-    AV_PIX_FMT_RGB48BE, AV_PIX_FMT_BGR48BE,
-    AV_PIX_FMT_RGB48LE, AV_PIX_FMT_BGR48LE,
-    AV_PIX_FMT_RGBA64BE, AV_PIX_FMT_BGRA64BE,
-    AV_PIX_FMT_RGBA64LE, AV_PIX_FMT_BGRA64LE,
-    AV_PIX_FMT_RGBA,  AV_PIX_FMT_BGRA,
-    AV_PIX_FMT_ARGB,  AV_PIX_FMT_ABGR,
-    AV_PIX_FMT_RGB0,  AV_PIX_FMT_BGR0,
-    AV_PIX_FMT_0RGB,  AV_PIX_FMT_0BGR,
-    AV_PIX_FMT_GBRP,
-    AV_PIX_FMT_GBRP9BE,  AV_PIX_FMT_GBRP9LE,
-    AV_PIX_FMT_GBRP10BE, AV_PIX_FMT_GBRP10LE,
-    AV_PIX_FMT_GBRP12BE, AV_PIX_FMT_GBRP12LE,
-    AV_PIX_FMT_GBRP14BE, AV_PIX_FMT_GBRP14LE,
-    AV_PIX_FMT_GBRP16BE, AV_PIX_FMT_GBRP16LE,
-    AV_PIX_FMT_YUV410P,
-    AV_PIX_FMT_YUV411P,
-    AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUVA420P,
-    AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUVA422P,
-    AV_PIX_FMT_YUV440P,
-    AV_PIX_FMT_YUV444P, AV_PIX_FMT_YUVA444P,
-    AV_PIX_FMT_YUVJ411P,
-    AV_PIX_FMT_YUVJ420P,
-    AV_PIX_FMT_YUVJ422P,
-    AV_PIX_FMT_YUVJ440P,
-    AV_PIX_FMT_YUVJ444P,
-    AV_PIX_FMT_YUV420P9LE,  AV_PIX_FMT_YUVA420P9LE,
-    AV_PIX_FMT_YUV420P9BE,  AV_PIX_FMT_YUVA420P9BE,
-    AV_PIX_FMT_YUV422P9LE,  AV_PIX_FMT_YUVA422P9LE,
-    AV_PIX_FMT_YUV422P9BE,  AV_PIX_FMT_YUVA422P9BE,
-    AV_PIX_FMT_YUV444P9LE,  AV_PIX_FMT_YUVA444P9LE,
-    AV_PIX_FMT_YUV444P9BE,  AV_PIX_FMT_YUVA444P9BE,
-    AV_PIX_FMT_YUV420P10LE, AV_PIX_FMT_YUVA420P10LE,
-    AV_PIX_FMT_YUV420P10BE, AV_PIX_FMT_YUVA420P10BE,
-    AV_PIX_FMT_YUV422P10LE, AV_PIX_FMT_YUVA422P10LE,
-    AV_PIX_FMT_YUV422P10BE, AV_PIX_FMT_YUVA422P10BE,
-    AV_PIX_FMT_YUV444P10LE, AV_PIX_FMT_YUVA444P10LE,
-    AV_PIX_FMT_YUV444P10BE, AV_PIX_FMT_YUVA444P10BE,
-    AV_PIX_FMT_YUV420P12BE,  AV_PIX_FMT_YUV420P12LE,
-    AV_PIX_FMT_YUV422P12BE,  AV_PIX_FMT_YUV422P12LE,
-    AV_PIX_FMT_YUV444P12BE,  AV_PIX_FMT_YUV444P12LE,
-    AV_PIX_FMT_YUV420P14BE,  AV_PIX_FMT_YUV420P14LE,
-    AV_PIX_FMT_YUV422P14BE,  AV_PIX_FMT_YUV422P14LE,
-    AV_PIX_FMT_YUV444P14BE,  AV_PIX_FMT_YUV444P14LE,
-    AV_PIX_FMT_YUV420P16LE, AV_PIX_FMT_YUVA420P16LE,
-    AV_PIX_FMT_YUV420P16BE, AV_PIX_FMT_YUVA420P16BE,
-    AV_PIX_FMT_YUV422P16LE, AV_PIX_FMT_YUVA422P16LE,
-    AV_PIX_FMT_YUV422P16BE, AV_PIX_FMT_YUVA422P16BE,
-    AV_PIX_FMT_YUV444P16LE, AV_PIX_FMT_YUVA444P16LE,
-    AV_PIX_FMT_YUV444P16BE, AV_PIX_FMT_YUVA444P16BE,
-    AV_PIX_FMT_NONE
-};
-
-static int query_formats(AVFilterContext *ctx)
-{
-    Stereo3DContext *s = ctx->priv;
-    const enum AVPixelFormat *pix_fmts;
-
-    switch (s->out.format) {
-    case ANAGLYPH_GM_COLOR:
-    case ANAGLYPH_GM_DUBOIS:
-    case ANAGLYPH_GM_GRAY:
-    case ANAGLYPH_GM_HALF:
-    case ANAGLYPH_RB_GRAY:
-    case ANAGLYPH_RC_COLOR:
-    case ANAGLYPH_RC_DUBOIS:
-    case ANAGLYPH_RC_GRAY:
-    case ANAGLYPH_RC_HALF:
-    case ANAGLYPH_RG_GRAY:
-    case ANAGLYPH_YB_COLOR:
-    case ANAGLYPH_YB_DUBOIS:
-    case ANAGLYPH_YB_GRAY:
-    case ANAGLYPH_YB_HALF:
-        pix_fmts = anaglyph_pix_fmts;
-        break;
-    default:
-        pix_fmts = other_pix_fmts;
-    }
-
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-
-    return 0;
-}
-
-static int config_output(AVFilterLink *outlink)
-{
-    AVFilterContext *ctx = outlink->src;
-    AVFilterLink *inlink = ctx->inputs[0];
-    Stereo3DContext *s = ctx->priv;
-    AVRational aspect = inlink->sample_aspect_ratio;
-    AVRational fps = inlink->frame_rate;
-    AVRational tb = inlink->time_base;
-    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(outlink->format);
-    int ret;
-
-    switch (s->in.format) {
-    case SIDE_BY_SIDE_2_LR:
-    case SIDE_BY_SIDE_LR:
-    case SIDE_BY_SIDE_2_RL:
-    case SIDE_BY_SIDE_RL:
-        if (inlink->w & 1) {
-            av_log(ctx, AV_LOG_ERROR, "width must be even\n");
-            return AVERROR_INVALIDDATA;
-        }
-        break;
-    case ABOVE_BELOW_2_LR:
-    case ABOVE_BELOW_LR:
-    case ABOVE_BELOW_2_RL:
-    case ABOVE_BELOW_RL:
-        if (s->out.format == INTERLEAVE_ROWS_LR ||
-            s->out.format == INTERLEAVE_ROWS_RL) {
-            if (inlink->h & 3) {
-                av_log(ctx, AV_LOG_ERROR, "height must be multiple of 4\n");
-                return AVERROR_INVALIDDATA;
-            }
-        }
-        if (inlink->h & 1) {
-            av_log(ctx, AV_LOG_ERROR, "height must be even\n");
-            return AVERROR_INVALIDDATA;
-        }
-        break;
-    }
-
-    s->in.width     =
-    s->width        = inlink->w;
-    s->in.height    =
-    s->height       = inlink->h;
-    s->row_step     = 1;
-    s->in.off_lstep =
-    s->in.off_rstep =
-    s->in.off_left  =
-    s->in.off_right =
-    s->in.row_left  =
-    s->in.row_right = 0;
-
-    switch (s->in.format) {
-    case SIDE_BY_SIDE_2_LR:
-        aspect.num     *= 2;
-    case SIDE_BY_SIDE_LR:
-        s->width        = inlink->w / 2;
-        s->in.off_right = s->width;
-        break;
-    case SIDE_BY_SIDE_2_RL:
-        aspect.num     *= 2;
-    case SIDE_BY_SIDE_RL:
-        s->width        = inlink->w / 2;
-        s->in.off_left  = s->width;
-        break;
-    case ABOVE_BELOW_2_LR:
-        aspect.den     *= 2;
-    case ABOVE_BELOW_LR:
-        s->in.row_right =
-        s->height       = inlink->h / 2;
-        break;
-    case ABOVE_BELOW_2_RL:
-        aspect.den     *= 2;
-    case ABOVE_BELOW_RL:
-        s->in.row_left  =
-        s->height       = inlink->h / 2;
-        break;
-    case ALTERNATING_RL:
-    case ALTERNATING_LR:
-        outlink->flags |= FF_LINK_FLAG_REQUEST_LOOP;
-        fps.den        *= 2;
-        tb.num         *= 2;
-        break;
-    default:
-        av_log(ctx, AV_LOG_ERROR, "input format %d is not supported\n", s->in.format);
-        return AVERROR(EINVAL);
-    }
-
-    s->out.width     = s->width;
-    s->out.height    = s->height;
-    s->out.off_lstep =
-    s->out.off_rstep =
-    s->out.off_left  =
-    s->out.off_right =
-    s->out.row_left  =
-    s->out.row_right = 0;
-
-    switch (s->out.format) {
-    case ANAGLYPH_RB_GRAY:
-    case ANAGLYPH_RG_GRAY:
-    case ANAGLYPH_RC_GRAY:
-    case ANAGLYPH_RC_HALF:
-    case ANAGLYPH_RC_COLOR:
-    case ANAGLYPH_RC_DUBOIS:
-    case ANAGLYPH_GM_GRAY:
-    case ANAGLYPH_GM_HALF:
-    case ANAGLYPH_GM_COLOR:
-    case ANAGLYPH_GM_DUBOIS:
-    case ANAGLYPH_YB_GRAY:
-    case ANAGLYPH_YB_HALF:
-    case ANAGLYPH_YB_COLOR:
-    case ANAGLYPH_YB_DUBOIS: {
-        uint8_t rgba_map[4];
-
-        ff_fill_rgba_map(rgba_map, outlink->format);
-        s->ana_matrix[rgba_map[0]] = &ana_coeff[s->out.format][0][0];
-        s->ana_matrix[rgba_map[1]] = &ana_coeff[s->out.format][1][0];
-        s->ana_matrix[rgba_map[2]] = &ana_coeff[s->out.format][2][0];
-        break;
-    }
-    case SIDE_BY_SIDE_2_LR:
-        aspect.den      *= 2;
-    case SIDE_BY_SIDE_LR:
-        s->out.width     = s->width * 2;
-        s->out.off_right = s->width;
-        break;
-    case SIDE_BY_SIDE_2_RL:
-        aspect.den      *= 2;
-    case SIDE_BY_SIDE_RL:
-        s->out.width     = s->width * 2;
-        s->out.off_left  = s->width;
-        break;
-    case ABOVE_BELOW_2_LR:
-        aspect.num      *= 2;
-    case ABOVE_BELOW_LR:
-        s->out.height    = s->height * 2;
-        s->out.row_right = s->height;
-        break;
-    case ABOVE_BELOW_2_RL:
-        aspect.num      *= 2;
-    case ABOVE_BELOW_RL:
-        s->out.height    = s->height * 2;
-        s->out.row_left  = s->height;
-        break;
-    case INTERLEAVE_ROWS_LR:
-        s->row_step      = 2;
-        s->height        = s->height / 2;
-        s->out.off_rstep =
-        s->in.off_rstep  = 1;
-        break;
-    case INTERLEAVE_ROWS_RL:
-        s->row_step      = 2;
-        s->height        = s->height / 2;
-        s->out.off_lstep =
-        s->in.off_lstep  = 1;
-        break;
-    case MONO_R:
-        s->in.off_left   = s->in.off_right;
-        s->in.row_left   = s->in.row_right;
-    case MONO_L:
-        break;
-    case ALTERNATING_RL:
-    case ALTERNATING_LR:
-        fps.num         *= 2;
-        tb.den          *= 2;
-        break;
-    default:
-        av_log(ctx, AV_LOG_ERROR, "output format %d is not supported\n", s->out.format);
-        return AVERROR(EINVAL);
-    }
-
-    outlink->w = s->out.width;
-    outlink->h = s->out.height;
-    outlink->frame_rate = fps;
-    outlink->time_base = tb;
-    outlink->sample_aspect_ratio = aspect;
-
-    if ((ret = av_image_fill_linesizes(s->linesize, outlink->format, s->width)) < 0)
-        return ret;
-    s->nb_planes = av_pix_fmt_count_planes(outlink->format);
-    av_image_fill_max_pixsteps(s->pixstep, NULL, desc);
-    s->ts_unit = av_q2d(av_inv_q(av_mul_q(outlink->frame_rate, outlink->time_base)));
-    s->pheight[1] = s->pheight[2] = FF_CEIL_RSHIFT(s->height, desc->log2_chroma_h);
-    s->pheight[0] = s->pheight[3] = s->height;
-    s->hsub = desc->log2_chroma_w;
-    s->vsub = desc->log2_chroma_h;
-
-    return 0;
-}
-
-static inline uint8_t ana_convert(const int *coeff, const uint8_t *left, const uint8_t *right)
-{
-    int sum;
-
-    sum  = coeff[0] * left[0] + coeff[3] * right[0]; //red in
-    sum += coeff[1] * left[1] + coeff[4] * right[1]; //green in
-    sum += coeff[2] * left[2] + coeff[5] * right[2]; //blue in
-
-    return av_clip_uint8(sum >> 16);
-}
-
-static int filter_frame(AVFilterLink *inlink, AVFrame *inpicref)
-{
-    AVFilterContext *ctx  = inlink->dst;
-    Stereo3DContext *s = ctx->priv;
-    AVFilterLink *outlink = ctx->outputs[0];
-    AVFrame *out, *oleft, *oright, *ileft, *iright;
-    int out_off_left[4], out_off_right[4];
-    int in_off_left[4], in_off_right[4];
-    int i;
-
-    switch (s->in.format) {
-    case ALTERNATING_LR:
-    case ALTERNATING_RL:
-        if (!s->prev) {
-            s->prev = inpicref;
-            return 0;
-        }
-        ileft  = s->prev;
-        iright = inpicref;
-        if (s->in.format == ALTERNATING_RL)
-            FFSWAP(AVFrame *, ileft, iright);
-        break;
-    default:
-        ileft = iright = inpicref;
-    };
-
-    out = oleft = oright = ff_get_video_buffer(outlink, outlink->w, outlink->h);
-    if (!out) {
-        av_frame_free(&s->prev);
-        av_frame_free(&inpicref);
-        return AVERROR(ENOMEM);
-    }
-    av_frame_copy_props(out, inpicref);
-
-    if (s->out.format == ALTERNATING_LR ||
-        s->out.format == ALTERNATING_RL) {
-        oright = ff_get_video_buffer(outlink, outlink->w, outlink->h);
-        if (!oright) {
-            av_frame_free(&oleft);
-            av_frame_free(&s->prev);
-            av_frame_free(&inpicref);
-            return AVERROR(ENOMEM);
-        }
-        av_frame_copy_props(oright, inpicref);
-    }
-
-    for (i = 0; i < 4; i++) {
-        int hsub = i == 1 || i == 2 ? s->hsub : 0;
-        int vsub = i == 1 || i == 2 ? s->vsub : 0;
-        in_off_left[i]   = (FF_CEIL_RSHIFT(s->in.row_left,   vsub) + s->in.off_lstep)  * ileft->linesize[i]  + FF_CEIL_RSHIFT(s->in.off_left   * s->pixstep[i], hsub);
-        in_off_right[i]  = (FF_CEIL_RSHIFT(s->in.row_right,  vsub) + s->in.off_rstep)  * iright->linesize[i] + FF_CEIL_RSHIFT(s->in.off_right  * s->pixstep[i], hsub);
-        out_off_left[i]  = (FF_CEIL_RSHIFT(s->out.row_left,  vsub) + s->out.off_lstep) * oleft->linesize[i]  + FF_CEIL_RSHIFT(s->out.off_left  * s->pixstep[i], hsub);
-        out_off_right[i] = (FF_CEIL_RSHIFT(s->out.row_right, vsub) + s->out.off_rstep) * oright->linesize[i] + FF_CEIL_RSHIFT(s->out.off_right * s->pixstep[i], hsub);
-    }
-
-    switch (s->out.format) {
-    case ALTERNATING_LR:
-    case ALTERNATING_RL:
-    case SIDE_BY_SIDE_LR:
-    case SIDE_BY_SIDE_RL:
-    case SIDE_BY_SIDE_2_LR:
-    case SIDE_BY_SIDE_2_RL:
-    case ABOVE_BELOW_LR:
-    case ABOVE_BELOW_RL:
-    case ABOVE_BELOW_2_LR:
-    case ABOVE_BELOW_2_RL:
-    case INTERLEAVE_ROWS_LR:
-    case INTERLEAVE_ROWS_RL:
-        for (i = 0; i < s->nb_planes; i++) {
-            av_image_copy_plane(oleft->data[i] + out_off_left[i],
-                                oleft->linesize[i] * s->row_step,
-                                ileft->data[i] + in_off_left[i],
-                                ileft->linesize[i] * s->row_step,
-                                s->linesize[i], s->pheight[i]);
-            av_image_copy_plane(oright->data[i] + out_off_right[i],
-                                oright->linesize[i] * s->row_step,
-                                iright->data[i] + in_off_right[i],
-                                iright->linesize[i] * s->row_step,
-                                s->linesize[i], s->pheight[i]);
-        }
-        break;
-    case MONO_L:
-        iright = ileft;
-    case MONO_R:
-        for (i = 0; i < s->nb_planes; i++) {
-            av_image_copy_plane(out->data[i], out->linesize[i],
-                                iright->data[i] + in_off_left[i],
-                                iright->linesize[i],
-                                s->linesize[i], s->pheight[i]);
-        }
-        break;
-    case ANAGLYPH_RB_GRAY:
-    case ANAGLYPH_RG_GRAY:
-    case ANAGLYPH_RC_GRAY:
-    case ANAGLYPH_RC_HALF:
-    case ANAGLYPH_RC_COLOR:
-    case ANAGLYPH_RC_DUBOIS:
-    case ANAGLYPH_GM_GRAY:
-    case ANAGLYPH_GM_HALF:
-    case ANAGLYPH_GM_COLOR:
-    case ANAGLYPH_GM_DUBOIS:
-    case ANAGLYPH_YB_GRAY:
-    case ANAGLYPH_YB_HALF:
-    case ANAGLYPH_YB_COLOR:
-    case ANAGLYPH_YB_DUBOIS: {
-        int x, y, il, ir, o;
-        const uint8_t *lsrc = ileft->data[0];
-        const uint8_t *rsrc = iright->data[0];
-        uint8_t *dst = out->data[0];
-        int out_width = s->out.width;
-        const int **ana_matrix = s->ana_matrix;
-
-        for (y = 0; y < s->out.height; y++) {
-            o   = out->linesize[0] * y;
-            il  = in_off_left[0]  + y * ileft->linesize[0];
-            ir  = in_off_right[0] + y * iright->linesize[0];
-            for (x = 0; x < out_width; x++, il += 3, ir += 3, o+= 3) {
-                dst[o    ] = ana_convert(ana_matrix[0], lsrc + il, rsrc + ir);
-                dst[o + 1] = ana_convert(ana_matrix[1], lsrc + il, rsrc + ir);
-                dst[o + 2] = ana_convert(ana_matrix[2], lsrc + il, rsrc + ir);
-            }
-        }
-        break;
-    }
-    default:
-        av_assert0(0);
-    }
-
-    av_frame_free(&inpicref);
-    av_frame_free(&s->prev);
-    if (oright != oleft) {
-        if (s->out.format == ALTERNATING_LR)
-            FFSWAP(AVFrame *, oleft, oright);
-        oright->pts = outlink->frame_count * s->ts_unit;
-        ff_filter_frame(outlink, oright);
-        out = oleft;
-        oleft->pts = outlink->frame_count * s->ts_unit;
-    } else if (s->in.format == ALTERNATING_LR ||
-               s->in.format == ALTERNATING_RL) {
-        out->pts = outlink->frame_count * s->ts_unit;
-    }
-    return ff_filter_frame(outlink, out);
-}
-
-static av_cold void uninit(AVFilterContext *ctx)
-{
-    Stereo3DContext *s = ctx->priv;
-
-    av_frame_free(&s->prev);
-}
-
-static const AVFilterPad stereo3d_inputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .filter_frame = filter_frame,
-    },
-    { NULL }
-};
-
-static const AVFilterPad stereo3d_outputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .config_props = config_output,
-    },
-    { NULL }
-};
-
-AVFilter ff_vf_stereo3d = {
-    .name          = "stereo3d",
-    .description   = NULL_IF_CONFIG_SMALL("Convert video stereoscopic 3D view."),
-    .priv_size     = sizeof(Stereo3DContext),
-    .uninit        = uninit,
-    .query_formats = query_formats,
-    .inputs        = stereo3d_inputs,
-    .outputs       = stereo3d_outputs,
-    .priv_class    = &stereo3d_class,
-};
diff --git a/libavfilter/vf_super2xsai.c b/libavfilter/vf_super2xsai.c
deleted file mode 100644
index 686dac1..0000000
--- a/libavfilter/vf_super2xsai.c
+++ /dev/null
@@ -1,352 +0,0 @@
-/*
- * Copyright (c) 2010 Niel van der Westhuizen <nielkie@gmail.com>
- * Copyright (c) 2002 A'rpi
- * Copyright (c) 1997-2001 ZSNES Team ( zsknight@zsnes.com / _demo_@zsnes.com )
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with FFmpeg; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-/**
- * @file
- * Super 2xSaI video filter
- * Ported from MPlayer libmpcodecs/vf_2xsai.c.
- */
-
-#include "libavutil/pixdesc.h"
-#include "libavutil/intreadwrite.h"
-#include "avfilter.h"
-#include "formats.h"
-#include "internal.h"
-#include "video.h"
-
-typedef struct {
-    /* masks used for two pixels interpolation */
-    uint32_t hi_pixel_mask;
-    uint32_t lo_pixel_mask;
-
-    /* masks used for four pixels interpolation */
-    uint32_t q_hi_pixel_mask;
-    uint32_t q_lo_pixel_mask;
-
-    int bpp; ///< bytes per pixel, pixel stride for each (packed) pixel
-    int is_be;
-} Super2xSaIContext;
-
-#define GET_RESULT(A, B, C, D) ((A != C || A != D) - (B != C || B != D))
-
-#define INTERPOLATE(A, B) (((A & hi_pixel_mask) >> 1) + ((B & hi_pixel_mask) >> 1) + (A & B & lo_pixel_mask))
-
-#define Q_INTERPOLATE(A, B, C, D) ((A & q_hi_pixel_mask) >> 2) + ((B & q_hi_pixel_mask) >> 2) + ((C & q_hi_pixel_mask) >> 2) + ((D & q_hi_pixel_mask) >> 2) \
-    + ((((A & q_lo_pixel_mask) + (B & q_lo_pixel_mask) + (C & q_lo_pixel_mask) + (D & q_lo_pixel_mask)) >> 2) & q_lo_pixel_mask)
-
-static void super2xsai(AVFilterContext *ctx,
-                       uint8_t *src, int src_linesize,
-                       uint8_t *dst, int dst_linesize,
-                       int width, int height)
-{
-    Super2xSaIContext *sai = ctx->priv;
-    unsigned int x, y;
-    uint32_t color[4][4];
-    unsigned char *src_line[4];
-    const int bpp = sai->bpp;
-    const uint32_t hi_pixel_mask = sai->hi_pixel_mask;
-    const uint32_t lo_pixel_mask = sai->lo_pixel_mask;
-    const uint32_t q_hi_pixel_mask = sai->q_hi_pixel_mask;
-    const uint32_t q_lo_pixel_mask = sai->q_lo_pixel_mask;
-
-    /* Point to the first 4 lines, first line is duplicated */
-    src_line[0] = src;
-    src_line[1] = src;
-    src_line[2] = src + src_linesize*FFMIN(1, height-1);
-    src_line[3] = src + src_linesize*FFMIN(2, height-1);
-
-#define READ_COLOR4(dst, src_line, off) dst = *((const uint32_t *)src_line + off)
-#define READ_COLOR3(dst, src_line, off) dst = AV_RL24 (src_line + 3*off)
-#define READ_COLOR2(dst, src_line, off) dst = sai->is_be ? AV_RB16(src_line + 2 * off) : AV_RL16(src_line + 2 * off)
-
-    for (y = 0; y < height; y++) {
-        uint8_t *dst_line[2];
-
-        dst_line[0] = dst + dst_linesize*2*y;
-        dst_line[1] = dst + dst_linesize*(2*y+1);
-
-        switch (bpp) {
-        case 4:
-            READ_COLOR4(color[0][0], src_line[0], 0); color[0][1] = color[0][0]; READ_COLOR4(color[0][2], src_line[0], 1); READ_COLOR4(color[0][3], src_line[0], 2);
-            READ_COLOR4(color[1][0], src_line[1], 0); color[1][1] = color[1][0]; READ_COLOR4(color[1][2], src_line[1], 1); READ_COLOR4(color[1][3], src_line[1], 2);
-            READ_COLOR4(color[2][0], src_line[2], 0); color[2][1] = color[2][0]; READ_COLOR4(color[2][2], src_line[2], 1); READ_COLOR4(color[2][3], src_line[2], 2);
-            READ_COLOR4(color[3][0], src_line[3], 0); color[3][1] = color[3][0]; READ_COLOR4(color[3][2], src_line[3], 1); READ_COLOR4(color[3][3], src_line[3], 2);
-            break;
-        case 3:
-            READ_COLOR3(color[0][0], src_line[0], 0); color[0][1] = color[0][0]; READ_COLOR3(color[0][2], src_line[0], 1); READ_COLOR3(color[0][3], src_line[0], 2);
-            READ_COLOR3(color[1][0], src_line[1], 0); color[1][1] = color[1][0]; READ_COLOR3(color[1][2], src_line[1], 1); READ_COLOR3(color[1][3], src_line[1], 2);
-            READ_COLOR3(color[2][0], src_line[2], 0); color[2][1] = color[2][0]; READ_COLOR3(color[2][2], src_line[2], 1); READ_COLOR3(color[2][3], src_line[2], 2);
-            READ_COLOR3(color[3][0], src_line[3], 0); color[3][1] = color[3][0]; READ_COLOR3(color[3][2], src_line[3], 1); READ_COLOR3(color[3][3], src_line[3], 2);
-            break;
-        default:
-            READ_COLOR2(color[0][0], src_line[0], 0); color[0][1] = color[0][0]; READ_COLOR2(color[0][2], src_line[0], 1); READ_COLOR2(color[0][3], src_line[0], 2);
-            READ_COLOR2(color[1][0], src_line[1], 0); color[1][1] = color[1][0]; READ_COLOR2(color[1][2], src_line[1], 1); READ_COLOR2(color[1][3], src_line[1], 2);
-            READ_COLOR2(color[2][0], src_line[2], 0); color[2][1] = color[2][0]; READ_COLOR2(color[2][2], src_line[2], 1); READ_COLOR2(color[2][3], src_line[2], 2);
-            READ_COLOR2(color[3][0], src_line[3], 0); color[3][1] = color[3][0]; READ_COLOR2(color[3][2], src_line[3], 1); READ_COLOR2(color[3][3], src_line[3], 2);
-        }
-
-        for (x = 0; x < width; x++) {
-            uint32_t product1a, product1b, product2a, product2b;
-
-//---------------------------------------  B0 B1 B2 B3    0  1  2  3
-//                                         4  5* 6  S2 -> 4  5* 6  7
-//                                         1  2  3  S1    8  9 10 11
-//                                         A0 A1 A2 A3   12 13 14 15
-//--------------------------------------
-            if (color[2][1] == color[1][2] && color[1][1] != color[2][2]) {
-                product2b = color[2][1];
-                product1b = product2b;
-            } else if (color[1][1] == color[2][2] && color[2][1] != color[1][2]) {
-                product2b = color[1][1];
-                product1b = product2b;
-            } else if (color[1][1] == color[2][2] && color[2][1] == color[1][2]) {
-                int r = 0;
-
-                r += GET_RESULT(color[1][2], color[1][1], color[1][0], color[3][1]);
-                r += GET_RESULT(color[1][2], color[1][1], color[2][0], color[0][1]);
-                r += GET_RESULT(color[1][2], color[1][1], color[3][2], color[2][3]);
-                r += GET_RESULT(color[1][2], color[1][1], color[0][2], color[1][3]);
-
-                if (r > 0)
-                    product1b = color[1][2];
-                else if (r < 0)
-                    product1b = color[1][1];
-                else
-                    product1b = INTERPOLATE(color[1][1], color[1][2]);
-
-                product2b = product1b;
-            } else {
-                if (color[1][2] == color[2][2] && color[2][2] == color[3][1] && color[2][1] != color[3][2] && color[2][2] != color[3][0])
-                    product2b = Q_INTERPOLATE(color[2][2], color[2][2], color[2][2], color[2][1]);
-                else if (color[1][1] == color[2][1] && color[2][1] == color[3][2] && color[3][1] != color[2][2] && color[2][1] != color[3][3])
-                    product2b = Q_INTERPOLATE(color[2][1], color[2][1], color[2][1], color[2][2]);
-                else
-                    product2b = INTERPOLATE(color[2][1], color[2][2]);
-
-                if (color[1][2] == color[2][2] && color[1][2] == color[0][1] && color[1][1] != color[0][2] && color[1][2] != color[0][0])
-                    product1b = Q_INTERPOLATE(color[1][2], color[1][2], color[1][2], color[1][1]);
-                else if (color[1][1] == color[2][1] && color[1][1] == color[0][2] && color[0][1] != color[1][2] && color[1][1] != color[0][3])
-                    product1b = Q_INTERPOLATE(color[1][2], color[1][1], color[1][1], color[1][1]);
-                else
-                    product1b = INTERPOLATE(color[1][1], color[1][2]);
-            }
-
-            if (color[1][1] == color[2][2] && color[2][1] != color[1][2] && color[1][0] == color[1][1] && color[1][1] != color[3][2])
-                product2a = INTERPOLATE(color[2][1], color[1][1]);
-            else if (color[1][1] == color[2][0] && color[1][2] == color[1][1] && color[1][0] != color[2][1] && color[1][1] != color[3][0])
-                product2a = INTERPOLATE(color[2][1], color[1][1]);
-            else
-                product2a = color[2][1];
-
-            if (color[2][1] == color[1][2] && color[1][1] != color[2][2] && color[2][0] == color[2][1] && color[2][1] != color[0][2])
-                product1a = INTERPOLATE(color[2][1], color[1][1]);
-            else if (color[1][0] == color[2][1] && color[2][2] == color[2][1] && color[2][0] != color[1][1] && color[2][1] != color[0][0])
-                product1a = INTERPOLATE(color[2][1], color[1][1]);
-            else
-                product1a = color[1][1];
-
-            /* Set the calculated pixels */
-            switch (bpp) {
-            case 4:
-                AV_WN32A(dst_line[0] + x * 8,     product1a);
-                AV_WN32A(dst_line[0] + x * 8 + 4, product1b);
-                AV_WN32A(dst_line[1] + x * 8,     product2a);
-                AV_WN32A(dst_line[1] + x * 8 + 4, product2b);
-                break;
-            case 3:
-                AV_WL24(dst_line[0] + x * 6,     product1a);
-                AV_WL24(dst_line[0] + x * 6 + 3, product1b);
-                AV_WL24(dst_line[1] + x * 6,     product2a);
-                AV_WL24(dst_line[1] + x * 6 + 3, product2b);
-                break;
-            default: // bpp = 2
-                if (sai->is_be) {
-                    AV_WB32(dst_line[0] + x * 4, product1a | (product1b << 16));
-                    AV_WB32(dst_line[1] + x * 4, product2a | (product2b << 16));
-                } else {
-                    AV_WL32(dst_line[0] + x * 4, product1a | (product1b << 16));
-                    AV_WL32(dst_line[1] + x * 4, product2a | (product2b << 16));
-                }
-            }
-
-            /* Move color matrix forward */
-            color[0][0] = color[0][1]; color[0][1] = color[0][2]; color[0][2] = color[0][3];
-            color[1][0] = color[1][1]; color[1][1] = color[1][2]; color[1][2] = color[1][3];
-            color[2][0] = color[2][1]; color[2][1] = color[2][2]; color[2][2] = color[2][3];
-            color[3][0] = color[3][1]; color[3][1] = color[3][2]; color[3][2] = color[3][3];
-
-            if (x < width - 3) {
-                x += 3;
-                switch (bpp) {
-                case 4:
-                    READ_COLOR4(color[0][3], src_line[0], x);
-                    READ_COLOR4(color[1][3], src_line[1], x);
-                    READ_COLOR4(color[2][3], src_line[2], x);
-                    READ_COLOR4(color[3][3], src_line[3], x);
-                    break;
-                case 3:
-                    READ_COLOR3(color[0][3], src_line[0], x);
-                    READ_COLOR3(color[1][3], src_line[1], x);
-                    READ_COLOR3(color[2][3], src_line[2], x);
-                    READ_COLOR3(color[3][3], src_line[3], x);
-                    break;
-                default:        /* case 2 */
-                    READ_COLOR2(color[0][3], src_line[0], x);
-                    READ_COLOR2(color[1][3], src_line[1], x);
-                    READ_COLOR2(color[2][3], src_line[2], x);
-                    READ_COLOR2(color[3][3], src_line[3], x);
-                }
-                x -= 3;
-            }
-        }
-
-        /* We're done with one line, so we shift the source lines up */
-        src_line[0] = src_line[1];
-        src_line[1] = src_line[2];
-        src_line[2] = src_line[3];
-
-        /* Read next line */
-        src_line[3] = src_line[2];
-        if (y < height - 3)
-            src_line[3] += src_linesize;
-    } // y loop
-}
-
-static int query_formats(AVFilterContext *ctx)
-{
-    static const enum AVPixelFormat pix_fmts[] = {
-        AV_PIX_FMT_RGBA, AV_PIX_FMT_BGRA, AV_PIX_FMT_ARGB, AV_PIX_FMT_ABGR,
-        AV_PIX_FMT_RGB24, AV_PIX_FMT_BGR24,
-        AV_PIX_FMT_RGB565BE, AV_PIX_FMT_BGR565BE, AV_PIX_FMT_RGB555BE, AV_PIX_FMT_BGR555BE,
-        AV_PIX_FMT_RGB565LE, AV_PIX_FMT_BGR565LE, AV_PIX_FMT_RGB555LE, AV_PIX_FMT_BGR555LE,
-        AV_PIX_FMT_NONE
-    };
-
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-    return 0;
-}
-
-static int config_input(AVFilterLink *inlink)
-{
-    Super2xSaIContext *sai = inlink->dst->priv;
-
-    sai->hi_pixel_mask   = 0xFEFEFEFE;
-    sai->lo_pixel_mask   = 0x01010101;
-    sai->q_hi_pixel_mask = 0xFCFCFCFC;
-    sai->q_lo_pixel_mask = 0x03030303;
-    sai->bpp  = 4;
-
-    switch (inlink->format) {
-    case AV_PIX_FMT_RGB24:
-    case AV_PIX_FMT_BGR24:
-        sai->bpp = 3;
-        break;
-
-    case AV_PIX_FMT_RGB565BE:
-    case AV_PIX_FMT_BGR565BE:
-        sai->is_be = 1;
-    case AV_PIX_FMT_RGB565LE:
-    case AV_PIX_FMT_BGR565LE:
-        sai->hi_pixel_mask   = 0xF7DEF7DE;
-        sai->lo_pixel_mask   = 0x08210821;
-        sai->q_hi_pixel_mask = 0xE79CE79C;
-        sai->q_lo_pixel_mask = 0x18631863;
-        sai->bpp = 2;
-        break;
-
-    case AV_PIX_FMT_BGR555BE:
-    case AV_PIX_FMT_RGB555BE:
-        sai->is_be = 1;
-    case AV_PIX_FMT_BGR555LE:
-    case AV_PIX_FMT_RGB555LE:
-        sai->hi_pixel_mask   = 0x7BDE7BDE;
-        sai->lo_pixel_mask   = 0x04210421;
-        sai->q_hi_pixel_mask = 0x739C739C;
-        sai->q_lo_pixel_mask = 0x0C630C63;
-        sai->bpp = 2;
-        break;
-    }
-
-    return 0;
-}
-
-static int config_output(AVFilterLink *outlink)
-{
-    AVFilterLink *inlink = outlink->src->inputs[0];
-
-    outlink->w = inlink->w*2;
-    outlink->h = inlink->h*2;
-
-    av_log(inlink->dst, AV_LOG_VERBOSE, "fmt:%s size:%dx%d -> size:%dx%d\n",
-           av_get_pix_fmt_name(inlink->format),
-           inlink->w, inlink->h, outlink->w, outlink->h);
-
-    return 0;
-}
-
-static int filter_frame(AVFilterLink *inlink, AVFrame *inpicref)
-{
-    AVFilterLink *outlink = inlink->dst->outputs[0];
-    AVFrame *outpicref = ff_get_video_buffer(outlink, outlink->w, outlink->h);
-    if (!outpicref) {
-        av_frame_free(&inpicref);
-        return AVERROR(ENOMEM);
-    }
-    av_frame_copy_props(outpicref, inpicref);
-    outpicref->width  = outlink->w;
-    outpicref->height = outlink->h;
-
-    super2xsai(inlink->dst, inpicref->data[0], inpicref->linesize[0],
-               outpicref->data[0], outpicref->linesize[0],
-               inlink->w, inlink->h);
-
-    av_frame_free(&inpicref);
-    return ff_filter_frame(outlink, outpicref);
-}
-
-static const AVFilterPad super2xsai_inputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .config_props = config_input,
-        .filter_frame = filter_frame,
-    },
-    { NULL }
-};
-
-static const AVFilterPad super2xsai_outputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .config_props = config_output,
-    },
-    { NULL }
-};
-
-AVFilter ff_vf_super2xsai = {
-    .name          = "super2xsai",
-    .description   = NULL_IF_CONFIG_SMALL("Scale the input by 2x using the Super2xSaI pixel art algorithm."),
-    .priv_size     = sizeof(Super2xSaIContext),
-    .query_formats = query_formats,
-    .inputs        = super2xsai_inputs,
-    .outputs       = super2xsai_outputs,
-};
diff --git a/libavfilter/vf_tinterlace.c b/libavfilter/vf_tinterlace.c
deleted file mode 100644
index db82393..0000000
--- a/libavfilter/vf_tinterlace.c
+++ /dev/null
@@ -1,386 +0,0 @@
-/*
- * Copyright (c) 2011 Stefano Sabatini
- * Copyright (c) 2010 Baptiste Coudurier
- * Copyright (c) 2003 Michael Zucchi <notzed@ximian.com>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with FFmpeg if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-/**
- * @file
- * temporal field interlace filter, ported from MPlayer/libmpcodecs
- */
-
-#include "libavutil/opt.h"
-#include "libavutil/imgutils.h"
-#include "libavutil/avassert.h"
-#include "avfilter.h"
-#include "internal.h"
-
-enum TInterlaceMode {
-    MODE_MERGE = 0,
-    MODE_DROP_EVEN,
-    MODE_DROP_ODD,
-    MODE_PAD,
-    MODE_INTERLEAVE_TOP,
-    MODE_INTERLEAVE_BOTTOM,
-    MODE_INTERLACEX2,
-    MODE_NB,
-};
-
-typedef struct {
-    const AVClass *class;
-    enum TInterlaceMode mode;   ///< interlace mode selected
-    int flags;                  ///< flags affecting interlacing algorithm
-    int frame;                  ///< number of the output frame
-    int vsub;                   ///< chroma vertical subsampling
-    AVFrame *cur;
-    AVFrame *next;
-    uint8_t *black_data[4];     ///< buffer used to fill padded lines
-    int black_linesize[4];
-} TInterlaceContext;
-
-#define OFFSET(x) offsetof(TInterlaceContext, x)
-#define FLAGS AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM
-#define TINTERLACE_FLAG_VLPF 01
-
-static const AVOption tinterlace_options[] = {
-    {"mode",              "select interlace mode", OFFSET(mode), AV_OPT_TYPE_INT, {.i64=MODE_MERGE}, 0, MODE_NB-1, FLAGS, "mode"},
-    {"merge",             "merge fields",                                 0, AV_OPT_TYPE_CONST, {.i64=MODE_MERGE},             INT_MIN, INT_MAX, FLAGS, "mode"},
-    {"drop_even",         "drop even fields",                             0, AV_OPT_TYPE_CONST, {.i64=MODE_DROP_EVEN},         INT_MIN, INT_MAX, FLAGS, "mode"},
-    {"drop_odd",          "drop odd fields",                              0, AV_OPT_TYPE_CONST, {.i64=MODE_DROP_ODD},          INT_MIN, INT_MAX, FLAGS, "mode"},
-    {"pad",               "pad alternate lines with black",               0, AV_OPT_TYPE_CONST, {.i64=MODE_PAD},               INT_MIN, INT_MAX, FLAGS, "mode"},
-    {"interleave_top",    "interleave top and bottom fields",             0, AV_OPT_TYPE_CONST, {.i64=MODE_INTERLEAVE_TOP},    INT_MIN, INT_MAX, FLAGS, "mode"},
-    {"interleave_bottom", "interleave bottom and top fields",             0, AV_OPT_TYPE_CONST, {.i64=MODE_INTERLEAVE_BOTTOM}, INT_MIN, INT_MAX, FLAGS, "mode"},
-    {"interlacex2",       "interlace fields from two consecutive frames", 0, AV_OPT_TYPE_CONST, {.i64=MODE_INTERLACEX2},       INT_MIN, INT_MAX, FLAGS, "mode"},
-
-    {"flags",             "set flags", OFFSET(flags), AV_OPT_TYPE_FLAGS, {.i64 = 0}, 0, INT_MAX, 0, "flags" },
-    {"low_pass_filter",   "enable vertical low-pass filter",              0, AV_OPT_TYPE_CONST, {.i64 = TINTERLACE_FLAG_VLPF}, INT_MIN, INT_MAX, FLAGS, "flags" },
-    {"vlpf",              "enable vertical low-pass filter",              0, AV_OPT_TYPE_CONST, {.i64 = TINTERLACE_FLAG_VLPF}, INT_MIN, INT_MAX, FLAGS, "flags" },
-
-    {NULL}
-};
-
-AVFILTER_DEFINE_CLASS(tinterlace);
-
-#define FULL_SCALE_YUVJ_FORMATS \
-    AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUVJ440P
-
-static enum AVPixelFormat full_scale_yuvj_pix_fmts[] = {
-    FULL_SCALE_YUVJ_FORMATS, AV_PIX_FMT_NONE
-};
-
-static int query_formats(AVFilterContext *ctx)
-{
-    static const enum AVPixelFormat pix_fmts[] = {
-        AV_PIX_FMT_YUV410P, AV_PIX_FMT_YUV411P,
-        AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P,
-        AV_PIX_FMT_YUV440P, AV_PIX_FMT_YUV444P,
-        AV_PIX_FMT_YUVA420P, AV_PIX_FMT_YUVA422P, AV_PIX_FMT_YUVA444P,
-        AV_PIX_FMT_GRAY8, FULL_SCALE_YUVJ_FORMATS,
-        AV_PIX_FMT_NONE
-    };
-
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-    return 0;
-}
-
-static av_cold void uninit(AVFilterContext *ctx)
-{
-    TInterlaceContext *tinterlace = ctx->priv;
-
-    av_frame_free(&tinterlace->cur );
-    av_frame_free(&tinterlace->next);
-    av_freep(&tinterlace->black_data[0]);
-}
-
-static int config_out_props(AVFilterLink *outlink)
-{
-    AVFilterContext *ctx = outlink->src;
-    AVFilterLink *inlink = outlink->src->inputs[0];
-    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(outlink->format);
-    TInterlaceContext *tinterlace = ctx->priv;
-
-    tinterlace->vsub = desc->log2_chroma_h;
-    outlink->flags |= FF_LINK_FLAG_REQUEST_LOOP;
-    outlink->w = inlink->w;
-    outlink->h = tinterlace->mode == MODE_MERGE || tinterlace->mode == MODE_PAD ?
-        inlink->h*2 : inlink->h;
-
-    if (tinterlace->mode == MODE_PAD) {
-        uint8_t black[4] = { 16, 128, 128, 16 };
-        int i, ret;
-        if (ff_fmt_is_in(outlink->format, full_scale_yuvj_pix_fmts))
-            black[0] = black[3] = 0;
-        ret = av_image_alloc(tinterlace->black_data, tinterlace->black_linesize,
-                             outlink->w, outlink->h, outlink->format, 1);
-        if (ret < 0)
-            return ret;
-
-        /* fill black picture with black */
-        for (i = 0; i < 4 && tinterlace->black_data[i]; i++) {
-            int h = i == 1 || i == 2 ? FF_CEIL_RSHIFT(outlink->h, desc->log2_chroma_h) : outlink->h;
-            memset(tinterlace->black_data[i], black[i],
-                   tinterlace->black_linesize[i] * h);
-        }
-    }
-    if ((tinterlace->flags & TINTERLACE_FLAG_VLPF)
-            && !(tinterlace->mode == MODE_INTERLEAVE_TOP
-              || tinterlace->mode == MODE_INTERLEAVE_BOTTOM)) {
-        av_log(ctx, AV_LOG_WARNING, "low_pass_filter flag ignored with mode %d\n",
-                tinterlace->mode);
-        tinterlace->flags &= ~TINTERLACE_FLAG_VLPF;
-    }
-    av_log(ctx, AV_LOG_VERBOSE, "mode:%d filter:%s h:%d -> h:%d\n",
-           tinterlace->mode, (tinterlace->flags & TINTERLACE_FLAG_VLPF) ? "on" : "off",
-           inlink->h, outlink->h);
-
-    return 0;
-}
-
-#define FIELD_UPPER           0
-#define FIELD_LOWER           1
-#define FIELD_UPPER_AND_LOWER 2
-
-/**
- * Copy picture field from src to dst.
- *
- * @param src_field copy from upper, lower field or both
- * @param interleave leave a padding line between each copied line
- * @param dst_field copy to upper or lower field,
- *        only meaningful when interleave is selected
- * @param flags context flags
- */
-static inline
-void copy_picture_field(uint8_t *dst[4], int dst_linesize[4],
-                        const uint8_t *src[4], int src_linesize[4],
-                        enum AVPixelFormat format, int w, int src_h,
-                        int src_field, int interleave, int dst_field,
-                        int flags)
-{
-    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(format);
-    int plane, vsub = desc->log2_chroma_h;
-    int k = src_field == FIELD_UPPER_AND_LOWER ? 1 : 2;
-    int h, i;
-
-    for (plane = 0; plane < desc->nb_components; plane++) {
-        int lines = plane == 1 || plane == 2 ? FF_CEIL_RSHIFT(src_h, vsub) : src_h;
-        int linesize = av_image_get_linesize(format, w, plane);
-        uint8_t *dstp = dst[plane];
-        const uint8_t *srcp = src[plane];
-
-        if (linesize < 0)
-            return;
-
-        lines = (lines + (src_field == FIELD_UPPER)) / k;
-        if (src_field == FIELD_LOWER)
-            srcp += src_linesize[plane];
-        if (interleave && dst_field == FIELD_LOWER)
-            dstp += dst_linesize[plane];
-        if (flags & TINTERLACE_FLAG_VLPF) {
-            // Low-pass filtering is required when creating an interlaced destination from
-            // a progressive source which contains high-frequency vertical detail.
-            // Filtering will reduce interlace 'twitter' and Moire patterning.
-            int srcp_linesize = src_linesize[plane] * k;
-            int dstp_linesize = dst_linesize[plane] * (interleave ? 2 : 1);
-            for (h = lines; h > 0; h--) {
-                const uint8_t *srcp_above = srcp - src_linesize[plane];
-                const uint8_t *srcp_below = srcp + src_linesize[plane];
-                if (h == lines) srcp_above = srcp; // there is no line above
-                if (h == 1) srcp_below = srcp;     // there is no line below
-                for (i = 0; i < linesize; i++) {
-                    // this calculation is an integer representation of
-                    // '0.5 * current + 0.25 * above + 0.25 * below'
-                    // '1 +' is for rounding. */
-                    dstp[i] = (1 + srcp[i] + srcp[i] + srcp_above[i] + srcp_below[i]) >> 2;
-                }
-                dstp += dstp_linesize;
-                srcp += srcp_linesize;
-            }
-        } else {
-            av_image_copy_plane(dstp, dst_linesize[plane] * (interleave ? 2 : 1),
-                            srcp, src_linesize[plane]*k, linesize, lines);
-        }
-    }
-}
-
-static int filter_frame(AVFilterLink *inlink, AVFrame *picref)
-{
-    AVFilterContext *ctx = inlink->dst;
-    AVFilterLink *outlink = ctx->outputs[0];
-    TInterlaceContext *tinterlace = ctx->priv;
-    AVFrame *cur, *next, *out;
-    int field, tff, ret;
-
-    av_frame_free(&tinterlace->cur);
-    tinterlace->cur  = tinterlace->next;
-    tinterlace->next = picref;
-
-    cur = tinterlace->cur;
-    next = tinterlace->next;
-    /* we need at least two frames */
-    if (!tinterlace->cur)
-        return 0;
-
-    switch (tinterlace->mode) {
-    case MODE_MERGE: /* move the odd frame into the upper field of the new image, even into
-             * the lower field, generating a double-height video at half framerate */
-        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
-        if (!out)
-            return AVERROR(ENOMEM);
-        av_frame_copy_props(out, cur);
-        out->height = outlink->h;
-        out->interlaced_frame = 1;
-        out->top_field_first = 1;
-
-        /* write odd frame lines into the upper field of the new frame */
-        copy_picture_field(out->data, out->linesize,
-                           (const uint8_t **)cur->data, cur->linesize,
-                           inlink->format, inlink->w, inlink->h,
-                           FIELD_UPPER_AND_LOWER, 1, FIELD_UPPER, tinterlace->flags);
-        /* write even frame lines into the lower field of the new frame */
-        copy_picture_field(out->data, out->linesize,
-                           (const uint8_t **)next->data, next->linesize,
-                           inlink->format, inlink->w, inlink->h,
-                           FIELD_UPPER_AND_LOWER, 1, FIELD_LOWER, tinterlace->flags);
-        av_frame_free(&tinterlace->next);
-        break;
-
-    case MODE_DROP_ODD:  /* only output even frames, odd  frames are dropped; height unchanged, half framerate */
-    case MODE_DROP_EVEN: /* only output odd  frames, even frames are dropped; height unchanged, half framerate */
-        out = av_frame_clone(tinterlace->mode == MODE_DROP_EVEN ? cur : next);
-        if (!out)
-            return AVERROR(ENOMEM);
-        av_frame_free(&tinterlace->next);
-        break;
-
-    case MODE_PAD: /* expand each frame to double height, but pad alternate
-                    * lines with black; framerate unchanged */
-        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
-        if (!out)
-            return AVERROR(ENOMEM);
-        av_frame_copy_props(out, cur);
-        out->height = outlink->h;
-
-        field = (1 + tinterlace->frame) & 1 ? FIELD_UPPER : FIELD_LOWER;
-        /* copy upper and lower fields */
-        copy_picture_field(out->data, out->linesize,
-                           (const uint8_t **)cur->data, cur->linesize,
-                           inlink->format, inlink->w, inlink->h,
-                           FIELD_UPPER_AND_LOWER, 1, field, tinterlace->flags);
-        /* pad with black the other field */
-        copy_picture_field(out->data, out->linesize,
-                           (const uint8_t **)tinterlace->black_data, tinterlace->black_linesize,
-                           inlink->format, inlink->w, inlink->h,
-                           FIELD_UPPER_AND_LOWER, 1, !field, tinterlace->flags);
-        break;
-
-        /* interleave upper/lower lines from odd frames with lower/upper lines from even frames,
-         * halving the frame rate and preserving image height */
-    case MODE_INTERLEAVE_TOP:    /* top    field first */
-    case MODE_INTERLEAVE_BOTTOM: /* bottom field first */
-        tff = tinterlace->mode == MODE_INTERLEAVE_TOP;
-        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
-        if (!out)
-            return AVERROR(ENOMEM);
-        av_frame_copy_props(out, cur);
-        out->interlaced_frame = 1;
-        out->top_field_first = tff;
-
-        /* copy upper/lower field from cur */
-        copy_picture_field(out->data, out->linesize,
-                           (const uint8_t **)cur->data, cur->linesize,
-                           inlink->format, inlink->w, inlink->h,
-                           tff ? FIELD_UPPER : FIELD_LOWER, 1, tff ? FIELD_UPPER : FIELD_LOWER,
-                           tinterlace->flags);
-        /* copy lower/upper field from next */
-        copy_picture_field(out->data, out->linesize,
-                           (const uint8_t **)next->data, next->linesize,
-                           inlink->format, inlink->w, inlink->h,
-                           tff ? FIELD_LOWER : FIELD_UPPER, 1, tff ? FIELD_LOWER : FIELD_UPPER,
-                           tinterlace->flags);
-        av_frame_free(&tinterlace->next);
-        break;
-    case MODE_INTERLACEX2: /* re-interlace preserving image height, double frame rate */
-        /* output current frame first */
-        out = av_frame_clone(cur);
-        if (!out)
-            return AVERROR(ENOMEM);
-        out->interlaced_frame = 1;
-
-        if ((ret = ff_filter_frame(outlink, out)) < 0)
-            return ret;
-
-        /* output mix of current and next frame */
-        tff = next->top_field_first;
-        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
-        if (!out)
-            return AVERROR(ENOMEM);
-        av_frame_copy_props(out, next);
-        out->interlaced_frame = 1;
-
-        /* write current frame second field lines into the second field of the new frame */
-        copy_picture_field(out->data, out->linesize,
-                           (const uint8_t **)cur->data, cur->linesize,
-                           inlink->format, inlink->w, inlink->h,
-                           tff ? FIELD_LOWER : FIELD_UPPER, 1, tff ? FIELD_LOWER : FIELD_UPPER,
-                           tinterlace->flags);
-        /* write next frame first field lines into the first field of the new frame */
-        copy_picture_field(out->data, out->linesize,
-                           (const uint8_t **)next->data, next->linesize,
-                           inlink->format, inlink->w, inlink->h,
-                           tff ? FIELD_UPPER : FIELD_LOWER, 1, tff ? FIELD_UPPER : FIELD_LOWER,
-                           tinterlace->flags);
-        break;
-    default:
-        av_assert0(0);
-    }
-
-    ret = ff_filter_frame(outlink, out);
-    tinterlace->frame++;
-
-    return ret;
-}
-
-static const AVFilterPad tinterlace_inputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .filter_frame = filter_frame,
-    },
-    { NULL }
-};
-
-static const AVFilterPad tinterlace_outputs[] = {
-    {
-        .name         = "default",
-        .type         = AVMEDIA_TYPE_VIDEO,
-        .config_props = config_out_props,
-    },
-    { NULL }
-};
-
-AVFilter ff_vf_tinterlace = {
-    .name          = "tinterlace",
-    .description   = NULL_IF_CONFIG_SMALL("Perform temporal field interlacing."),
-    .priv_size     = sizeof(TInterlaceContext),
-    .uninit        = uninit,
-    .query_formats = query_formats,
-    .inputs        = tinterlace_inputs,
-    .outputs       = tinterlace_outputs,
-    .priv_class    = &tinterlace_class,
-};
diff --git a/libavfilter/vsrc_mptestsrc.c b/libavfilter/vsrc_mptestsrc.c
deleted file mode 100644
index d045704..0000000
--- a/libavfilter/vsrc_mptestsrc.c
+++ /dev/null
@@ -1,361 +0,0 @@
-/*
- * Copyright (c) 2002 Michael Niedermayer <michaelni@gmx.at>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with FFmpeg; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-/**
- * @file
- * MP test source, ported from MPlayer libmpcodecs/vf_test.c
- */
-
-#include "libavutil/avstring.h"
-#include "libavutil/opt.h"
-#include "libavutil/parseutils.h"
-#include "libavutil/pixdesc.h"
-#include "avfilter.h"
-#include "internal.h"
-#include "formats.h"
-#include "video.h"
-
-#define WIDTH 512
-#define HEIGHT 512
-
-enum test_type {
-    TEST_DC_LUMA,
-    TEST_DC_CHROMA,
-    TEST_FREQ_LUMA,
-    TEST_FREQ_CHROMA,
-    TEST_AMP_LUMA,
-    TEST_AMP_CHROMA,
-    TEST_CBP,
-    TEST_MV,
-    TEST_RING1,
-    TEST_RING2,
-    TEST_ALL,
-    TEST_NB
-};
-
-typedef struct MPTestContext {
-    const AVClass *class;
-    AVRational frame_rate;
-    int64_t pts, max_pts, duration;
-    int hsub, vsub;
-    enum test_type test;
-} MPTestContext;
-
-#define OFFSET(x) offsetof(MPTestContext, x)
-#define FLAGS AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM
-static const AVOption mptestsrc_options[]= {
-    { "rate",     "set video rate",     OFFSET(frame_rate), AV_OPT_TYPE_VIDEO_RATE, {.str = "25"}, 0, 0, FLAGS },
-    { "r",        "set video rate",     OFFSET(frame_rate), AV_OPT_TYPE_VIDEO_RATE, {.str = "25"}, 0, 0, FLAGS },
-    { "duration", "set video duration", OFFSET(duration), AV_OPT_TYPE_DURATION, {.i64 = -1}, -1, INT64_MAX, FLAGS },
-    { "d",        "set video duration", OFFSET(duration), AV_OPT_TYPE_DURATION, {.i64 = -1}, -1, INT64_MAX, FLAGS },
-
-    { "test", "set test to perform", OFFSET(test),  AV_OPT_TYPE_INT,   {.i64=TEST_ALL}, 0, INT_MAX, FLAGS, "test" },
-    { "t",    "set test to perform", OFFSET(test),  AV_OPT_TYPE_INT,   {.i64=TEST_ALL}, 0, INT_MAX, FLAGS, "test" },
-        { "dc_luma",     "", 0, AV_OPT_TYPE_CONST, {.i64=TEST_DC_LUMA},     INT_MIN, INT_MAX, FLAGS, "test" },
-        { "dc_chroma",   "", 0, AV_OPT_TYPE_CONST, {.i64=TEST_DC_CHROMA},   INT_MIN, INT_MAX, FLAGS, "test" },
-        { "freq_luma",   "", 0, AV_OPT_TYPE_CONST, {.i64=TEST_FREQ_LUMA},   INT_MIN, INT_MAX, FLAGS, "test" },
-        { "freq_chroma", "", 0, AV_OPT_TYPE_CONST, {.i64=TEST_FREQ_CHROMA}, INT_MIN, INT_MAX, FLAGS, "test" },
-        { "amp_luma",    "", 0, AV_OPT_TYPE_CONST, {.i64=TEST_AMP_LUMA},    INT_MIN, INT_MAX, FLAGS, "test" },
-        { "amp_chroma",  "", 0, AV_OPT_TYPE_CONST, {.i64=TEST_AMP_CHROMA},  INT_MIN, INT_MAX, FLAGS, "test" },
-        { "cbp",         "", 0, AV_OPT_TYPE_CONST, {.i64=TEST_CBP},         INT_MIN, INT_MAX, FLAGS, "test" },
-        { "mv",          "", 0, AV_OPT_TYPE_CONST, {.i64=TEST_MV},          INT_MIN, INT_MAX, FLAGS, "test" },
-        { "ring1",       "", 0, AV_OPT_TYPE_CONST, {.i64=TEST_RING1},       INT_MIN, INT_MAX, FLAGS, "test" },
-        { "ring2",       "", 0, AV_OPT_TYPE_CONST, {.i64=TEST_RING2},       INT_MIN, INT_MAX, FLAGS, "test" },
-        { "all",         "", 0, AV_OPT_TYPE_CONST, {.i64=TEST_ALL},         INT_MIN, INT_MAX, FLAGS, "test" },
-    { NULL }
-};
-
-AVFILTER_DEFINE_CLASS(mptestsrc);
-
-static double c[64];
-
-static void init_idct(void)
-{
-    int i, j;
-
-    for (i = 0; i < 8; i++) {
-        double s = i == 0 ? sqrt(0.125) : 0.5;
-
-        for (j = 0; j < 8; j++)
-            c[i*8+j] = s*cos((M_PI/8.0)*i*(j+0.5));
-    }
-}
-
-static void idct(uint8_t *dst, int dst_linesize, int src[64])
-{
-    int i, j, k;
-    double tmp[64];
-
-    for (i = 0; i < 8; i++) {
-        for (j = 0; j < 8; j++) {
-            double sum = 0.0;
-
-            for (k = 0; k < 8; k++)
-                sum += c[k*8+j] * src[8*i+k];
-
-            tmp[8*i+j] = sum;
-        }
-    }
-
-    for (j = 0; j < 8; j++) {
-        for (i = 0; i < 8; i++) {
-            double sum = 0.0;
-
-            for (k = 0; k < 8; k++)
-                sum += c[k*8+i]*tmp[8*k+j];
-
-            dst[dst_linesize*i + j] = av_clip((int)floor(sum+0.5), 0, 255);
-        }
-    }
-}
-
-static void draw_dc(uint8_t *dst, int dst_linesize, int color, int w, int h)
-{
-    int x, y;
-
-    for (y = 0; y < h; y++)
-        for (x = 0; x < w; x++)
-            dst[x + y*dst_linesize] = color;
-}
-
-static void draw_basis(uint8_t *dst, int dst_linesize, int amp, int freq, int dc)
-{
-    int src[64];
-
-    memset(src, 0, 64*sizeof(int));
-    src[0] = dc;
-    if (amp)
-        src[freq] = amp;
-    idct(dst, dst_linesize, src);
-}
-
-static void draw_cbp(uint8_t *dst[3], int dst_linesize[3], int cbp, int amp, int dc)
-{
-    if (cbp&1)  draw_basis(dst[0]                    , dst_linesize[0], amp, 1, dc);
-    if (cbp&2)  draw_basis(dst[0]+8                  , dst_linesize[0], amp, 1, dc);
-    if (cbp&4)  draw_basis(dst[0]+  8*dst_linesize[0], dst_linesize[0], amp, 1, dc);
-    if (cbp&8)  draw_basis(dst[0]+8+8*dst_linesize[0], dst_linesize[0], amp, 1, dc);
-    if (cbp&16) draw_basis(dst[1]                    , dst_linesize[1], amp, 1, dc);
-    if (cbp&32) draw_basis(dst[2]                    , dst_linesize[2], amp, 1, dc);
-}
-
-static void dc_test(uint8_t *dst, int dst_linesize, int w, int h, int off)
-{
-    const int step = FFMAX(256/(w*h/256), 1);
-    int x, y, color = off;
-
-    for (y = 0; y < h; y += 16) {
-        for (x = 0; x < w; x += 16) {
-            draw_dc(dst + x + y*dst_linesize, dst_linesize, color, 8, 8);
-            color += step;
-        }
-    }
-}
-
-static void freq_test(uint8_t *dst, int dst_linesize, int off)
-{
-    int x, y, freq = 0;
-
-    for (y = 0; y < 8*16; y += 16) {
-        for (x = 0; x < 8*16; x += 16) {
-            draw_basis(dst + x + y*dst_linesize, dst_linesize, 4*(96+off), freq, 128*8);
-            freq++;
-        }
-    }
-}
-
-static void amp_test(uint8_t *dst, int dst_linesize, int off)
-{
-    int x, y, amp = off;
-
-    for (y = 0; y < 16*16; y += 16) {
-        for (x = 0; x < 16*16; x += 16) {
-            draw_basis(dst + x + y*dst_linesize, dst_linesize, 4*amp, 1, 128*8);
-            amp++;
-        }
-    }
-}
-
-static void cbp_test(uint8_t *dst[3], int dst_linesize[3], int off)
-{
-    int x, y, cbp = 0;
-
-    for (y = 0; y < 16*8; y += 16) {
-        for (x = 0; x < 16*8; x += 16) {
-            uint8_t *dst1[3];
-            dst1[0] = dst[0] + x*2 + y*2*dst_linesize[0];
-            dst1[1] = dst[1] + x   + y*  dst_linesize[1];
-            dst1[2] = dst[2] + x   + y*  dst_linesize[2];
-
-            draw_cbp(dst1, dst_linesize, cbp, (64+off)*4, 128*8);
-            cbp++;
-        }
-    }
-}
-
-static void mv_test(uint8_t *dst, int dst_linesize, int off)
-{
-    int x, y;
-
-    for (y = 0; y < 16*16; y++) {
-        if (y&16)
-            continue;
-        for (x = 0; x < 16*16; x++)
-            dst[x + y*dst_linesize] = x + off*8/(y/32+1);
-    }
-}
-
-static void ring1_test(uint8_t *dst, int dst_linesize, int off)
-{
-    int x, y, color = 0;
-
-    for (y = off; y < 16*16; y += 16) {
-        for (x = off; x < 16*16; x += 16) {
-            draw_dc(dst + x + y*dst_linesize, dst_linesize, ((x+y)&16) ? color : -color, 16, 16);
-            color++;
-        }
-    }
-}
-
-static void ring2_test(uint8_t *dst, int dst_linesize, int off)
-{
-    int x, y;
-
-    for (y = 0; y < 16*16; y++) {
-        for (x = 0; x < 16*16; x++) {
-            double d = sqrt((x-8*16)*(x-8*16) + (y-8*16)*(y-8*16));
-            double r = d/20 - (int)(d/20);
-            if (r < off/30.0) {
-                dst[x + y*dst_linesize]     = 255;
-                dst[x + y*dst_linesize+256] = 0;
-            } else {
-                dst[x + y*dst_linesize]     = x;
-                dst[x + y*dst_linesize+256] = x;
-            }
-        }
-    }
-}
-
-static av_cold int init(AVFilterContext *ctx)
-{
-    MPTestContext *test = ctx->priv;
-
-    test->max_pts = test->duration >= 0 ?
-        av_rescale_q(test->duration, AV_TIME_BASE_Q, av_inv_q(test->frame_rate)) : -1;
-    test->pts = 0;
-
-    av_log(ctx, AV_LOG_VERBOSE, "rate:%d/%d duration:%f\n",
-           test->frame_rate.num, test->frame_rate.den,
-           test->duration < 0 ? -1 : test->max_pts * av_q2d(av_inv_q(test->frame_rate)));
-    init_idct();
-
-    return 0;
-}
-
-static int config_props(AVFilterLink *outlink)
-{
-    AVFilterContext *ctx = outlink->src;
-    MPTestContext *test = ctx->priv;
-    const AVPixFmtDescriptor *pix_desc = av_pix_fmt_desc_get(outlink->format);
-
-    test->hsub = pix_desc->log2_chroma_w;
-    test->vsub = pix_desc->log2_chroma_h;
-
-    outlink->w = WIDTH;
-    outlink->h = HEIGHT;
-    outlink->time_base = av_inv_q(test->frame_rate);
-
-    return 0;
-}
-
-static int query_formats(AVFilterContext *ctx)
-{
-    static const enum AVPixelFormat pix_fmts[] = {
-        AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE
-    };
-
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-    return 0;
-}
-
-static int request_frame(AVFilterLink *outlink)
-{
-    MPTestContext *test = outlink->src->priv;
-    AVFrame *picref;
-    int w = WIDTH, h = HEIGHT,
-        cw = FF_CEIL_RSHIFT(w, test->hsub), ch = FF_CEIL_RSHIFT(h, test->vsub);
-    unsigned int frame = outlink->frame_count;
-    enum test_type tt = test->test;
-    int i;
-
-    if (test->max_pts >= 0 && test->pts > test->max_pts)
-        return AVERROR_EOF;
-    picref = ff_get_video_buffer(outlink, w, h);
-    if (!picref)
-        return AVERROR(ENOMEM);
-    picref->pts = test->pts++;
-
-    // clean image
-    for (i = 0; i < h; i++)
-        memset(picref->data[0] + i*picref->linesize[0], 0, w);
-    for (i = 0; i < ch; i++) {
-        memset(picref->data[1] + i*picref->linesize[1], 128, cw);
-        memset(picref->data[2] + i*picref->linesize[2], 128, cw);
-    }
-
-    if (tt == TEST_ALL && frame%30) /* draw a black frame at the beginning of each test */
-        tt = (frame/30)%(TEST_NB-1);
-
-    switch (tt) {
-    case TEST_DC_LUMA:       dc_test(picref->data[0], picref->linesize[0], 256, 256, frame%30); break;
-    case TEST_DC_CHROMA:     dc_test(picref->data[1], picref->linesize[1], 256, 256, frame%30); break;
-    case TEST_FREQ_LUMA:   freq_test(picref->data[0], picref->linesize[0], frame%30); break;
-    case TEST_FREQ_CHROMA: freq_test(picref->data[1], picref->linesize[1], frame%30); break;
-    case TEST_AMP_LUMA:     amp_test(picref->data[0], picref->linesize[0], frame%30); break;
-    case TEST_AMP_CHROMA:   amp_test(picref->data[1], picref->linesize[1], frame%30); break;
-    case TEST_CBP:          cbp_test(picref->data   , picref->linesize   , frame%30); break;
-    case TEST_MV:            mv_test(picref->data[0], picref->linesize[0], frame%30); break;
-    case TEST_RING1:      ring1_test(picref->data[0], picref->linesize[0], frame%30); break;
-    case TEST_RING2:      ring2_test(picref->data[0], picref->linesize[0], frame%30); break;
-    }
-
-    return ff_filter_frame(outlink, picref);
-}
-
-static const AVFilterPad mptestsrc_outputs[] = {
-    {
-        .name          = "default",
-        .type          = AVMEDIA_TYPE_VIDEO,
-        .request_frame = request_frame,
-        .config_props  = config_props,
-    },
-    { NULL }
-};
-
-AVFilter ff_vsrc_mptestsrc = {
-    .name          = "mptestsrc",
-    .description   = NULL_IF_CONFIG_SMALL("Generate various test pattern."),
-    .priv_size     = sizeof(MPTestContext),
-    .priv_class    = &mptestsrc_class,
-    .init          = init,
-    .query_formats = query_formats,
-    .inputs        = NULL,
-    .outputs       = mptestsrc_outputs,
-};
diff --git a/libpostproc/Makefile b/libpostproc/Makefile
deleted file mode 100644
index b9bb4be..0000000
--- a/libpostproc/Makefile
+++ /dev/null
@@ -1,12 +0,0 @@
-include $(SUBDIR)../config.mak
-
-NAME = postproc
-FFLIBS = avutil
-
-HEADERS = postprocess.h        \
-          version.h            \
-
-OBJS = postprocess.o
-
-# Windows resource file
-SLIBOBJS-$(HAVE_GNU_WINDRES) += postprocres.o
diff --git a/libpostproc/libpostproc.v b/libpostproc/libpostproc.v
deleted file mode 100644
index e65d76f..0000000
--- a/libpostproc/libpostproc.v
+++ /dev/null
@@ -1,4 +0,0 @@
-LIBPOSTPROC_$MAJOR {
-        global: postproc_*; pp_*;
-        local: *;
-};
diff --git a/libpostproc/postprocess.c b/libpostproc/postprocess.c
deleted file mode 100644
index da586ff..0000000
--- a/libpostproc/postprocess.c
+++ /dev/null
@@ -1,1049 +0,0 @@
-/*
- * Copyright (C) 2001-2003 Michael Niedermayer (michaelni@gmx.at)
- *
- * AltiVec optimizations (C) 2004 Romain Dolbeau <romain@dolbeau.org>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * postprocessing.
- */
-
-/*
-                        C       MMX     MMX2    3DNow   AltiVec
-isVertDC                Ec      Ec                      Ec
-isVertMinMaxOk          Ec      Ec                      Ec
-doVertLowPass           E               e       e       Ec
-doVertDefFilter         Ec      Ec      e       e       Ec
-isHorizDC               Ec      Ec                      Ec
-isHorizMinMaxOk         a       E                       Ec
-doHorizLowPass          E               e       e       Ec
-doHorizDefFilter        Ec      Ec      e       e       Ec
-do_a_deblock            Ec      E       Ec      E
-deRing                  E               e       e*      Ecp
-Vertical RKAlgo1        E               a       a
-Horizontal RKAlgo1                      a       a
-Vertical X1#            a               E       E
-Horizontal X1#          a               E       E
-LinIpolDeinterlace      e               E       E*
-CubicIpolDeinterlace    a               e       e*
-LinBlendDeinterlace     e               E       E*
-MedianDeinterlace#      E       Ec      Ec
-TempDeNoiser#           E               e       e       Ec
-
-* I do not have a 3DNow! CPU -> it is untested, but no one said it does not work so it seems to work
-# more or less selfinvented filters so the exactness is not too meaningful
-E = Exact implementation
-e = almost exact implementation (slightly different rounding,...)
-a = alternative / approximate impl
-c = checked against the other implementations (-vo md5)
-p = partially optimized, still some work to do
-*/
-
-/*
-TODO:
-reduce the time wasted on the mem transfer
-unroll stuff if instructions depend too much on the prior one
-move YScale thing to the end instead of fixing QP
-write a faster and higher quality deblocking filter :)
-make the mainloop more flexible (variable number of blocks at once
-        (the if/else stuff per block is slowing things down)
-compare the quality & speed of all filters
-split this huge file
-optimize c versions
-try to unroll inner for(x=0 ... loop to avoid these damn if(x ... checks
-...
-*/
-
-//Changelog: use git log
-
-#include "config.h"
-#include "libavutil/avutil.h"
-#include "libavutil/avassert.h"
-#include <inttypes.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-//#undef HAVE_MMXEXT_INLINE
-//#define HAVE_AMD3DNOW_INLINE
-//#undef HAVE_MMX_INLINE
-//#undef ARCH_X86
-//#define DEBUG_BRIGHTNESS
-#include "postprocess.h"
-#include "postprocess_internal.h"
-#include "libavutil/avstring.h"
-
-unsigned postproc_version(void)
-{
-    av_assert0(LIBPOSTPROC_VERSION_MICRO >= 100);
-    return LIBPOSTPROC_VERSION_INT;
-}
-
-const char *postproc_configuration(void)
-{
-    return FFMPEG_CONFIGURATION;
-}
-
-const char *postproc_license(void)
-{
-#define LICENSE_PREFIX "libpostproc license: "
-    return LICENSE_PREFIX FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;
-}
-
-#if HAVE_ALTIVEC_H
-#include <altivec.h>
-#endif
-
-#define GET_MODE_BUFFER_SIZE 500
-#define OPTIONS_ARRAY_SIZE 10
-#define BLOCK_SIZE 8
-#define TEMP_STRIDE 8
-//#define NUM_BLOCKS_AT_ONCE 16 //not used yet
-
-#if ARCH_X86 && HAVE_INLINE_ASM
-DECLARE_ASM_CONST(8, uint64_t, w05)= 0x0005000500050005LL;
-DECLARE_ASM_CONST(8, uint64_t, w04)= 0x0004000400040004LL;
-DECLARE_ASM_CONST(8, uint64_t, w20)= 0x0020002000200020LL;
-DECLARE_ASM_CONST(8, uint64_t, b00)= 0x0000000000000000LL;
-DECLARE_ASM_CONST(8, uint64_t, b01)= 0x0101010101010101LL;
-DECLARE_ASM_CONST(8, uint64_t, b02)= 0x0202020202020202LL;
-DECLARE_ASM_CONST(8, uint64_t, b08)= 0x0808080808080808LL;
-DECLARE_ASM_CONST(8, uint64_t, b80)= 0x8080808080808080LL;
-#endif
-
-DECLARE_ASM_CONST(8, int, deringThreshold)= 20;
-
-
-static const struct PPFilter filters[]=
-{
-    {"hb", "hdeblock",              1, 1, 3, H_DEBLOCK},
-    {"vb", "vdeblock",              1, 2, 4, V_DEBLOCK},
-/*  {"hr", "rkhdeblock",            1, 1, 3, H_RK1_FILTER},
-    {"vr", "rkvdeblock",            1, 2, 4, V_RK1_FILTER},*/
-    {"h1", "x1hdeblock",            1, 1, 3, H_X1_FILTER},
-    {"v1", "x1vdeblock",            1, 2, 4, V_X1_FILTER},
-    {"ha", "ahdeblock",             1, 1, 3, H_A_DEBLOCK},
-    {"va", "avdeblock",             1, 2, 4, V_A_DEBLOCK},
-    {"dr", "dering",                1, 5, 6, DERING},
-    {"al", "autolevels",            0, 1, 2, LEVEL_FIX},
-    {"lb", "linblenddeint",         1, 1, 4, LINEAR_BLEND_DEINT_FILTER},
-    {"li", "linipoldeint",          1, 1, 4, LINEAR_IPOL_DEINT_FILTER},
-    {"ci", "cubicipoldeint",        1, 1, 4, CUBIC_IPOL_DEINT_FILTER},
-    {"md", "mediandeint",           1, 1, 4, MEDIAN_DEINT_FILTER},
-    {"fd", "ffmpegdeint",           1, 1, 4, FFMPEG_DEINT_FILTER},
-    {"l5", "lowpass5",              1, 1, 4, LOWPASS5_DEINT_FILTER},
-    {"tn", "tmpnoise",              1, 7, 8, TEMP_NOISE_FILTER},
-    {"fq", "forcequant",            1, 0, 0, FORCE_QUANT},
-    {"be", "bitexact",              1, 0, 0, BITEXACT},
-    {NULL, NULL,0,0,0,0} //End Marker
-};
-
-static const char *replaceTable[]=
-{
-    "default",      "hb:a,vb:a,dr:a",
-    "de",           "hb:a,vb:a,dr:a",
-    "fast",         "h1:a,v1:a,dr:a",
-    "fa",           "h1:a,v1:a,dr:a",
-    "ac",           "ha:a:128:7,va:a,dr:a",
-    NULL //End Marker
-};
-
-
-#if ARCH_X86 && HAVE_INLINE_ASM
-static inline void prefetchnta(void *p)
-{
-    __asm__ volatile(   "prefetchnta (%0)\n\t"
-        : : "r" (p)
-    );
-}
-
-static inline void prefetcht0(void *p)
-{
-    __asm__ volatile(   "prefetcht0 (%0)\n\t"
-        : : "r" (p)
-    );
-}
-
-static inline void prefetcht1(void *p)
-{
-    __asm__ volatile(   "prefetcht1 (%0)\n\t"
-        : : "r" (p)
-    );
-}
-
-static inline void prefetcht2(void *p)
-{
-    __asm__ volatile(   "prefetcht2 (%0)\n\t"
-        : : "r" (p)
-    );
-}
-#endif
-
-/* The horizontal functions exist only in C because the MMX
- * code is faster with vertical filters and transposing. */
-
-/**
- * Check if the given 8x8 Block is mostly "flat"
- */
-static inline int isHorizDC_C(const uint8_t src[], int stride, const PPContext *c)
-{
-    int numEq= 0;
-    int y;
-    const int dcOffset= ((c->nonBQP*c->ppMode.baseDcDiff)>>8) + 1;
-    const int dcThreshold= dcOffset*2 + 1;
-
-    for(y=0; y<BLOCK_SIZE; y++){
-        if(((unsigned)(src[0] - src[1] + dcOffset)) < dcThreshold) numEq++;
-        if(((unsigned)(src[1] - src[2] + dcOffset)) < dcThreshold) numEq++;
-        if(((unsigned)(src[2] - src[3] + dcOffset)) < dcThreshold) numEq++;
-        if(((unsigned)(src[3] - src[4] + dcOffset)) < dcThreshold) numEq++;
-        if(((unsigned)(src[4] - src[5] + dcOffset)) < dcThreshold) numEq++;
-        if(((unsigned)(src[5] - src[6] + dcOffset)) < dcThreshold) numEq++;
-        if(((unsigned)(src[6] - src[7] + dcOffset)) < dcThreshold) numEq++;
-        src+= stride;
-    }
-    return numEq > c->ppMode.flatnessThreshold;
-}
-
-/**
- * Check if the middle 8x8 Block in the given 8x16 block is flat
- */
-static inline int isVertDC_C(const uint8_t src[], int stride, const PPContext *c)
-{
-    int numEq= 0;
-    int y;
-    const int dcOffset= ((c->nonBQP*c->ppMode.baseDcDiff)>>8) + 1;
-    const int dcThreshold= dcOffset*2 + 1;
-
-    src+= stride*4; // src points to begin of the 8x8 Block
-    for(y=0; y<BLOCK_SIZE-1; y++){
-        if(((unsigned)(src[0] - src[0+stride] + dcOffset)) < dcThreshold) numEq++;
-        if(((unsigned)(src[1] - src[1+stride] + dcOffset)) < dcThreshold) numEq++;
-        if(((unsigned)(src[2] - src[2+stride] + dcOffset)) < dcThreshold) numEq++;
-        if(((unsigned)(src[3] - src[3+stride] + dcOffset)) < dcThreshold) numEq++;
-        if(((unsigned)(src[4] - src[4+stride] + dcOffset)) < dcThreshold) numEq++;
-        if(((unsigned)(src[5] - src[5+stride] + dcOffset)) < dcThreshold) numEq++;
-        if(((unsigned)(src[6] - src[6+stride] + dcOffset)) < dcThreshold) numEq++;
-        if(((unsigned)(src[7] - src[7+stride] + dcOffset)) < dcThreshold) numEq++;
-        src+= stride;
-    }
-    return numEq > c->ppMode.flatnessThreshold;
-}
-
-static inline int isHorizMinMaxOk_C(const uint8_t src[], int stride, int QP)
-{
-    int i;
-    for(i=0; i<2; i++){
-        if((unsigned)(src[0] - src[5] + 2*QP) > 4*QP) return 0;
-        src += stride;
-        if((unsigned)(src[2] - src[7] + 2*QP) > 4*QP) return 0;
-        src += stride;
-        if((unsigned)(src[4] - src[1] + 2*QP) > 4*QP) return 0;
-        src += stride;
-        if((unsigned)(src[6] - src[3] + 2*QP) > 4*QP) return 0;
-        src += stride;
-    }
-    return 1;
-}
-
-static inline int isVertMinMaxOk_C(const uint8_t src[], int stride, int QP)
-{
-    int x;
-    src+= stride*4;
-    for(x=0; x<BLOCK_SIZE; x+=4){
-        if((unsigned)(src[  x + 0*stride] - src[  x + 5*stride] + 2*QP) > 4*QP) return 0;
-        if((unsigned)(src[1+x + 2*stride] - src[1+x + 7*stride] + 2*QP) > 4*QP) return 0;
-        if((unsigned)(src[2+x + 4*stride] - src[2+x + 1*stride] + 2*QP) > 4*QP) return 0;
-        if((unsigned)(src[3+x + 6*stride] - src[3+x + 3*stride] + 2*QP) > 4*QP) return 0;
-    }
-    return 1;
-}
-
-static inline int horizClassify_C(const uint8_t src[], int stride, const PPContext *c)
-{
-    if( isHorizDC_C(src, stride, c) ){
-        if( isHorizMinMaxOk_C(src, stride, c->QP) )
-            return 1;
-        else
-            return 0;
-    }else{
-        return 2;
-    }
-}
-
-static inline int vertClassify_C(const uint8_t src[], int stride, const PPContext *c)
-{
-    if( isVertDC_C(src, stride, c) ){
-        if( isVertMinMaxOk_C(src, stride, c->QP) )
-            return 1;
-        else
-            return 0;
-    }else{
-        return 2;
-    }
-}
-
-static inline void doHorizDefFilter_C(uint8_t dst[], int stride, const PPContext *c)
-{
-    int y;
-    for(y=0; y<BLOCK_SIZE; y++){
-        const int middleEnergy= 5*(dst[4] - dst[3]) + 2*(dst[2] - dst[5]);
-
-        if(FFABS(middleEnergy) < 8*c->QP){
-            const int q=(dst[3] - dst[4])/2;
-            const int leftEnergy=  5*(dst[2] - dst[1]) + 2*(dst[0] - dst[3]);
-            const int rightEnergy= 5*(dst[6] - dst[5]) + 2*(dst[4] - dst[7]);
-
-            int d= FFABS(middleEnergy) - FFMIN( FFABS(leftEnergy), FFABS(rightEnergy) );
-            d= FFMAX(d, 0);
-
-            d= (5*d + 32) >> 6;
-            d*= FFSIGN(-middleEnergy);
-
-            if(q>0)
-            {
-                d= d<0 ? 0 : d;
-                d= d>q ? q : d;
-            }
-            else
-            {
-                d= d>0 ? 0 : d;
-                d= d<q ? q : d;
-            }
-
-            dst[3]-= d;
-            dst[4]+= d;
-        }
-        dst+= stride;
-    }
-}
-
-/**
- * Do a horizontal low pass filter on the 10x8 block (dst points to middle 8x8 Block)
- * using the 9-Tap Filter (1,1,2,2,4,2,2,1,1)/16 (C version)
- */
-static inline void doHorizLowPass_C(uint8_t dst[], int stride, const PPContext *c)
-{
-    int y;
-    for(y=0; y<BLOCK_SIZE; y++){
-        const int first= FFABS(dst[-1] - dst[0]) < c->QP ? dst[-1] : dst[0];
-        const int last= FFABS(dst[8] - dst[7]) < c->QP ? dst[8] : dst[7];
-
-        int sums[10];
-        sums[0] = 4*first + dst[0] + dst[1] + dst[2] + 4;
-        sums[1] = sums[0] - first  + dst[3];
-        sums[2] = sums[1] - first  + dst[4];
-        sums[3] = sums[2] - first  + dst[5];
-        sums[4] = sums[3] - first  + dst[6];
-        sums[5] = sums[4] - dst[0] + dst[7];
-        sums[6] = sums[5] - dst[1] + last;
-        sums[7] = sums[6] - dst[2] + last;
-        sums[8] = sums[7] - dst[3] + last;
-        sums[9] = sums[8] - dst[4] + last;
-
-        dst[0]= (sums[0] + sums[2] + 2*dst[0])>>4;
-        dst[1]= (sums[1] + sums[3] + 2*dst[1])>>4;
-        dst[2]= (sums[2] + sums[4] + 2*dst[2])>>4;
-        dst[3]= (sums[3] + sums[5] + 2*dst[3])>>4;
-        dst[4]= (sums[4] + sums[6] + 2*dst[4])>>4;
-        dst[5]= (sums[5] + sums[7] + 2*dst[5])>>4;
-        dst[6]= (sums[6] + sums[8] + 2*dst[6])>>4;
-        dst[7]= (sums[7] + sums[9] + 2*dst[7])>>4;
-
-        dst+= stride;
-    }
-}
-
-/**
- * Experimental Filter 1 (Horizontal)
- * will not damage linear gradients
- * Flat blocks should look like they were passed through the (1,1,2,2,4,2,2,1,1) 9-Tap filter
- * can only smooth blocks at the expected locations (it cannot smooth them if they did move)
- * MMX2 version does correct clipping C version does not
- * not identical with the vertical one
- */
-static inline void horizX1Filter(uint8_t *src, int stride, int QP)
-{
-    int y;
-    static uint64_t lut[256];
-    if(!lut[255])
-    {
-        int i;
-        for(i=0; i<256; i++)
-        {
-            int v= i < 128 ? 2*i : 2*(i-256);
-/*
-//Simulate 112242211 9-Tap filter
-            uint64_t a= (v/16)  & 0xFF;
-            uint64_t b= (v/8)   & 0xFF;
-            uint64_t c= (v/4)   & 0xFF;
-            uint64_t d= (3*v/8) & 0xFF;
-*/
-//Simulate piecewise linear interpolation
-            uint64_t a= (v/16)   & 0xFF;
-            uint64_t b= (v*3/16) & 0xFF;
-            uint64_t c= (v*5/16) & 0xFF;
-            uint64_t d= (7*v/16) & 0xFF;
-            uint64_t A= (0x100 - a)&0xFF;
-            uint64_t B= (0x100 - b)&0xFF;
-            uint64_t C= (0x100 - c)&0xFF;
-            uint64_t D= (0x100 - c)&0xFF;
-
-            lut[i]   = (a<<56) | (b<<48) | (c<<40) | (d<<32) |
-                       (D<<24) | (C<<16) | (B<<8)  | (A);
-            //lut[i] = (v<<32) | (v<<24);
-        }
-    }
-
-    for(y=0; y<BLOCK_SIZE; y++){
-        int a= src[1] - src[2];
-        int b= src[3] - src[4];
-        int c= src[5] - src[6];
-
-        int d= FFMAX(FFABS(b) - (FFABS(a) + FFABS(c))/2, 0);
-
-        if(d < QP){
-            int v = d * FFSIGN(-b);
-
-            src[1] +=v/8;
-            src[2] +=v/4;
-            src[3] +=3*v/8;
-            src[4] -=3*v/8;
-            src[5] -=v/4;
-            src[6] -=v/8;
-        }
-        src+=stride;
-    }
-}
-
-/**
- * accurate deblock filter
- */
-static av_always_inline void do_a_deblock_C(uint8_t *src, int step,
-                                            int stride, const PPContext *c)
-{
-    int y;
-    const int QP= c->QP;
-    const int dcOffset= ((c->nonBQP*c->ppMode.baseDcDiff)>>8) + 1;
-    const int dcThreshold= dcOffset*2 + 1;
-//START_TIMER
-    src+= step*4; // src points to begin of the 8x8 Block
-    for(y=0; y<8; y++){
-        int numEq= 0;
-
-        if(((unsigned)(src[-1*step] - src[0*step] + dcOffset)) < dcThreshold) numEq++;
-        if(((unsigned)(src[ 0*step] - src[1*step] + dcOffset)) < dcThreshold) numEq++;
-        if(((unsigned)(src[ 1*step] - src[2*step] + dcOffset)) < dcThreshold) numEq++;
-        if(((unsigned)(src[ 2*step] - src[3*step] + dcOffset)) < dcThreshold) numEq++;
-        if(((unsigned)(src[ 3*step] - src[4*step] + dcOffset)) < dcThreshold) numEq++;
-        if(((unsigned)(src[ 4*step] - src[5*step] + dcOffset)) < dcThreshold) numEq++;
-        if(((unsigned)(src[ 5*step] - src[6*step] + dcOffset)) < dcThreshold) numEq++;
-        if(((unsigned)(src[ 6*step] - src[7*step] + dcOffset)) < dcThreshold) numEq++;
-        if(((unsigned)(src[ 7*step] - src[8*step] + dcOffset)) < dcThreshold) numEq++;
-        if(numEq > c->ppMode.flatnessThreshold){
-            int min, max, x;
-
-            if(src[0] > src[step]){
-                max= src[0];
-                min= src[step];
-            }else{
-                max= src[step];
-                min= src[0];
-            }
-            for(x=2; x<8; x+=2){
-                if(src[x*step] > src[(x+1)*step]){
-                        if(src[x    *step] > max) max= src[ x   *step];
-                        if(src[(x+1)*step] < min) min= src[(x+1)*step];
-                }else{
-                        if(src[(x+1)*step] > max) max= src[(x+1)*step];
-                        if(src[ x   *step] < min) min= src[ x   *step];
-                }
-            }
-            if(max-min < 2*QP){
-                const int first= FFABS(src[-1*step] - src[0]) < QP ? src[-1*step] : src[0];
-                const int last= FFABS(src[8*step] - src[7*step]) < QP ? src[8*step] : src[7*step];
-
-                int sums[10];
-                sums[0] = 4*first + src[0*step] + src[1*step] + src[2*step] + 4;
-                sums[1] = sums[0] - first       + src[3*step];
-                sums[2] = sums[1] - first       + src[4*step];
-                sums[3] = sums[2] - first       + src[5*step];
-                sums[4] = sums[3] - first       + src[6*step];
-                sums[5] = sums[4] - src[0*step] + src[7*step];
-                sums[6] = sums[5] - src[1*step] + last;
-                sums[7] = sums[6] - src[2*step] + last;
-                sums[8] = sums[7] - src[3*step] + last;
-                sums[9] = sums[8] - src[4*step] + last;
-
-                src[0*step]= (sums[0] + sums[2] + 2*src[0*step])>>4;
-                src[1*step]= (sums[1] + sums[3] + 2*src[1*step])>>4;
-                src[2*step]= (sums[2] + sums[4] + 2*src[2*step])>>4;
-                src[3*step]= (sums[3] + sums[5] + 2*src[3*step])>>4;
-                src[4*step]= (sums[4] + sums[6] + 2*src[4*step])>>4;
-                src[5*step]= (sums[5] + sums[7] + 2*src[5*step])>>4;
-                src[6*step]= (sums[6] + sums[8] + 2*src[6*step])>>4;
-                src[7*step]= (sums[7] + sums[9] + 2*src[7*step])>>4;
-            }
-        }else{
-            const int middleEnergy= 5*(src[4*step] - src[3*step]) + 2*(src[2*step] - src[5*step]);
-
-            if(FFABS(middleEnergy) < 8*QP){
-                const int q=(src[3*step] - src[4*step])/2;
-                const int leftEnergy=  5*(src[2*step] - src[1*step]) + 2*(src[0*step] - src[3*step]);
-                const int rightEnergy= 5*(src[6*step] - src[5*step]) + 2*(src[4*step] - src[7*step]);
-
-                int d= FFABS(middleEnergy) - FFMIN( FFABS(leftEnergy), FFABS(rightEnergy) );
-                d= FFMAX(d, 0);
-
-                d= (5*d + 32) >> 6;
-                d*= FFSIGN(-middleEnergy);
-
-                if(q>0){
-                    d= d<0 ? 0 : d;
-                    d= d>q ? q : d;
-                }else{
-                    d= d>0 ? 0 : d;
-                    d= d<q ? q : d;
-                }
-
-                src[3*step]-= d;
-                src[4*step]+= d;
-            }
-        }
-
-        src += stride;
-    }
-/*if(step==16){
-    STOP_TIMER("step16")
-}else{
-    STOP_TIMER("stepX")
-}*/
-}
-
-//Note: we have C, MMX, MMX2, 3DNOW version there is no 3DNOW+MMX2 one
-//Plain C versions
-//we always compile C for testing which needs bitexactness
-#define TEMPLATE_PP_C 1
-#include "postprocess_template.c"
-
-#if HAVE_ALTIVEC
-#   define TEMPLATE_PP_ALTIVEC 1
-#   include "postprocess_altivec_template.c"
-#   include "postprocess_template.c"
-#endif
-
-#if ARCH_X86 && HAVE_INLINE_ASM
-#    if CONFIG_RUNTIME_CPUDETECT
-#        define TEMPLATE_PP_MMX 1
-#        include "postprocess_template.c"
-#        define TEMPLATE_PP_MMXEXT 1
-#        include "postprocess_template.c"
-#        define TEMPLATE_PP_3DNOW 1
-#        include "postprocess_template.c"
-#        define TEMPLATE_PP_SSE2 1
-#        include "postprocess_template.c"
-#    else
-#        if HAVE_SSE2_INLINE
-#            define TEMPLATE_PP_SSE2 1
-#            include "postprocess_template.c"
-#        elif HAVE_MMXEXT_INLINE
-#            define TEMPLATE_PP_MMXEXT 1
-#            include "postprocess_template.c"
-#        elif HAVE_AMD3DNOW_INLINE
-#            define TEMPLATE_PP_3DNOW 1
-#            include "postprocess_template.c"
-#        elif HAVE_MMX_INLINE
-#            define TEMPLATE_PP_MMX 1
-#            include "postprocess_template.c"
-#        endif
-#    endif
-#endif
-
-typedef void (*pp_fn)(const uint8_t src[], int srcStride, uint8_t dst[], int dstStride, int width, int height,
-                      const QP_STORE_T QPs[], int QPStride, int isColor, PPContext *c2);
-
-static inline void postProcess(const uint8_t src[], int srcStride, uint8_t dst[], int dstStride, int width, int height,
-        const QP_STORE_T QPs[], int QPStride, int isColor, pp_mode *vm, pp_context *vc)
-{
-    pp_fn pp = postProcess_C;
-    PPContext *c= (PPContext *)vc;
-    PPMode *ppMode= (PPMode *)vm;
-    c->ppMode= *ppMode; //FIXME
-
-    if (!(ppMode->lumMode & BITEXACT)) {
-#if CONFIG_RUNTIME_CPUDETECT
-#if ARCH_X86 && HAVE_INLINE_ASM
-        // ordered per speed fastest first
-        if      (c->cpuCaps & AV_CPU_FLAG_SSE2)     pp = postProcess_SSE2;
-        else if (c->cpuCaps & AV_CPU_FLAG_MMXEXT)   pp = postProcess_MMX2;
-        else if (c->cpuCaps & AV_CPU_FLAG_3DNOW)    pp = postProcess_3DNow;
-        else if (c->cpuCaps & AV_CPU_FLAG_MMX)      pp = postProcess_MMX;
-#elif HAVE_ALTIVEC
-        if      (c->cpuCaps & AV_CPU_FLAG_ALTIVEC)  pp = postProcess_altivec;
-#endif
-#else /* CONFIG_RUNTIME_CPUDETECT */
-#if     HAVE_SSE2_INLINE
-        pp = postProcess_SSE2;
-#elif   HAVE_MMXEXT_INLINE
-        pp = postProcess_MMX2;
-#elif HAVE_AMD3DNOW_INLINE
-        pp = postProcess_3DNow;
-#elif HAVE_MMX_INLINE
-        pp = postProcess_MMX;
-#elif HAVE_ALTIVEC
-        pp = postProcess_altivec;
-#endif
-#endif /* !CONFIG_RUNTIME_CPUDETECT */
-    }
-
-    pp(src, srcStride, dst, dstStride, width, height, QPs, QPStride, isColor, c);
-}
-
-/* -pp Command line Help
-*/
-const char pp_help[] =
-"Available postprocessing filters:\n"
-"Filters                        Options\n"
-"short  long name       short   long option     Description\n"
-"*      *               a       autoq           CPU power dependent enabler\n"
-"                       c       chrom           chrominance filtering enabled\n"
-"                       y       nochrom         chrominance filtering disabled\n"
-"                       n       noluma          luma filtering disabled\n"
-"hb     hdeblock        (2 threshold)           horizontal deblocking filter\n"
-"       1. difference factor: default=32, higher -> more deblocking\n"
-"       2. flatness threshold: default=39, lower -> more deblocking\n"
-"                       the h & v deblocking filters share these\n"
-"                       so you can't set different thresholds for h / v\n"
-"vb     vdeblock        (2 threshold)           vertical deblocking filter\n"
-"ha     hadeblock       (2 threshold)           horizontal deblocking filter\n"
-"va     vadeblock       (2 threshold)           vertical deblocking filter\n"
-"h1     x1hdeblock                              experimental h deblock filter 1\n"
-"v1     x1vdeblock                              experimental v deblock filter 1\n"
-"dr     dering                                  deringing filter\n"
-"al     autolevels                              automatic brightness / contrast\n"
-"                       f        fullyrange     stretch luminance to (0..255)\n"
-"lb     linblenddeint                           linear blend deinterlacer\n"
-"li     linipoldeint                            linear interpolating deinterlace\n"
-"ci     cubicipoldeint                          cubic interpolating deinterlacer\n"
-"md     mediandeint                             median deinterlacer\n"
-"fd     ffmpegdeint                             ffmpeg deinterlacer\n"
-"l5     lowpass5                                FIR lowpass deinterlacer\n"
-"de     default                                 hb:a,vb:a,dr:a\n"
-"fa     fast                                    h1:a,v1:a,dr:a\n"
-"ac                                             ha:a:128:7,va:a,dr:a\n"
-"tn     tmpnoise        (3 threshold)           temporal noise reducer\n"
-"                     1. <= 2. <= 3.            larger -> stronger filtering\n"
-"fq     forceQuant      <quantizer>             force quantizer\n"
-"Usage:\n"
-"<filterName>[:<option>[:<option>...]][[,|/][-]<filterName>[:<option>...]]...\n"
-"long form example:\n"
-"vdeblock:autoq/hdeblock:autoq/linblenddeint    default,-vdeblock\n"
-"short form example:\n"
-"vb:a/hb:a/lb                                   de,-vb\n"
-"more examples:\n"
-"tn:64:128:256\n"
-"\n"
-;
-
-pp_mode *pp_get_mode_by_name_and_quality(const char *name, int quality)
-{
-    char temp[GET_MODE_BUFFER_SIZE];
-    char *p= temp;
-    static const char filterDelimiters[] = ",/";
-    static const char optionDelimiters[] = ":|";
-    struct PPMode *ppMode;
-    char *filterToken;
-
-    if (!name)  {
-        av_log(NULL, AV_LOG_ERROR, "pp: Missing argument\n");
-        return NULL;
-    }
-
-    if (!strcmp(name, "help")) {
-        const char *p;
-        for (p = pp_help; strchr(p, '\n'); p = strchr(p, '\n') + 1) {
-            av_strlcpy(temp, p, FFMIN(sizeof(temp), strchr(p, '\n') - p + 2));
-            av_log(NULL, AV_LOG_INFO, "%s", temp);
-        }
-        return NULL;
-    }
-
-    ppMode= av_malloc(sizeof(PPMode));
-
-    ppMode->lumMode= 0;
-    ppMode->chromMode= 0;
-    ppMode->maxTmpNoise[0]= 700;
-    ppMode->maxTmpNoise[1]= 1500;
-    ppMode->maxTmpNoise[2]= 3000;
-    ppMode->maxAllowedY= 234;
-    ppMode->minAllowedY= 16;
-    ppMode->baseDcDiff= 256/8;
-    ppMode->flatnessThreshold= 56-16-1;
-    ppMode->maxClippedThreshold= 0.01;
-    ppMode->error=0;
-
-    memset(temp, 0, GET_MODE_BUFFER_SIZE);
-    av_strlcpy(temp, name, GET_MODE_BUFFER_SIZE - 1);
-
-    av_log(NULL, AV_LOG_DEBUG, "pp: %s\n", name);
-
-    for(;;){
-        char *filterName;
-        int q= 1000000; //PP_QUALITY_MAX;
-        int chrom=-1;
-        int luma=-1;
-        char *option;
-        char *options[OPTIONS_ARRAY_SIZE];
-        int i;
-        int filterNameOk=0;
-        int numOfUnknownOptions=0;
-        int enable=1; //does the user want us to enabled or disabled the filter
-
-        filterToken= strtok(p, filterDelimiters);
-        if(filterToken == NULL) break;
-        p+= strlen(filterToken) + 1; // p points to next filterToken
-        filterName= strtok(filterToken, optionDelimiters);
-        if (filterName == NULL) {
-            ppMode->error++;
-            break;
-        }
-        av_log(NULL, AV_LOG_DEBUG, "pp: %s::%s\n", filterToken, filterName);
-
-        if(*filterName == '-'){
-            enable=0;
-            filterName++;
-        }
-
-        for(;;){ //for all options
-            option= strtok(NULL, optionDelimiters);
-            if(option == NULL) break;
-
-            av_log(NULL, AV_LOG_DEBUG, "pp: option: %s\n", option);
-            if(!strcmp("autoq", option) || !strcmp("a", option)) q= quality;
-            else if(!strcmp("nochrom", option) || !strcmp("y", option)) chrom=0;
-            else if(!strcmp("chrom", option) || !strcmp("c", option)) chrom=1;
-            else if(!strcmp("noluma", option) || !strcmp("n", option)) luma=0;
-            else{
-                options[numOfUnknownOptions] = option;
-                numOfUnknownOptions++;
-            }
-            if(numOfUnknownOptions >= OPTIONS_ARRAY_SIZE-1) break;
-        }
-        options[numOfUnknownOptions] = NULL;
-
-        /* replace stuff from the replace Table */
-        for(i=0; replaceTable[2*i]!=NULL; i++){
-            if(!strcmp(replaceTable[2*i], filterName)){
-                int newlen= strlen(replaceTable[2*i + 1]);
-                int plen;
-                int spaceLeft;
-
-                p--, *p=',';
-
-                plen= strlen(p);
-                spaceLeft= p - temp + plen;
-                if(spaceLeft + newlen  >= GET_MODE_BUFFER_SIZE - 1){
-                    ppMode->error++;
-                    break;
-                }
-                memmove(p + newlen, p, plen+1);
-                memcpy(p, replaceTable[2*i + 1], newlen);
-                filterNameOk=1;
-            }
-        }
-
-        for(i=0; filters[i].shortName!=NULL; i++){
-            if(   !strcmp(filters[i].longName, filterName)
-               || !strcmp(filters[i].shortName, filterName)){
-                ppMode->lumMode &= ~filters[i].mask;
-                ppMode->chromMode &= ~filters[i].mask;
-
-                filterNameOk=1;
-                if(!enable) break; // user wants to disable it
-
-                if(q >= filters[i].minLumQuality && luma)
-                    ppMode->lumMode|= filters[i].mask;
-                if(chrom==1 || (chrom==-1 && filters[i].chromDefault))
-                    if(q >= filters[i].minChromQuality)
-                            ppMode->chromMode|= filters[i].mask;
-
-                if(filters[i].mask == LEVEL_FIX){
-                    int o;
-                    ppMode->minAllowedY= 16;
-                    ppMode->maxAllowedY= 234;
-                    for(o=0; options[o]!=NULL; o++){
-                        if(  !strcmp(options[o],"fullyrange")
-                           ||!strcmp(options[o],"f")){
-                            ppMode->minAllowedY= 0;
-                            ppMode->maxAllowedY= 255;
-                            numOfUnknownOptions--;
-                        }
-                    }
-                }
-                else if(filters[i].mask == TEMP_NOISE_FILTER)
-                {
-                    int o;
-                    int numOfNoises=0;
-
-                    for(o=0; options[o]!=NULL; o++){
-                        char *tail;
-                        ppMode->maxTmpNoise[numOfNoises]=
-                            strtol(options[o], &tail, 0);
-                        if(tail!=options[o]){
-                            numOfNoises++;
-                            numOfUnknownOptions--;
-                            if(numOfNoises >= 3) break;
-                        }
-                    }
-                }
-                else if(filters[i].mask == V_DEBLOCK   || filters[i].mask == H_DEBLOCK
-                     || filters[i].mask == V_A_DEBLOCK || filters[i].mask == H_A_DEBLOCK){
-                    int o;
-
-                    for(o=0; options[o]!=NULL && o<2; o++){
-                        char *tail;
-                        int val= strtol(options[o], &tail, 0);
-                        if(tail==options[o]) break;
-
-                        numOfUnknownOptions--;
-                        if(o==0) ppMode->baseDcDiff= val;
-                        else ppMode->flatnessThreshold= val;
-                    }
-                }
-                else if(filters[i].mask == FORCE_QUANT){
-                    int o;
-                    ppMode->forcedQuant= 15;
-
-                    for(o=0; options[o]!=NULL && o<1; o++){
-                        char *tail;
-                        int val= strtol(options[o], &tail, 0);
-                        if(tail==options[o]) break;
-
-                        numOfUnknownOptions--;
-                        ppMode->forcedQuant= val;
-                    }
-                }
-            }
-        }
-        if(!filterNameOk) ppMode->error++;
-        ppMode->error += numOfUnknownOptions;
-    }
-
-    av_log(NULL, AV_LOG_DEBUG, "pp: lumMode=%X, chromMode=%X\n", ppMode->lumMode, ppMode->chromMode);
-    if(ppMode->error){
-        av_log(NULL, AV_LOG_ERROR, "%d errors in postprocess string \"%s\"\n", ppMode->error, name);
-        av_free(ppMode);
-        return NULL;
-    }
-    return ppMode;
-}
-
-void pp_free_mode(pp_mode *mode){
-    av_free(mode);
-}
-
-static void reallocAlign(void **p, int alignment, int size){
-    av_free(*p);
-    *p= av_mallocz(size);
-}
-
-static void reallocBuffers(PPContext *c, int width, int height, int stride, int qpStride){
-    int mbWidth = (width+15)>>4;
-    int mbHeight= (height+15)>>4;
-    int i;
-
-    c->stride= stride;
-    c->qpStride= qpStride;
-
-    reallocAlign((void **)&c->tempDst, 8, stride*24+32);
-    reallocAlign((void **)&c->tempSrc, 8, stride*24);
-    reallocAlign((void **)&c->tempBlocks, 8, 2*16*8);
-    reallocAlign((void **)&c->yHistogram, 8, 256*sizeof(uint64_t));
-    for(i=0; i<256; i++)
-            c->yHistogram[i]= width*height/64*15/256;
-
-    for(i=0; i<3; i++){
-        //Note: The +17*1024 is just there so I do not have to worry about r/w over the end.
-        reallocAlign((void **)&c->tempBlurred[i], 8, stride*mbHeight*16 + 17*1024);
-        reallocAlign((void **)&c->tempBlurredPast[i], 8, 256*((height+7)&(~7))/2 + 17*1024);//FIXME size
-    }
-
-    reallocAlign((void **)&c->deintTemp, 8, 2*width+32);
-    reallocAlign((void **)&c->nonBQPTable, 8, qpStride*mbHeight*sizeof(QP_STORE_T));
-    reallocAlign((void **)&c->stdQPTable, 8, qpStride*mbHeight*sizeof(QP_STORE_T));
-    reallocAlign((void **)&c->forcedQPTable, 8, mbWidth*sizeof(QP_STORE_T));
-}
-
-static const char * context_to_name(void * ptr) {
-    return "postproc";
-}
-
-static const AVClass av_codec_context_class = { "Postproc", context_to_name, NULL };
-
-pp_context *pp_get_context(int width, int height, int cpuCaps){
-    PPContext *c= av_malloc(sizeof(PPContext));
-    int stride= FFALIGN(width, 16);  //assumed / will realloc if needed
-    int qpStride= (width+15)/16 + 2; //assumed / will realloc if needed
-
-    memset(c, 0, sizeof(PPContext));
-    c->av_class = &av_codec_context_class;
-    if(cpuCaps&PP_FORMAT){
-        c->hChromaSubSample= cpuCaps&0x3;
-        c->vChromaSubSample= (cpuCaps>>4)&0x3;
-    }else{
-        c->hChromaSubSample= 1;
-        c->vChromaSubSample= 1;
-    }
-    if (cpuCaps & PP_CPU_CAPS_AUTO) {
-        c->cpuCaps = av_get_cpu_flags();
-    } else {
-        c->cpuCaps = 0;
-        if (cpuCaps & PP_CPU_CAPS_MMX)      c->cpuCaps |= AV_CPU_FLAG_MMX;
-        if (cpuCaps & PP_CPU_CAPS_MMX2)     c->cpuCaps |= AV_CPU_FLAG_MMXEXT;
-        if (cpuCaps & PP_CPU_CAPS_3DNOW)    c->cpuCaps |= AV_CPU_FLAG_3DNOW;
-        if (cpuCaps & PP_CPU_CAPS_ALTIVEC)  c->cpuCaps |= AV_CPU_FLAG_ALTIVEC;
-    }
-
-    reallocBuffers(c, width, height, stride, qpStride);
-
-    c->frameNum=-1;
-
-    return c;
-}
-
-void pp_free_context(void *vc){
-    PPContext *c = (PPContext*)vc;
-    int i;
-
-    for(i=0; i<3; i++) av_free(c->tempBlurred[i]);
-    for(i=0; i<3; i++) av_free(c->tempBlurredPast[i]);
-
-    av_free(c->tempBlocks);
-    av_free(c->yHistogram);
-    av_free(c->tempDst);
-    av_free(c->tempSrc);
-    av_free(c->deintTemp);
-    av_free(c->stdQPTable);
-    av_free(c->nonBQPTable);
-    av_free(c->forcedQPTable);
-
-    memset(c, 0, sizeof(PPContext));
-
-    av_free(c);
-}
-
-void  pp_postprocess(const uint8_t * src[3], const int srcStride[3],
-                     uint8_t * dst[3], const int dstStride[3],
-                     int width, int height,
-                     const QP_STORE_T *QP_store,  int QPStride,
-                     pp_mode *vm,  void *vc, int pict_type)
-{
-    int mbWidth = (width+15)>>4;
-    int mbHeight= (height+15)>>4;
-    PPMode *mode = (PPMode*)vm;
-    PPContext *c = (PPContext*)vc;
-    int minStride= FFMAX(FFABS(srcStride[0]), FFABS(dstStride[0]));
-    int absQPStride = FFABS(QPStride);
-
-    // c->stride and c->QPStride are always positive
-    if(c->stride < minStride || c->qpStride < absQPStride)
-        reallocBuffers(c, width, height,
-                       FFMAX(minStride, c->stride),
-                       FFMAX(c->qpStride, absQPStride));
-
-    if(QP_store==NULL || (mode->lumMode & FORCE_QUANT)){
-        int i;
-        QP_store= c->forcedQPTable;
-        absQPStride = QPStride = 0;
-        if(mode->lumMode & FORCE_QUANT)
-            for(i=0; i<mbWidth; i++) c->forcedQPTable[i]= mode->forcedQuant;
-        else
-            for(i=0; i<mbWidth; i++) c->forcedQPTable[i]= 1;
-    }
-
-    if(pict_type & PP_PICT_TYPE_QP2){
-        int i;
-        const int count= mbHeight * absQPStride;
-        for(i=0; i<(count>>2); i++){
-            ((uint32_t*)c->stdQPTable)[i] = (((const uint32_t*)QP_store)[i]>>1) & 0x7F7F7F7F;
-        }
-        for(i<<=2; i<count; i++){
-            c->stdQPTable[i] = QP_store[i]>>1;
-        }
-        QP_store= c->stdQPTable;
-        QPStride= absQPStride;
-    }
-
-    if(0){
-        int x,y;
-        for(y=0; y<mbHeight; y++){
-            for(x=0; x<mbWidth; x++){
-                av_log(c, AV_LOG_INFO, "%2d ", QP_store[x + y*QPStride]);
-            }
-            av_log(c, AV_LOG_INFO, "\n");
-        }
-        av_log(c, AV_LOG_INFO, "\n");
-    }
-
-    if((pict_type&7)!=3){
-        if (QPStride >= 0){
-            int i;
-            const int count= mbHeight * QPStride;
-            for(i=0; i<(count>>2); i++){
-                ((uint32_t*)c->nonBQPTable)[i] = ((const uint32_t*)QP_store)[i] & 0x3F3F3F3F;
-            }
-            for(i<<=2; i<count; i++){
-                c->nonBQPTable[i] = QP_store[i] & 0x3F;
-            }
-        } else {
-            int i,j;
-            for(i=0; i<mbHeight; i++) {
-                for(j=0; j<absQPStride; j++) {
-                    c->nonBQPTable[i*absQPStride+j] = QP_store[i*QPStride+j] & 0x3F;
-                }
-            }
-        }
-    }
-
-    av_log(c, AV_LOG_DEBUG, "using npp filters 0x%X/0x%X\n",
-           mode->lumMode, mode->chromMode);
-
-    postProcess(src[0], srcStride[0], dst[0], dstStride[0],
-                width, height, QP_store, QPStride, 0, mode, c);
-
-    width  = (width )>>c->hChromaSubSample;
-    height = (height)>>c->vChromaSubSample;
-
-    if(mode->chromMode){
-        postProcess(src[1], srcStride[1], dst[1], dstStride[1],
-                    width, height, QP_store, QPStride, 1, mode, c);
-        postProcess(src[2], srcStride[2], dst[2], dstStride[2],
-                    width, height, QP_store, QPStride, 2, mode, c);
-    }
-    else if(srcStride[1] == dstStride[1] && srcStride[2] == dstStride[2]){
-        linecpy(dst[1], src[1], height, srcStride[1]);
-        linecpy(dst[2], src[2], height, srcStride[2]);
-    }else{
-        int y;
-        for(y=0; y<height; y++){
-            memcpy(&(dst[1][y*dstStride[1]]), &(src[1][y*srcStride[1]]), width);
-            memcpy(&(dst[2][y*dstStride[2]]), &(src[2][y*srcStride[2]]), width);
-        }
-    }
-}
diff --git a/libpostproc/postprocess.h b/libpostproc/postprocess.h
deleted file mode 100644
index 928e01f..0000000
--- a/libpostproc/postprocess.h
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2001-2003 Michael Niedermayer (michaelni@gmx.at)
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef POSTPROC_POSTPROCESS_H
-#define POSTPROC_POSTPROCESS_H
-
-/**
- * @file
- * @ingroup lpp
- * external API header
- */
-
-/**
- * @defgroup lpp Libpostproc
- * @{
- */
-
-#include "libpostproc/version.h"
-
-/**
- * Return the LIBPOSTPROC_VERSION_INT constant.
- */
-unsigned postproc_version(void);
-
-/**
- * Return the libpostproc build-time configuration.
- */
-const char *postproc_configuration(void);
-
-/**
- * Return the libpostproc license.
- */
-const char *postproc_license(void);
-
-#define PP_QUALITY_MAX 6
-
-#define QP_STORE_T int8_t
-
-#include <inttypes.h>
-
-typedef void pp_context;
-typedef void pp_mode;
-
-#if LIBPOSTPROC_VERSION_INT < (52<<16)
-typedef pp_context pp_context_t;
-typedef pp_mode pp_mode_t;
-extern const char *const pp_help; ///< a simple help text
-#else
-extern const char pp_help[]; ///< a simple help text
-#endif
-
-void  pp_postprocess(const uint8_t * src[3], const int srcStride[3],
-                     uint8_t * dst[3], const int dstStride[3],
-                     int horizontalSize, int verticalSize,
-                     const QP_STORE_T *QP_store,  int QP_stride,
-                     pp_mode *mode, pp_context *ppContext, int pict_type);
-
-
-/**
- * Return a pp_mode or NULL if an error occurred.
- *
- * @param name    the string after "-pp" on the command line
- * @param quality a number from 0 to PP_QUALITY_MAX
- */
-pp_mode *pp_get_mode_by_name_and_quality(const char *name, int quality);
-void pp_free_mode(pp_mode *mode);
-
-pp_context *pp_get_context(int width, int height, int flags);
-void pp_free_context(pp_context *ppContext);
-
-#define PP_CPU_CAPS_MMX   0x80000000
-#define PP_CPU_CAPS_MMX2  0x20000000
-#define PP_CPU_CAPS_3DNOW 0x40000000
-#define PP_CPU_CAPS_ALTIVEC 0x10000000
-#define PP_CPU_CAPS_AUTO  0x00080000
-
-#define PP_FORMAT         0x00000008
-#define PP_FORMAT_420    (0x00000011|PP_FORMAT)
-#define PP_FORMAT_422    (0x00000001|PP_FORMAT)
-#define PP_FORMAT_411    (0x00000002|PP_FORMAT)
-#define PP_FORMAT_444    (0x00000000|PP_FORMAT)
-
-#define PP_PICT_TYPE_QP2  0x00000010 ///< MPEG2 style QScale
-
-/**
- * @}
- */
-
-#endif /* POSTPROC_POSTPROCESS_H */
diff --git a/libpostproc/postprocess_altivec_template.c b/libpostproc/postprocess_altivec_template.c
deleted file mode 100644
index fa6ebe2..0000000
--- a/libpostproc/postprocess_altivec_template.c
+++ /dev/null
@@ -1,1210 +0,0 @@
-/*
- * AltiVec optimizations (C) 2004 Romain Dolbeau <romain@dolbeau.org>
- *
- * based on code by Copyright (C) 2001-2003 Michael Niedermayer (michaelni@gmx.at)
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include "libavutil/avutil.h"
-
-#define ALTIVEC_TRANSPOSE_8x8_SHORT(src_a,src_b,src_c,src_d,src_e,src_f,src_g,src_h) \
-    do {                                                          \
-        __typeof__(src_a) tempA1, tempB1, tempC1, tempD1;         \
-        __typeof__(src_a) tempE1, tempF1, tempG1, tempH1;         \
-        __typeof__(src_a) tempA2, tempB2, tempC2, tempD2;         \
-        __typeof__(src_a) tempE2, tempF2, tempG2, tempH2;         \
-        tempA1 = vec_mergeh (src_a, src_e);                       \
-        tempB1 = vec_mergel (src_a, src_e);                       \
-        tempC1 = vec_mergeh (src_b, src_f);                       \
-        tempD1 = vec_mergel (src_b, src_f);                       \
-        tempE1 = vec_mergeh (src_c, src_g);                       \
-        tempF1 = vec_mergel (src_c, src_g);                       \
-        tempG1 = vec_mergeh (src_d, src_h);                       \
-        tempH1 = vec_mergel (src_d, src_h);                       \
-        tempA2 = vec_mergeh (tempA1, tempE1);                     \
-        tempB2 = vec_mergel (tempA1, tempE1);                     \
-        tempC2 = vec_mergeh (tempB1, tempF1);                     \
-        tempD2 = vec_mergel (tempB1, tempF1);                     \
-        tempE2 = vec_mergeh (tempC1, tempG1);                     \
-        tempF2 = vec_mergel (tempC1, tempG1);                     \
-        tempG2 = vec_mergeh (tempD1, tempH1);                     \
-        tempH2 = vec_mergel (tempD1, tempH1);                     \
-        src_a = vec_mergeh (tempA2, tempE2);                      \
-        src_b = vec_mergel (tempA2, tempE2);                      \
-        src_c = vec_mergeh (tempB2, tempF2);                      \
-        src_d = vec_mergel (tempB2, tempF2);                      \
-        src_e = vec_mergeh (tempC2, tempG2);                      \
-        src_f = vec_mergel (tempC2, tempG2);                      \
-        src_g = vec_mergeh (tempD2, tempH2);                      \
-        src_h = vec_mergel (tempD2, tempH2);                      \
-    } while (0)
-
-
-static inline int vertClassify_altivec(uint8_t src[], int stride, PPContext *c) {
-    /*
-    this code makes no assumption on src or stride.
-    One could remove the recomputation of the perm
-    vector by assuming (stride % 16) == 0, unfortunately
-    this is not always true.
-    */
-    short data_0 = ((c->nonBQP*c->ppMode.baseDcDiff)>>8) + 1;
-    DECLARE_ALIGNED(16, short, data)[8] =
-                    {
-                        data_0,
-                        data_0 * 2 + 1,
-                        c->QP * 2,
-                        c->QP * 4
-                    };
-    int numEq;
-    uint8_t *src2 = src;
-    vector signed short v_dcOffset;
-    vector signed short v2QP;
-    vector unsigned short v4QP;
-    vector unsigned short v_dcThreshold;
-    const int properStride = (stride % 16);
-    const int srcAlign = ((unsigned long)src2 % 16);
-    const int two_vectors = ((srcAlign > 8) || properStride) ? 1 : 0;
-    const vector signed int zero = vec_splat_s32(0);
-    const vector signed short mask = vec_splat_s16(1);
-    vector signed int v_numEq = vec_splat_s32(0);
-    vector signed short v_data = vec_ld(0, data);
-    vector signed short v_srcAss0, v_srcAss1, v_srcAss2, v_srcAss3,
-                        v_srcAss4, v_srcAss5, v_srcAss6, v_srcAss7;
-//FIXME avoid this mess if possible
-    register int j0 = 0,
-                 j1 = stride,
-                 j2 = 2 * stride,
-                 j3 = 3 * stride,
-                 j4 = 4 * stride,
-                 j5 = 5 * stride,
-                 j6 = 6 * stride,
-                 j7 = 7 * stride;
-    vector unsigned char v_srcA0, v_srcA1, v_srcA2, v_srcA3,
-                         v_srcA4, v_srcA5, v_srcA6, v_srcA7;
-
-    v_dcOffset = vec_splat(v_data, 0);
-    v_dcThreshold = (vector unsigned short)vec_splat(v_data, 1);
-    v2QP = vec_splat(v_data, 2);
-    v4QP = (vector unsigned short)vec_splat(v_data, 3);
-
-    src2 += stride * 4;
-
-#define LOAD_LINE(i)                                                    \
-    {                                                                   \
-    vector unsigned char perm##i = vec_lvsl(j##i, src2);                \
-    vector unsigned char v_srcA2##i;                                    \
-    vector unsigned char v_srcA1##i = vec_ld(j##i, src2);               \
-    if (two_vectors)                                                    \
-        v_srcA2##i = vec_ld(j##i + 16, src2);                           \
-    v_srcA##i =                                                         \
-        vec_perm(v_srcA1##i, v_srcA2##i, perm##i);                      \
-    v_srcAss##i =                                                       \
-        (vector signed short)vec_mergeh((vector signed char)zero,       \
-                                        (vector signed char)v_srcA##i); }
-
-#define LOAD_LINE_ALIGNED(i)                                            \
-    v_srcA##i = vec_ld(j##i, src2);                                     \
-    v_srcAss##i =                                                       \
-        (vector signed short)vec_mergeh((vector signed char)zero,       \
-                                        (vector signed char)v_srcA##i)
-
-    /* Special-casing the aligned case is worthwhile, as all calls from
-     * the (transposed) horizontable deblocks will be aligned, in addition
-     * to the naturally aligned vertical deblocks. */
-    if (properStride && srcAlign) {
-        LOAD_LINE_ALIGNED(0);
-        LOAD_LINE_ALIGNED(1);
-        LOAD_LINE_ALIGNED(2);
-        LOAD_LINE_ALIGNED(3);
-        LOAD_LINE_ALIGNED(4);
-        LOAD_LINE_ALIGNED(5);
-        LOAD_LINE_ALIGNED(6);
-        LOAD_LINE_ALIGNED(7);
-    } else {
-        LOAD_LINE(0);
-        LOAD_LINE(1);
-        LOAD_LINE(2);
-        LOAD_LINE(3);
-        LOAD_LINE(4);
-        LOAD_LINE(5);
-        LOAD_LINE(6);
-        LOAD_LINE(7);
-    }
-#undef LOAD_LINE
-#undef LOAD_LINE_ALIGNED
-
-#define ITER(i, j)                                                      \
-    const vector signed short v_diff##i =                               \
-        vec_sub(v_srcAss##i, v_srcAss##j);                              \
-    const vector signed short v_sum##i =                                \
-        vec_add(v_diff##i, v_dcOffset);                                 \
-    const vector signed short v_comp##i =                               \
-        (vector signed short)vec_cmplt((vector unsigned short)v_sum##i, \
-                                       v_dcThreshold);                  \
-    const vector signed short v_part##i = vec_and(mask, v_comp##i);
-
-    {
-        ITER(0, 1)
-        ITER(1, 2)
-        ITER(2, 3)
-        ITER(3, 4)
-        ITER(4, 5)
-        ITER(5, 6)
-        ITER(6, 7)
-
-        v_numEq = vec_sum4s(v_part0, v_numEq);
-        v_numEq = vec_sum4s(v_part1, v_numEq);
-        v_numEq = vec_sum4s(v_part2, v_numEq);
-        v_numEq = vec_sum4s(v_part3, v_numEq);
-        v_numEq = vec_sum4s(v_part4, v_numEq);
-        v_numEq = vec_sum4s(v_part5, v_numEq);
-        v_numEq = vec_sum4s(v_part6, v_numEq);
-    }
-
-#undef ITER
-
-    v_numEq = vec_sums(v_numEq, zero);
-
-    v_numEq = vec_splat(v_numEq, 3);
-    vec_ste(v_numEq, 0, &numEq);
-
-    if (numEq > c->ppMode.flatnessThreshold){
-        const vector unsigned char mmoP1 = (const vector unsigned char)
-            {0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
-             0x00, 0x01, 0x12, 0x13, 0x08, 0x09, 0x1A, 0x1B};
-        const vector unsigned char mmoP2 = (const vector unsigned char)
-            {0x04, 0x05, 0x16, 0x17, 0x0C, 0x0D, 0x1E, 0x1F,
-             0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f};
-        const vector unsigned char mmoP = (const vector unsigned char)
-            vec_lvsl(8, (unsigned char*)0);
-
-        vector signed short mmoL1 = vec_perm(v_srcAss0, v_srcAss2, mmoP1);
-        vector signed short mmoL2 = vec_perm(v_srcAss4, v_srcAss6, mmoP2);
-        vector signed short mmoL = vec_perm(mmoL1, mmoL2, mmoP);
-        vector signed short mmoR1 = vec_perm(v_srcAss5, v_srcAss7, mmoP1);
-        vector signed short mmoR2 = vec_perm(v_srcAss1, v_srcAss3, mmoP2);
-        vector signed short mmoR = vec_perm(mmoR1, mmoR2, mmoP);
-        vector signed short mmoDiff = vec_sub(mmoL, mmoR);
-        vector unsigned short mmoSum = (vector unsigned short)vec_add(mmoDiff, v2QP);
-
-        if (vec_any_gt(mmoSum, v4QP))
-            return 0;
-        else
-            return 1;
-    }
-    else return 2;
-}
-
-static inline void doVertLowPass_altivec(uint8_t *src, int stride, PPContext *c) {
-    /*
-    this code makes no assumption on src or stride.
-    One could remove the recomputation of the perm
-    vector by assuming (stride % 16) == 0, unfortunately
-    this is not always true. Quite a lot of load/stores
-    can be removed by assuming proper alignment of
-    src & stride :-(
-    */
-    uint8_t *src2 = src;
-    const vector signed int zero = vec_splat_s32(0);
-    const int properStride = (stride % 16);
-    const int srcAlign = ((unsigned long)src2 % 16);
-    DECLARE_ALIGNED(16, short, qp)[8] = {c->QP};
-    vector signed short vqp = vec_ld(0, qp);
-    vector signed short vb0, vb1, vb2, vb3, vb4, vb5, vb6, vb7, vb8, vb9;
-    vector unsigned char vbA0, av_uninit(vbA1), av_uninit(vbA2), av_uninit(vbA3), av_uninit(vbA4), av_uninit(vbA5), av_uninit(vbA6), av_uninit(vbA7), av_uninit(vbA8), vbA9;
-    vector unsigned char vbB0, av_uninit(vbB1), av_uninit(vbB2), av_uninit(vbB3), av_uninit(vbB4), av_uninit(vbB5), av_uninit(vbB6), av_uninit(vbB7), av_uninit(vbB8), vbB9;
-    vector unsigned char vbT0, vbT1, vbT2, vbT3, vbT4, vbT5, vbT6, vbT7, vbT8, vbT9;
-    vector unsigned char perml0, perml1, perml2, perml3, perml4,
-                         perml5, perml6, perml7, perml8, perml9;
-    register int j0 = 0,
-                 j1 = stride,
-                 j2 = 2 * stride,
-                 j3 = 3 * stride,
-                 j4 = 4 * stride,
-                 j5 = 5 * stride,
-                 j6 = 6 * stride,
-                 j7 = 7 * stride,
-                 j8 = 8 * stride,
-                 j9 = 9 * stride;
-
-    vqp = vec_splat(vqp, 0);
-
-    src2 += stride*3;
-
-#define LOAD_LINE(i)                                                    \
-    perml##i = vec_lvsl(i * stride, src2);                              \
-    vbA##i = vec_ld(i * stride, src2);                                  \
-    vbB##i = vec_ld(i * stride + 16, src2);                             \
-    vbT##i = vec_perm(vbA##i, vbB##i, perml##i);                        \
-    vb##i =                                                             \
-        (vector signed short)vec_mergeh((vector unsigned char)zero,     \
-                                        (vector unsigned char)vbT##i)
-
-#define LOAD_LINE_ALIGNED(i)                                            \
-    vbT##i = vec_ld(j##i, src2);                                        \
-    vb##i =                                                             \
-        (vector signed short)vec_mergeh((vector signed char)zero,       \
-                                        (vector signed char)vbT##i)
-
-      /* Special-casing the aligned case is worthwhile, as all calls from
-       * the (transposed) horizontable deblocks will be aligned, in addition
-       * to the naturally aligned vertical deblocks. */
-    if (properStride && srcAlign) {
-          LOAD_LINE_ALIGNED(0);
-          LOAD_LINE_ALIGNED(1);
-          LOAD_LINE_ALIGNED(2);
-          LOAD_LINE_ALIGNED(3);
-          LOAD_LINE_ALIGNED(4);
-          LOAD_LINE_ALIGNED(5);
-          LOAD_LINE_ALIGNED(6);
-          LOAD_LINE_ALIGNED(7);
-          LOAD_LINE_ALIGNED(8);
-          LOAD_LINE_ALIGNED(9);
-    } else {
-          LOAD_LINE(0);
-          LOAD_LINE(1);
-          LOAD_LINE(2);
-          LOAD_LINE(3);
-          LOAD_LINE(4);
-          LOAD_LINE(5);
-          LOAD_LINE(6);
-          LOAD_LINE(7);
-          LOAD_LINE(8);
-          LOAD_LINE(9);
-    }
-#undef LOAD_LINE
-#undef LOAD_LINE_ALIGNED
-    {
-        const vector unsigned short v_2 = vec_splat_u16(2);
-        const vector unsigned short v_4 = vec_splat_u16(4);
-
-        const vector signed short v_diff01 = vec_sub(vb0, vb1);
-        const vector unsigned short v_cmp01 =
-            (const vector unsigned short) vec_cmplt(vec_abs(v_diff01), vqp);
-        const vector signed short v_first = vec_sel(vb1, vb0, v_cmp01);
-        const vector signed short v_diff89 = vec_sub(vb8, vb9);
-        const vector unsigned short v_cmp89 =
-            (const vector unsigned short) vec_cmplt(vec_abs(v_diff89), vqp);
-        const vector signed short v_last = vec_sel(vb8, vb9, v_cmp89);
-
-        const vector signed short temp01 = vec_mladd(v_first, (vector signed short)v_4, vb1);
-        const vector signed short temp02 = vec_add(vb2, vb3);
-        const vector signed short temp03 = vec_add(temp01, (vector signed short)v_4);
-        const vector signed short v_sumsB0 = vec_add(temp02, temp03);
-
-        const vector signed short temp11 = vec_sub(v_sumsB0, v_first);
-        const vector signed short v_sumsB1 = vec_add(temp11, vb4);
-
-        const vector signed short temp21 = vec_sub(v_sumsB1, v_first);
-        const vector signed short v_sumsB2 = vec_add(temp21, vb5);
-
-        const vector signed short temp31 = vec_sub(v_sumsB2, v_first);
-        const vector signed short v_sumsB3 = vec_add(temp31, vb6);
-
-        const vector signed short temp41 = vec_sub(v_sumsB3, v_first);
-        const vector signed short v_sumsB4 = vec_add(temp41, vb7);
-
-        const vector signed short temp51 = vec_sub(v_sumsB4, vb1);
-        const vector signed short v_sumsB5 = vec_add(temp51, vb8);
-
-        const vector signed short temp61 = vec_sub(v_sumsB5, vb2);
-        const vector signed short v_sumsB6 = vec_add(temp61, v_last);
-
-        const vector signed short temp71 = vec_sub(v_sumsB6, vb3);
-        const vector signed short v_sumsB7 = vec_add(temp71, v_last);
-
-        const vector signed short temp81 = vec_sub(v_sumsB7, vb4);
-        const vector signed short v_sumsB8 = vec_add(temp81, v_last);
-
-        const vector signed short temp91 = vec_sub(v_sumsB8, vb5);
-        const vector signed short v_sumsB9 = vec_add(temp91, v_last);
-
-    #define COMPUTE_VR(i, j, k)                                             \
-        const vector signed short temps1##i =                               \
-            vec_add(v_sumsB##i, v_sumsB##k);                                \
-        const vector signed short temps2##i =                               \
-            vec_mladd(vb##j, (vector signed short)v_2, temps1##i);          \
-        const vector signed short  vr##j = vec_sra(temps2##i, v_4)
-
-        COMPUTE_VR(0, 1, 2);
-        COMPUTE_VR(1, 2, 3);
-        COMPUTE_VR(2, 3, 4);
-        COMPUTE_VR(3, 4, 5);
-        COMPUTE_VR(4, 5, 6);
-        COMPUTE_VR(5, 6, 7);
-        COMPUTE_VR(6, 7, 8);
-        COMPUTE_VR(7, 8, 9);
-
-        const vector signed char neg1 = vec_splat_s8(-1);
-        const vector unsigned char permHH = (const vector unsigned char){0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
-                                                                         0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F};
-
-#define PACK_AND_STORE(i)                                       \
-{   const vector unsigned char perms##i =                       \
-        vec_lvsr(i * stride, src2);                             \
-    const vector unsigned char vf##i =                          \
-        vec_packsu(vr##i, (vector signed short)zero);           \
-    const vector unsigned char vg##i =                          \
-        vec_perm(vf##i, vbT##i, permHH);                        \
-    const vector unsigned char mask##i =                        \
-        vec_perm((vector unsigned char)zero, (vector unsigned char)neg1, perms##i); \
-    const vector unsigned char vg2##i =                         \
-        vec_perm(vg##i, vg##i, perms##i);                       \
-    const vector unsigned char svA##i =                         \
-        vec_sel(vbA##i, vg2##i, mask##i);                       \
-    const vector unsigned char svB##i =                         \
-        vec_sel(vg2##i, vbB##i, mask##i);                       \
-    vec_st(svA##i, i * stride, src2);                           \
-    vec_st(svB##i, i * stride + 16, src2);}
-
-#define PACK_AND_STORE_ALIGNED(i)                               \
-{   const vector unsigned char vf##i =                          \
-        vec_packsu(vr##i, (vector signed short)zero);           \
-    const vector unsigned char vg##i =                          \
-        vec_perm(vf##i, vbT##i, permHH);                        \
-    vec_st(vg##i, i * stride, src2);}
-
-        /* Special-casing the aligned case is worthwhile, as all calls from
-         * the (transposed) horizontable deblocks will be aligned, in addition
-         * to the naturally aligned vertical deblocks. */
-        if (properStride && srcAlign) {
-            PACK_AND_STORE_ALIGNED(1)
-            PACK_AND_STORE_ALIGNED(2)
-            PACK_AND_STORE_ALIGNED(3)
-            PACK_AND_STORE_ALIGNED(4)
-            PACK_AND_STORE_ALIGNED(5)
-            PACK_AND_STORE_ALIGNED(6)
-            PACK_AND_STORE_ALIGNED(7)
-            PACK_AND_STORE_ALIGNED(8)
-        } else {
-            PACK_AND_STORE(1)
-            PACK_AND_STORE(2)
-            PACK_AND_STORE(3)
-            PACK_AND_STORE(4)
-            PACK_AND_STORE(5)
-            PACK_AND_STORE(6)
-            PACK_AND_STORE(7)
-            PACK_AND_STORE(8)
-        }
-    #undef PACK_AND_STORE
-    #undef PACK_AND_STORE_ALIGNED
-    }
-}
-
-
-
-static inline void doVertDefFilter_altivec(uint8_t src[], int stride, PPContext *c) {
-    /*
-    this code makes no assumption on src or stride.
-    One could remove the recomputation of the perm
-    vector by assuming (stride % 16) == 0, unfortunately
-    this is not always true. Quite a lot of load/stores
-    can be removed by assuming proper alignment of
-    src & stride :-(
-    */
-    uint8_t *src2 = src + stride*3;
-    const vector signed int zero = vec_splat_s32(0);
-    DECLARE_ALIGNED(16, short, qp)[8] = {8*c->QP};
-    vector signed short vqp = vec_splat(
-                                (vector signed short)vec_ld(0, qp), 0);
-
-#define LOAD_LINE(i)                                                    \
-    const vector unsigned char perm##i =                                \
-        vec_lvsl(i * stride, src2);                                     \
-    const vector unsigned char vbA##i =                                 \
-        vec_ld(i * stride, src2);                                       \
-    const vector unsigned char vbB##i =                                 \
-        vec_ld(i * stride + 16, src2);                                  \
-    const vector unsigned char vbT##i =                                 \
-        vec_perm(vbA##i, vbB##i, perm##i);                              \
-    const vector signed short vb##i =                                   \
-        (vector signed short)vec_mergeh((vector unsigned char)zero,     \
-                                        (vector unsigned char)vbT##i)
-
-     LOAD_LINE(1);
-     LOAD_LINE(2);
-     LOAD_LINE(3);
-     LOAD_LINE(4);
-     LOAD_LINE(5);
-     LOAD_LINE(6);
-     LOAD_LINE(7);
-     LOAD_LINE(8);
-#undef LOAD_LINE
-
-     const vector signed short v_1 = vec_splat_s16(1);
-     const vector signed short v_2 = vec_splat_s16(2);
-     const vector signed short v_5 = vec_splat_s16(5);
-     const vector signed short v_32 = vec_sl(v_1,
-                                             (vector unsigned short)v_5);
-     /* middle energy */
-     const vector signed short l3minusl6 = vec_sub(vb3, vb6);
-     const vector signed short l5minusl4 = vec_sub(vb5, vb4);
-     const vector signed short twotimes_l3minusl6 = vec_mladd(v_2, l3minusl6, (vector signed short)zero);
-     const vector signed short mE = vec_mladd(v_5, l5minusl4, twotimes_l3minusl6);
-     const vector signed short absmE = vec_abs(mE);
-     /* left & right energy */
-     const vector signed short l1minusl4 = vec_sub(vb1, vb4);
-     const vector signed short l3minusl2 = vec_sub(vb3, vb2);
-     const vector signed short l5minusl8 = vec_sub(vb5, vb8);
-     const vector signed short l7minusl6 = vec_sub(vb7, vb6);
-     const vector signed short twotimes_l1minusl4 = vec_mladd(v_2, l1minusl4, (vector signed short)zero);
-     const vector signed short twotimes_l5minusl8 = vec_mladd(v_2, l5minusl8, (vector signed short)zero);
-     const vector signed short lE = vec_mladd(v_5, l3minusl2, twotimes_l1minusl4);
-     const vector signed short rE = vec_mladd(v_5, l7minusl6, twotimes_l5minusl8);
-     /* d */
-     const vector signed short ddiff = vec_sub(absmE,
-                                               vec_min(vec_abs(lE),
-                                                       vec_abs(rE)));
-     const vector signed short ddiffclamp = vec_max(ddiff, (vector signed short)zero);
-     const vector signed short dtimes64 = vec_mladd(v_5, ddiffclamp, v_32);
-     const vector signed short d = vec_sra(dtimes64, vec_splat_u16(6));
-     const vector signed short minusd = vec_sub((vector signed short)zero, d);
-     const vector signed short finald = vec_sel(minusd,
-                                                d,
-                                                vec_cmpgt(vec_sub((vector signed short)zero, mE),
-                                                          (vector signed short)zero));
-     /* q */
-     const vector signed short qtimes2 = vec_sub(vb4, vb5);
-     /* for a shift right to behave like /2, we need to add one
-        to all negative integer */
-     const vector signed short rounddown = vec_sel((vector signed short)zero,
-                                                   v_1,
-                                                   vec_cmplt(qtimes2, (vector signed short)zero));
-     const vector signed short q = vec_sra(vec_add(qtimes2, rounddown), vec_splat_u16(1));
-     /* clamp */
-     const vector signed short dclamp_P1 = vec_max((vector signed short)zero, finald);
-     const vector signed short dclamp_P = vec_min(dclamp_P1, q);
-     const vector signed short dclamp_N1 = vec_min((vector signed short)zero, finald);
-     const vector signed short dclamp_N = vec_max(dclamp_N1, q);
-
-     const vector signed short dclampedfinal = vec_sel(dclamp_N,
-                                                       dclamp_P,
-                                                       vec_cmpgt(q, (vector signed short)zero));
-     const vector signed short dornotd = vec_sel((vector signed short)zero,
-                                                 dclampedfinal,
-                                                 vec_cmplt(absmE, vqp));
-     /* add/subtract to l4 and l5 */
-     const vector signed short vb4minusd = vec_sub(vb4, dornotd);
-     const vector signed short vb5plusd  = vec_add(vb5, dornotd);
-     /* finally, stores */
-     const vector unsigned char st4 = vec_packsu(vb4minusd, (vector signed short)zero);
-     const vector unsigned char st5 = vec_packsu(vb5plusd,  (vector signed short)zero);
-
-     const vector signed char neg1 = vec_splat_s8(-1);
-     const vector unsigned char permHH = (const vector unsigned char){0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
-                                                                      0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F};
-
-#define STORE(i)                                                \
-{    const vector unsigned char perms##i =                      \
-         vec_lvsr(i * stride, src2);                            \
-     const vector unsigned char vg##i =                         \
-         vec_perm(st##i, vbT##i, permHH);                       \
-     const vector unsigned char mask##i =                       \
-         vec_perm((vector unsigned char)zero, (vector unsigned char)neg1, perms##i); \
-     const vector unsigned char vg2##i =                        \
-         vec_perm(vg##i, vg##i, perms##i);                      \
-     const vector unsigned char svA##i =                        \
-         vec_sel(vbA##i, vg2##i, mask##i);                      \
-     const vector unsigned char svB##i =                        \
-         vec_sel(vg2##i, vbB##i, mask##i);                      \
-     vec_st(svA##i, i * stride, src2);                          \
-     vec_st(svB##i, i * stride + 16, src2);}
-
-     STORE(4)
-     STORE(5)
-}
-
-static inline void dering_altivec(uint8_t src[], int stride, PPContext *c) {
-    const vector signed int vsint32_8 = vec_splat_s32(8);
-    const vector unsigned int vuint32_4 = vec_splat_u32(4);
-    const vector signed char neg1 = vec_splat_s8(-1);
-
-    const vector unsigned char permA1 = (vector unsigned char)
-        {0x00, 0x01, 0x02, 0x10, 0x11, 0x12, 0x1F, 0x1F,
-         0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F};
-    const vector unsigned char permA2 = (vector unsigned char)
-        {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x10, 0x11,
-         0x12, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F};
-    const vector unsigned char permA1inc = (vector unsigned char)
-        {0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
-         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
-    const vector unsigned char permA2inc = (vector unsigned char)
-        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
-         0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
-    const vector unsigned char magic = (vector unsigned char)
-        {0x01, 0x02, 0x01, 0x02, 0x04, 0x02, 0x01, 0x02,
-         0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
-    const vector unsigned char extractPerm = (vector unsigned char)
-        {0x10, 0x10, 0x10, 0x01, 0x10, 0x10, 0x10, 0x01,
-         0x10, 0x10, 0x10, 0x01, 0x10, 0x10, 0x10, 0x01};
-    const vector unsigned char extractPermInc = (vector unsigned char)
-        {0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
-         0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01};
-    const vector unsigned char identity = vec_lvsl(0,(unsigned char *)0);
-    const vector unsigned char tenRight = (vector unsigned char)
-        {0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
-    const vector unsigned char eightLeft = (vector unsigned char)
-        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08};
-
-    /*
-    this code makes no assumption on src or stride.
-    One could remove the recomputation of the perm
-    vector by assuming (stride % 16) == 0, unfortunately
-    this is not always true. Quite a lot of load/stores
-    can be removed by assuming proper alignment of
-    src & stride :-(
-    */
-    uint8_t *srcCopy = src;
-    DECLARE_ALIGNED(16, uint8_t, dt)[16] = { deringThreshold };
-    const vector signed int zero = vec_splat_s32(0);
-    vector unsigned char v_dt = vec_splat(vec_ld(0, dt), 0);
-
-#define LOAD_LINE(i)                                                  \
-    const vector unsigned char perm##i =                              \
-        vec_lvsl(i * stride, srcCopy);                                \
-    vector unsigned char sA##i = vec_ld(i * stride, srcCopy);         \
-    vector unsigned char sB##i = vec_ld(i * stride + 16, srcCopy);    \
-    vector unsigned char src##i = vec_perm(sA##i, sB##i, perm##i)
-
-    LOAD_LINE(0);
-    LOAD_LINE(1);
-    LOAD_LINE(2);
-    LOAD_LINE(3);
-    LOAD_LINE(4);
-    LOAD_LINE(5);
-    LOAD_LINE(6);
-    LOAD_LINE(7);
-    LOAD_LINE(8);
-    LOAD_LINE(9);
-#undef LOAD_LINE
-
-    vector unsigned char v_avg;
-    DECLARE_ALIGNED(16, signed int, S)[8];
-    DECLARE_ALIGNED(16, int, tQP2)[4] = { c->QP/2 + 1 };
-    vector signed int vQP2 = vec_ld(0, tQP2);
-    vQP2 = vec_splat(vQP2, 0);
-
-    {
-    const vector unsigned char trunc_perm = (vector unsigned char)
-        {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
-         0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18};
-    const vector unsigned char trunc_src12 = vec_perm(src1, src2, trunc_perm);
-    const vector unsigned char trunc_src34 = vec_perm(src3, src4, trunc_perm);
-    const vector unsigned char trunc_src56 = vec_perm(src5, src6, trunc_perm);
-    const vector unsigned char trunc_src78 = vec_perm(src7, src8, trunc_perm);
-
-#define EXTRACT(op) do {                                                \
-    const vector unsigned char s_1   = vec_##op(trunc_src12, trunc_src34); \
-    const vector unsigned char s_2   = vec_##op(trunc_src56, trunc_src78); \
-    const vector unsigned char s_6   = vec_##op(s_1, s_2);     \
-    const vector unsigned char s_8h  = vec_mergeh(s_6, s_6);   \
-    const vector unsigned char s_8l  = vec_mergel(s_6, s_6);   \
-    const vector unsigned char s_9   = vec_##op(s_8h, s_8l);   \
-    const vector unsigned char s_9h  = vec_mergeh(s_9, s_9);   \
-    const vector unsigned char s_9l  = vec_mergel(s_9, s_9);   \
-    const vector unsigned char s_10  = vec_##op(s_9h, s_9l);   \
-    const vector unsigned char s_10h = vec_mergeh(s_10, s_10); \
-    const vector unsigned char s_10l = vec_mergel(s_10, s_10); \
-    const vector unsigned char s_11  = vec_##op(s_10h, s_10l); \
-    const vector unsigned char s_11h = vec_mergeh(s_11, s_11); \
-    const vector unsigned char s_11l = vec_mergel(s_11, s_11); \
-    v_##op = vec_##op(s_11h, s_11l);                           \
-} while (0)
-
-    vector unsigned char v_min;
-    vector unsigned char v_max;
-    EXTRACT(min);
-    EXTRACT(max);
-#undef EXTRACT
-
-    if (vec_all_lt(vec_sub(v_max, v_min), v_dt))
-        return;
-
-    v_avg = vec_avg(v_min, v_max);
-    }
-
-    {
-    const vector unsigned short mask1 = (vector unsigned short)
-                                        {0x0001, 0x0002, 0x0004, 0x0008,
-                                         0x0010, 0x0020, 0x0040, 0x0080};
-    const vector unsigned short mask2 = (vector unsigned short)
-                                        {0x0100, 0x0200, 0x0000, 0x0000,
-                                         0x0000, 0x0000, 0x0000, 0x0000};
-
-    const vector unsigned int vuint32_16 = vec_sl(vec_splat_u32(1), vec_splat_u32(4));
-    const vector unsigned int vuint32_1 = vec_splat_u32(1);
-
-    vector signed int sumA2;
-    vector signed int sumB2;
-    vector signed int sum0, sum1, sum2, sum3, sum4;
-    vector signed int sum5, sum6, sum7, sum8, sum9;
-
-#define COMPARE(i)                                                      \
-    do {                                                                \
-        const vector unsigned char cmp =                                \
-            (vector unsigned char)vec_cmpgt(src##i, v_avg);             \
-        const vector unsigned short cmpHi =                             \
-            (vector unsigned short)vec_mergeh(cmp, cmp);                \
-        const vector unsigned short cmpLi =                             \
-            (vector unsigned short)vec_mergel(cmp, cmp);                \
-        const vector signed short cmpHf =                               \
-            (vector signed short)vec_and(cmpHi, mask1);                 \
-        const vector signed short cmpLf =                               \
-            (vector signed short)vec_and(cmpLi, mask2);                 \
-        const vector signed int sump = vec_sum4s(cmpHf, zero);          \
-        const vector signed int sumq = vec_sum4s(cmpLf, sump);          \
-        sum##i  = vec_sums(sumq, zero);                                 \
-    } while (0)
-
-    COMPARE(0);
-    COMPARE(1);
-    COMPARE(2);
-    COMPARE(3);
-    COMPARE(4);
-    COMPARE(5);
-    COMPARE(6);
-    COMPARE(7);
-    COMPARE(8);
-    COMPARE(9);
-#undef COMPARE
-
-    {
-    const vector signed int sump02 = vec_mergel(sum0, sum2);
-    const vector signed int sump13 = vec_mergel(sum1, sum3);
-    const vector signed int sumA = vec_mergel(sump02, sump13);
-
-    const vector signed int sump46 = vec_mergel(sum4, sum6);
-    const vector signed int sump57 = vec_mergel(sum5, sum7);
-    const vector signed int sumB = vec_mergel(sump46, sump57);
-
-    const vector signed int sump8A = vec_mergel(sum8, zero);
-    const vector signed int sump9B = vec_mergel(sum9, zero);
-    const vector signed int sumC = vec_mergel(sump8A, sump9B);
-
-    const vector signed int tA = vec_sl(vec_nor(zero, sumA), vuint32_16);
-    const vector signed int tB = vec_sl(vec_nor(zero, sumB), vuint32_16);
-    const vector signed int tC = vec_sl(vec_nor(zero, sumC), vuint32_16);
-    const vector signed int t2A = vec_or(sumA, tA);
-    const vector signed int t2B = vec_or(sumB, tB);
-    const vector signed int t2C = vec_or(sumC, tC);
-    const vector signed int t3A = vec_and(vec_sra(t2A, vuint32_1),
-                                          vec_sl(t2A, vuint32_1));
-    const vector signed int t3B = vec_and(vec_sra(t2B, vuint32_1),
-                                          vec_sl(t2B, vuint32_1));
-    const vector signed int t3C = vec_and(vec_sra(t2C, vuint32_1),
-                                          vec_sl(t2C, vuint32_1));
-    const vector signed int yA = vec_and(t2A, t3A);
-    const vector signed int yB = vec_and(t2B, t3B);
-    const vector signed int yC = vec_and(t2C, t3C);
-
-    const vector unsigned char strangeperm1 = vec_lvsl(4, (unsigned char*)0);
-    const vector unsigned char strangeperm2 = vec_lvsl(8, (unsigned char*)0);
-    const vector signed int sumAd4 = vec_perm(yA, yB, strangeperm1);
-    const vector signed int sumAd8 = vec_perm(yA, yB, strangeperm2);
-    const vector signed int sumBd4 = vec_perm(yB, yC, strangeperm1);
-    const vector signed int sumBd8 = vec_perm(yB, yC, strangeperm2);
-    const vector signed int sumAp = vec_and(yA,
-                                            vec_and(sumAd4,sumAd8));
-    const vector signed int sumBp = vec_and(yB,
-                                            vec_and(sumBd4,sumBd8));
-    sumA2 = vec_or(sumAp,
-                   vec_sra(sumAp,
-                           vuint32_16));
-    sumB2  = vec_or(sumBp,
-                    vec_sra(sumBp,
-                            vuint32_16));
-    }
-    vec_st(sumA2, 0, S);
-    vec_st(sumB2, 16, S);
-    }
-
-    /* I'm not sure the following is actually faster
-       than straight, unvectorized C code :-( */
-
-#define F_INIT()                                       \
-    vector unsigned char tenRightM = tenRight;         \
-    vector unsigned char permA1M = permA1;             \
-    vector unsigned char permA2M = permA2;             \
-    vector unsigned char extractPermM = extractPerm
-
-#define F2(i, j, k, l)                                                  \
-    if (S[i] & (1 << (l+1))) {                                          \
-        const vector unsigned char a_A = vec_perm(src##i, src##j, permA1M); \
-        const vector unsigned char a_B = vec_perm(a_A, src##k, permA2M); \
-        const vector signed int a_sump =                                \
-            (vector signed int)vec_msum(a_B, magic, (vector unsigned int)zero);\
-        vector signed int F = vec_sr(vec_sums(a_sump, vsint32_8), vuint32_4); \
-        const vector signed int p =                                     \
-            (vector signed int)vec_perm(src##j, (vector unsigned char)zero, \
-                                        extractPermM);                  \
-        const vector signed int sum  = vec_add(p, vQP2);                \
-        const vector signed int diff = vec_sub(p, vQP2);                \
-        vector signed int newpm;                                        \
-        vector unsigned char newpm2, mask;                              \
-        F = vec_splat(F, 3);                                            \
-        if (vec_all_lt(sum, F))                                         \
-            newpm = sum;                                                \
-        else if (vec_all_gt(diff, F))                                   \
-            newpm = diff;                                               \
-        else newpm = F;                                                 \
-        newpm2 = vec_splat((vector unsigned char)newpm, 15);            \
-        mask = vec_add(identity, tenRightM);                            \
-        src##j = vec_perm(src##j, newpm2, mask);                        \
-    }                                                                   \
-    permA1M = vec_add(permA1M, permA1inc);                              \
-    permA2M = vec_add(permA2M, permA2inc);                              \
-    tenRightM = vec_sro(tenRightM, eightLeft);                          \
-    extractPermM = vec_add(extractPermM, extractPermInc)
-
-#define ITER(i, j, k) do {                      \
-    F_INIT();                                   \
-    F2(i, j, k, 0);                             \
-    F2(i, j, k, 1);                             \
-    F2(i, j, k, 2);                             \
-    F2(i, j, k, 3);                             \
-    F2(i, j, k, 4);                             \
-    F2(i, j, k, 5);                             \
-    F2(i, j, k, 6);                             \
-    F2(i, j, k, 7);                             \
-} while (0)
-
-    ITER(0, 1, 2);
-    ITER(1, 2, 3);
-    ITER(2, 3, 4);
-    ITER(3, 4, 5);
-    ITER(4, 5, 6);
-    ITER(5, 6, 7);
-    ITER(6, 7, 8);
-    ITER(7, 8, 9);
-
-#define STORE_LINE(i) do {                              \
-    const vector unsigned char permST =                 \
-        vec_lvsr(i * stride, srcCopy);                  \
-    const vector unsigned char maskST =                 \
-        vec_perm((vector unsigned char)zero,            \
-                 (vector unsigned char)neg1, permST);   \
-    src##i = vec_perm(src##i ,src##i, permST);          \
-    sA##i= vec_sel(sA##i, src##i, maskST);              \
-    sB##i= vec_sel(src##i, sB##i, maskST);              \
-    vec_st(sA##i, i * stride, srcCopy);                 \
-    vec_st(sB##i, i * stride + 16, srcCopy);            \
-} while (0)
-
-    STORE_LINE(1);
-    STORE_LINE(2);
-    STORE_LINE(3);
-    STORE_LINE(4);
-    STORE_LINE(5);
-    STORE_LINE(6);
-    STORE_LINE(7);
-    STORE_LINE(8);
-
-#undef STORE_LINE
-#undef ITER
-#undef F2
-}
-
-#define doHorizLowPass_altivec(a...) doHorizLowPass_C(a)
-#define doHorizDefFilter_altivec(a...) doHorizDefFilter_C(a)
-#define do_a_deblock_altivec(a...) do_a_deblock_C(a)
-
-static inline void tempNoiseReducer_altivec(uint8_t *src, int stride,
-                                            uint8_t *tempBlurred, uint32_t *tempBlurredPast, int *maxNoise)
-{
-    const vector signed char neg1 = vec_splat_s8(-1);
-    const vector unsigned char permHH = (const vector unsigned char){0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
-                                                                     0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F};
-
-    const vector signed int zero = vec_splat_s32(0);
-    const vector signed short vsint16_1 = vec_splat_s16(1);
-    vector signed int v_dp = zero;
-    vector signed int v_sysdp = zero;
-    int d, sysd, i;
-
-#define LOAD_LINE(src, i)                                               \
-    register int j##src##i = i * stride;                                \
-    vector unsigned char perm##src##i = vec_lvsl(j##src##i, src);       \
-    const vector unsigned char v_##src##A1##i = vec_ld(j##src##i, src); \
-    const vector unsigned char v_##src##A2##i = vec_ld(j##src##i + 16, src); \
-    const vector unsigned char v_##src##A##i =                          \
-        vec_perm(v_##src##A1##i, v_##src##A2##i, perm##src##i);         \
-    vector signed short v_##src##Ass##i =                               \
-        (vector signed short)vec_mergeh((vector signed char)zero,       \
-                                        (vector signed char)v_##src##A##i)
-
-    LOAD_LINE(src, 0);
-    LOAD_LINE(src, 1);
-    LOAD_LINE(src, 2);
-    LOAD_LINE(src, 3);
-    LOAD_LINE(src, 4);
-    LOAD_LINE(src, 5);
-    LOAD_LINE(src, 6);
-    LOAD_LINE(src, 7);
-
-    LOAD_LINE(tempBlurred, 0);
-    LOAD_LINE(tempBlurred, 1);
-    LOAD_LINE(tempBlurred, 2);
-    LOAD_LINE(tempBlurred, 3);
-    LOAD_LINE(tempBlurred, 4);
-    LOAD_LINE(tempBlurred, 5);
-    LOAD_LINE(tempBlurred, 6);
-    LOAD_LINE(tempBlurred, 7);
-#undef LOAD_LINE
-
-#define ACCUMULATE_DIFFS(i) do {                                \
-        vector signed short v_d = vec_sub(v_tempBlurredAss##i,  \
-                                          v_srcAss##i);         \
-        v_dp = vec_msums(v_d, v_d, v_dp);                       \
-        v_sysdp = vec_msums(v_d, vsint16_1, v_sysdp);           \
-    } while (0)
-
-    ACCUMULATE_DIFFS(0);
-    ACCUMULATE_DIFFS(1);
-    ACCUMULATE_DIFFS(2);
-    ACCUMULATE_DIFFS(3);
-    ACCUMULATE_DIFFS(4);
-    ACCUMULATE_DIFFS(5);
-    ACCUMULATE_DIFFS(6);
-    ACCUMULATE_DIFFS(7);
-#undef ACCUMULATE_DIFFS
-
-    tempBlurredPast[127]= maxNoise[0];
-    tempBlurredPast[128]= maxNoise[1];
-    tempBlurredPast[129]= maxNoise[2];
-
-    v_dp = vec_sums(v_dp, zero);
-    v_sysdp = vec_sums(v_sysdp, zero);
-
-    v_dp = vec_splat(v_dp, 3);
-    v_sysdp = vec_splat(v_sysdp, 3);
-
-    vec_ste(v_dp, 0, &d);
-    vec_ste(v_sysdp, 0, &sysd);
-
-    i = d;
-    d = (4*d
-         +(*(tempBlurredPast-256))
-         +(*(tempBlurredPast-1))+ (*(tempBlurredPast+1))
-         +(*(tempBlurredPast+256))
-         +4)>>3;
-
-    *tempBlurredPast=i;
-
-    if (d > maxNoise[1]) {
-        if (d < maxNoise[2]) {
-#define OP(i) v_tempBlurredAss##i = vec_avg(v_tempBlurredAss##i, v_srcAss##i);
-
-            OP(0);
-            OP(1);
-            OP(2);
-            OP(3);
-            OP(4);
-            OP(5);
-            OP(6);
-            OP(7);
-#undef OP
-        } else {
-#define OP(i) v_tempBlurredAss##i = v_srcAss##i;
-
-            OP(0);
-            OP(1);
-            OP(2);
-            OP(3);
-            OP(4);
-            OP(5);
-            OP(6);
-            OP(7);
-#undef OP
-        }
-    } else {
-        if (d < maxNoise[0]) {
-            const vector signed short vsint16_7 = vec_splat_s16(7);
-            const vector signed short vsint16_4 = vec_splat_s16(4);
-            const vector unsigned short vuint16_3 = vec_splat_u16(3);
-
-#define OP(i) do {                                                      \
-            const vector signed short v_temp =                          \
-                vec_mladd(v_tempBlurredAss##i, vsint16_7, v_srcAss##i); \
-            const vector signed short v_temp2 = vec_add(v_temp, vsint16_4); \
-            v_tempBlurredAss##i = vec_sr(v_temp2, vuint16_3);           \
-        } while (0)
-
-            OP(0);
-            OP(1);
-            OP(2);
-            OP(3);
-            OP(4);
-            OP(5);
-            OP(6);
-            OP(7);
-#undef OP
-        } else {
-            const vector signed short vsint16_3 = vec_splat_s16(3);
-            const vector signed short vsint16_2 = vec_splat_s16(2);
-
-#define OP(i) do {                                              \
-            const vector signed short v_temp =                  \
-                vec_mladd(v_tempBlurredAss##i, vsint16_3, v_srcAss##i); \
-            const vector signed short v_temp2 = vec_add(v_temp, vsint16_2); \
-            v_tempBlurredAss##i =                                       \
-                vec_sr(v_temp2, (vector unsigned short)vsint16_2);      \
-        } while (0)
-
-            OP(0);
-            OP(1);
-            OP(2);
-            OP(3);
-            OP(4);
-            OP(5);
-            OP(6);
-            OP(7);
-#undef OP
-        }
-    }
-
-#define PACK_AND_STORE(src, i) do {                                      \
-    const vector unsigned char perms = vec_lvsr(i * stride, src);        \
-    const vector unsigned char vf =                                      \
-        vec_packsu(v_tempBlurredAss##1, (vector signed short)zero);     \
-    const vector unsigned char vg = vec_perm(vf, v_##src##A##i, permHH); \
-    const vector unsigned char mask =                                    \
-        vec_perm((vector unsigned char)zero, (vector unsigned char)neg1, perms); \
-    const vector unsigned char vg2 = vec_perm(vg, vg, perms);            \
-    const vector unsigned char svA = vec_sel(v_##src##A1##i, vg2, mask); \
-    const vector unsigned char svB = vec_sel(vg2, v_##src##A2##i, mask); \
-    vec_st(svA, i * stride, src);                                        \
-    vec_st(svB, i * stride + 16, src);                                   \
-} while (0)
-
-    PACK_AND_STORE(src, 0);
-    PACK_AND_STORE(src, 1);
-    PACK_AND_STORE(src, 2);
-    PACK_AND_STORE(src, 3);
-    PACK_AND_STORE(src, 4);
-    PACK_AND_STORE(src, 5);
-    PACK_AND_STORE(src, 6);
-    PACK_AND_STORE(src, 7);
-    PACK_AND_STORE(tempBlurred, 0);
-    PACK_AND_STORE(tempBlurred, 1);
-    PACK_AND_STORE(tempBlurred, 2);
-    PACK_AND_STORE(tempBlurred, 3);
-    PACK_AND_STORE(tempBlurred, 4);
-    PACK_AND_STORE(tempBlurred, 5);
-    PACK_AND_STORE(tempBlurred, 6);
-    PACK_AND_STORE(tempBlurred, 7);
-#undef PACK_AND_STORE
-}
-
-static inline void transpose_16x8_char_toPackedAlign_altivec(unsigned char* dst, unsigned char* src, int stride) {
-    const vector unsigned char zero = vec_splat_u8(0);
-
-#define LOAD_DOUBLE_LINE(i, j)                                          \
-    vector unsigned char perm1##i = vec_lvsl(i * stride, src);          \
-    vector unsigned char perm2##i = vec_lvsl(j * stride, src);          \
-    vector unsigned char srcA##i = vec_ld(i * stride, src);             \
-    vector unsigned char srcB##i = vec_ld(i * stride + 16, src);        \
-    vector unsigned char srcC##i = vec_ld(j * stride, src);             \
-    vector unsigned char srcD##i = vec_ld(j * stride+ 16, src);         \
-    vector unsigned char src##i = vec_perm(srcA##i, srcB##i, perm1##i); \
-    vector unsigned char src##j = vec_perm(srcC##i, srcD##i, perm2##i)
-
-    LOAD_DOUBLE_LINE(0, 1);
-    LOAD_DOUBLE_LINE(2, 3);
-    LOAD_DOUBLE_LINE(4, 5);
-    LOAD_DOUBLE_LINE(6, 7);
-#undef LOAD_DOUBLE_LINE
-
-    vector unsigned char tempA = vec_mergeh(src0, zero);
-    vector unsigned char tempB = vec_mergel(src0, zero);
-    vector unsigned char tempC = vec_mergeh(src1, zero);
-    vector unsigned char tempD = vec_mergel(src1, zero);
-    vector unsigned char tempE = vec_mergeh(src2, zero);
-    vector unsigned char tempF = vec_mergel(src2, zero);
-    vector unsigned char tempG = vec_mergeh(src3, zero);
-    vector unsigned char tempH = vec_mergel(src3, zero);
-    vector unsigned char tempI = vec_mergeh(src4, zero);
-    vector unsigned char tempJ = vec_mergel(src4, zero);
-    vector unsigned char tempK = vec_mergeh(src5, zero);
-    vector unsigned char tempL = vec_mergel(src5, zero);
-    vector unsigned char tempM = vec_mergeh(src6, zero);
-    vector unsigned char tempN = vec_mergel(src6, zero);
-    vector unsigned char tempO = vec_mergeh(src7, zero);
-    vector unsigned char tempP = vec_mergel(src7, zero);
-
-    vector unsigned char temp0  = vec_mergeh(tempA, tempI);
-    vector unsigned char temp1  = vec_mergel(tempA, tempI);
-    vector unsigned char temp2  = vec_mergeh(tempB, tempJ);
-    vector unsigned char temp3  = vec_mergel(tempB, tempJ);
-    vector unsigned char temp4  = vec_mergeh(tempC, tempK);
-    vector unsigned char temp5  = vec_mergel(tempC, tempK);
-    vector unsigned char temp6  = vec_mergeh(tempD, tempL);
-    vector unsigned char temp7  = vec_mergel(tempD, tempL);
-    vector unsigned char temp8  = vec_mergeh(tempE, tempM);
-    vector unsigned char temp9  = vec_mergel(tempE, tempM);
-    vector unsigned char temp10 = vec_mergeh(tempF, tempN);
-    vector unsigned char temp11 = vec_mergel(tempF, tempN);
-    vector unsigned char temp12 = vec_mergeh(tempG, tempO);
-    vector unsigned char temp13 = vec_mergel(tempG, tempO);
-    vector unsigned char temp14 = vec_mergeh(tempH, tempP);
-    vector unsigned char temp15 = vec_mergel(tempH, tempP);
-
-    tempA = vec_mergeh(temp0, temp8);
-    tempB = vec_mergel(temp0, temp8);
-    tempC = vec_mergeh(temp1, temp9);
-    tempD = vec_mergel(temp1, temp9);
-    tempE = vec_mergeh(temp2, temp10);
-    tempF = vec_mergel(temp2, temp10);
-    tempG = vec_mergeh(temp3, temp11);
-    tempH = vec_mergel(temp3, temp11);
-    tempI = vec_mergeh(temp4, temp12);
-    tempJ = vec_mergel(temp4, temp12);
-    tempK = vec_mergeh(temp5, temp13);
-    tempL = vec_mergel(temp5, temp13);
-    tempM = vec_mergeh(temp6, temp14);
-    tempN = vec_mergel(temp6, temp14);
-    tempO = vec_mergeh(temp7, temp15);
-    tempP = vec_mergel(temp7, temp15);
-
-    temp0  = vec_mergeh(tempA, tempI);
-    temp1  = vec_mergel(tempA, tempI);
-    temp2  = vec_mergeh(tempB, tempJ);
-    temp3  = vec_mergel(tempB, tempJ);
-    temp4  = vec_mergeh(tempC, tempK);
-    temp5  = vec_mergel(tempC, tempK);
-    temp6  = vec_mergeh(tempD, tempL);
-    temp7  = vec_mergel(tempD, tempL);
-    temp8  = vec_mergeh(tempE, tempM);
-    temp9  = vec_mergel(tempE, tempM);
-    temp10 = vec_mergeh(tempF, tempN);
-    temp11 = vec_mergel(tempF, tempN);
-    temp12 = vec_mergeh(tempG, tempO);
-    temp13 = vec_mergel(tempG, tempO);
-    temp14 = vec_mergeh(tempH, tempP);
-    temp15 = vec_mergel(tempH, tempP);
-
-    vec_st(temp0,    0, dst);
-    vec_st(temp1,   16, dst);
-    vec_st(temp2,   32, dst);
-    vec_st(temp3,   48, dst);
-    vec_st(temp4,   64, dst);
-    vec_st(temp5,   80, dst);
-    vec_st(temp6,   96, dst);
-    vec_st(temp7,  112, dst);
-    vec_st(temp8,  128, dst);
-    vec_st(temp9,  144, dst);
-    vec_st(temp10, 160, dst);
-    vec_st(temp11, 176, dst);
-    vec_st(temp12, 192, dst);
-    vec_st(temp13, 208, dst);
-    vec_st(temp14, 224, dst);
-    vec_st(temp15, 240, dst);
-}
-
-static inline void transpose_8x16_char_fromPackedAlign_altivec(unsigned char* dst, unsigned char* src, int stride) {
-    const vector unsigned char zero = vec_splat_u8(0);
-    const vector signed   char neg1 = vec_splat_s8(-1);
-
-#define LOAD_DOUBLE_LINE(i, j)                                  \
-    vector unsigned char src##i = vec_ld(i * 16, src);            \
-    vector unsigned char src##j = vec_ld(j * 16, src)
-
-    LOAD_DOUBLE_LINE(0, 1);
-    LOAD_DOUBLE_LINE(2, 3);
-    LOAD_DOUBLE_LINE(4, 5);
-    LOAD_DOUBLE_LINE(6, 7);
-    LOAD_DOUBLE_LINE(8, 9);
-    LOAD_DOUBLE_LINE(10, 11);
-    LOAD_DOUBLE_LINE(12, 13);
-    LOAD_DOUBLE_LINE(14, 15);
-#undef LOAD_DOUBLE_LINE
-
-    vector unsigned char tempA = vec_mergeh(src0, src8);
-    vector unsigned char tempB;
-    vector unsigned char tempC = vec_mergeh(src1, src9);
-    vector unsigned char tempD;
-    vector unsigned char tempE = vec_mergeh(src2, src10);
-    vector unsigned char tempG = vec_mergeh(src3, src11);
-    vector unsigned char tempI = vec_mergeh(src4, src12);
-    vector unsigned char tempJ;
-    vector unsigned char tempK = vec_mergeh(src5, src13);
-    vector unsigned char tempL;
-    vector unsigned char tempM = vec_mergeh(src6, src14);
-    vector unsigned char tempO = vec_mergeh(src7, src15);
-
-    vector unsigned char temp0 = vec_mergeh(tempA, tempI);
-    vector unsigned char temp1 = vec_mergel(tempA, tempI);
-    vector unsigned char temp2;
-    vector unsigned char temp3;
-    vector unsigned char temp4 = vec_mergeh(tempC, tempK);
-    vector unsigned char temp5 = vec_mergel(tempC, tempK);
-    vector unsigned char temp6;
-    vector unsigned char temp7;
-    vector unsigned char temp8 = vec_mergeh(tempE, tempM);
-    vector unsigned char temp9 = vec_mergel(tempE, tempM);
-    vector unsigned char temp12 = vec_mergeh(tempG, tempO);
-    vector unsigned char temp13 = vec_mergel(tempG, tempO);
-
-    tempA = vec_mergeh(temp0, temp8);
-    tempB = vec_mergel(temp0, temp8);
-    tempC = vec_mergeh(temp1, temp9);
-    tempD = vec_mergel(temp1, temp9);
-    tempI = vec_mergeh(temp4, temp12);
-    tempJ = vec_mergel(temp4, temp12);
-    tempK = vec_mergeh(temp5, temp13);
-    tempL = vec_mergel(temp5, temp13);
-
-    temp0 = vec_mergeh(tempA, tempI);
-    temp1 = vec_mergel(tempA, tempI);
-    temp2 = vec_mergeh(tempB, tempJ);
-    temp3 = vec_mergel(tempB, tempJ);
-    temp4 = vec_mergeh(tempC, tempK);
-    temp5 = vec_mergel(tempC, tempK);
-    temp6 = vec_mergeh(tempD, tempL);
-    temp7 = vec_mergel(tempD, tempL);
-
-
-#define STORE_DOUBLE_LINE(i, j) do {                                    \
-    vector unsigned char dstAi = vec_ld(i * stride, dst);               \
-    vector unsigned char dstBi = vec_ld(i * stride + 16, dst);          \
-    vector unsigned char dstAj = vec_ld(j * stride, dst);               \
-    vector unsigned char dstBj = vec_ld(j * stride+ 16, dst);           \
-    vector unsigned char aligni = vec_lvsr(i * stride, dst);            \
-    vector unsigned char alignj = vec_lvsr(j * stride, dst);            \
-    vector unsigned char maski =                                        \
-        vec_perm(zero, (vector unsigned char)neg1, aligni);             \
-    vector unsigned char maskj =                                        \
-        vec_perm(zero, (vector unsigned char)neg1, alignj);             \
-    vector unsigned char dstRi = vec_perm(temp##i, temp##i, aligni);    \
-    vector unsigned char dstRj = vec_perm(temp##j, temp##j, alignj);    \
-    vector unsigned char dstAFi = vec_sel(dstAi, dstRi, maski);         \
-    vector unsigned char dstBFi = vec_sel(dstRi, dstBi, maski);         \
-    vector unsigned char dstAFj = vec_sel(dstAj, dstRj, maskj);         \
-    vector unsigned char dstBFj = vec_sel(dstRj, dstBj, maskj);         \
-    vec_st(dstAFi, i * stride, dst);                                    \
-    vec_st(dstBFi, i * stride + 16, dst);                               \
-    vec_st(dstAFj, j * stride, dst);                                    \
-    vec_st(dstBFj, j * stride + 16, dst);                               \
-} while (0)
-
-    STORE_DOUBLE_LINE(0,1);
-    STORE_DOUBLE_LINE(2,3);
-    STORE_DOUBLE_LINE(4,5);
-    STORE_DOUBLE_LINE(6,7);
-}
diff --git a/libpostproc/postprocess_internal.h b/libpostproc/postprocess_internal.h
deleted file mode 100644
index b1b8f0c..0000000
--- a/libpostproc/postprocess_internal.h
+++ /dev/null
@@ -1,179 +0,0 @@
-/*
- * Copyright (C) 2001-2002 Michael Niedermayer (michaelni@gmx.at)
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * internal API header.
- */
-
-#ifndef POSTPROC_POSTPROCESS_INTERNAL_H
-#define POSTPROC_POSTPROCESS_INTERNAL_H
-
-#include <string.h>
-#include "libavutil/avutil.h"
-#include "libavutil/intmath.h"
-#include "libavutil/log.h"
-#include "postprocess.h"
-
-#define V_DEBLOCK       0x01
-#define H_DEBLOCK       0x02
-#define DERING          0x04
-#define LEVEL_FIX       0x08 ///< Brightness & Contrast
-
-#define LUM_V_DEBLOCK   V_DEBLOCK               //   1
-#define LUM_H_DEBLOCK   H_DEBLOCK               //   2
-#define CHROM_V_DEBLOCK (V_DEBLOCK<<4)          //  16
-#define CHROM_H_DEBLOCK (H_DEBLOCK<<4)          //  32
-#define LUM_DERING      DERING                  //   4
-#define CHROM_DERING    (DERING<<4)             //  64
-#define LUM_LEVEL_FIX   LEVEL_FIX               //   8
-#define CHROM_LEVEL_FIX (LEVEL_FIX<<4)          // 128 (not implemented yet)
-
-// Experimental vertical filters
-#define V_X1_FILTER     0x0200                  // 512
-#define V_A_DEBLOCK     0x0400
-
-// Experimental horizontal filters
-#define H_X1_FILTER     0x2000                  // 8192
-#define H_A_DEBLOCK     0x4000
-
-/// select between full y range (255-0) or standard one (234-16)
-#define FULL_Y_RANGE    0x8000                  // 32768
-
-//Deinterlacing Filters
-#define LINEAR_IPOL_DEINT_FILTER        0x10000 // 65536
-#define LINEAR_BLEND_DEINT_FILTER       0x20000 // 131072
-#define CUBIC_BLEND_DEINT_FILTER        0x8000  // (not implemented yet)
-#define CUBIC_IPOL_DEINT_FILTER         0x40000 // 262144
-#define MEDIAN_DEINT_FILTER             0x80000 // 524288
-#define FFMPEG_DEINT_FILTER             0x400000
-#define LOWPASS5_DEINT_FILTER           0x800000
-
-#define TEMP_NOISE_FILTER               0x100000
-#define FORCE_QUANT                     0x200000
-#define BITEXACT                        0x1000000
-
-//use if you want a faster postprocessing code
-//cannot differentiate between chroma & luma filters (both on or both off)
-//obviously the -pp option on the command line has no effect except turning the here selected
-//filters on
-//#define COMPILE_TIME_MODE 0x77
-
-#define CLIP av_clip_uint8
-
-/**
- * Postprocessing filter.
- */
-struct PPFilter{
-    const char *shortName;
-    const char *longName;
-    int chromDefault;       ///< is chrominance filtering on by default if this filter is manually activated
-    int minLumQuality;      ///< minimum quality to turn luminance filtering on
-    int minChromQuality;    ///< minimum quality to turn chrominance filtering on
-    int mask;               ///< Bitmask to turn this filter on
-};
-
-/**
- * Postprocessing mode.
- */
-typedef struct PPMode{
-    int lumMode;                    ///< activates filters for luminance
-    int chromMode;                  ///< activates filters for chrominance
-    int error;                      ///< non zero on error
-
-    int minAllowedY;                ///< for brightness correction
-    int maxAllowedY;                ///< for brightness correction
-    float maxClippedThreshold;      ///< amount of "black" you are willing to lose to get a brightness-corrected picture
-
-    int maxTmpNoise[3];             ///< for Temporal Noise Reducing filter (Maximal sum of abs differences)
-
-    int baseDcDiff;
-    int flatnessThreshold;
-
-    int forcedQuant;                ///< quantizer if FORCE_QUANT is used
-} PPMode;
-
-/**
- * postprocess context.
- */
-typedef struct PPContext{
-    /**
-     * info on struct for av_log
-     */
-    const AVClass *av_class;
-
-    uint8_t *tempBlocks; ///<used for the horizontal code
-
-    /**
-     * luma histogram.
-     * we need 64bit here otherwise we'll going to have a problem
-     * after watching a black picture for 5 hours
-     */
-    uint64_t *yHistogram;
-
-    DECLARE_ALIGNED(8, uint64_t, packedYOffset);
-    DECLARE_ALIGNED(8, uint64_t, packedYScale);
-
-    /** Temporal noise reducing buffers */
-    uint8_t *tempBlurred[3];
-    int32_t *tempBlurredPast[3];
-
-    /** Temporary buffers for handling the last row(s) */
-    uint8_t *tempDst;
-    uint8_t *tempSrc;
-
-    uint8_t *deintTemp;
-
-    DECLARE_ALIGNED(8, uint64_t, pQPb);
-    DECLARE_ALIGNED(8, uint64_t, pQPb2);
-
-    DECLARE_ALIGNED(8, uint64_t, mmxDcOffset)[64];
-    DECLARE_ALIGNED(8, uint64_t, mmxDcThreshold)[64];
-
-    QP_STORE_T *stdQPTable;       ///< used to fix MPEG2 style qscale
-    QP_STORE_T *nonBQPTable;
-    QP_STORE_T *forcedQPTable;
-
-    int QP;
-    int nonBQP;
-
-    int frameNum;
-
-    int cpuCaps;
-
-    int qpStride; ///<size of qp buffers (needed to realloc them if needed)
-    int stride;   ///<size of some buffers (needed to realloc them if needed)
-
-    int hChromaSubSample;
-    int vChromaSubSample;
-
-    PPMode ppMode;
-} PPContext;
-
-
-static inline void linecpy(void *dest, const void *src, int lines, int stride) {
-    if (stride > 0) {
-        memcpy(dest, src, lines*stride);
-    } else {
-        memcpy((uint8_t*)dest+(lines-1)*stride, (const uint8_t*)src+(lines-1)*stride, -lines*stride);
-    }
-}
-
-#endif /* POSTPROC_POSTPROCESS_INTERNAL_H */
diff --git a/libpostproc/postprocess_template.c b/libpostproc/postprocess_template.c
deleted file mode 100644
index 74b0ab4..0000000
--- a/libpostproc/postprocess_template.c
+++ /dev/null
@@ -1,3714 +0,0 @@
-/*
- * Copyright (C) 2001-2002 Michael Niedermayer (michaelni@gmx.at)
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * mmx/mmx2/3dnow postprocess code.
- */
-
-#include "libavutil/x86/asm.h"
-
-/* A single TEMPLATE_PP_* should be defined (to 1) when this template is
- * included. The following macros will define its dependencies to 1 as well
- * (like MMX2 depending on MMX), and will define to 0 all the others. Every
- * TEMPLATE_PP_* need to be undef at the end. */
-
-#ifdef TEMPLATE_PP_C
-#   define RENAME(a) a ## _C
-#else
-#   define TEMPLATE_PP_C 0
-#endif
-
-#ifdef TEMPLATE_PP_ALTIVEC
-#   define RENAME(a) a ## _altivec
-#else
-#   define TEMPLATE_PP_ALTIVEC 0
-#endif
-
-#ifdef TEMPLATE_PP_MMX
-#   define RENAME(a) a ## _MMX
-#else
-#   define TEMPLATE_PP_MMX 0
-#endif
-
-#ifdef TEMPLATE_PP_MMXEXT
-#   undef  TEMPLATE_PP_MMX
-#   define TEMPLATE_PP_MMX 1
-#   define RENAME(a) a ## _MMX2
-#else
-#   define TEMPLATE_PP_MMXEXT 0
-#endif
-
-#ifdef TEMPLATE_PP_3DNOW
-#   undef  TEMPLATE_PP_MMX
-#   define TEMPLATE_PP_MMX 1
-#   define RENAME(a) a ## _3DNow
-#else
-#   define TEMPLATE_PP_3DNOW 0
-#endif
-
-#ifdef TEMPLATE_PP_SSE2
-#   undef  TEMPLATE_PP_MMX
-#   define TEMPLATE_PP_MMX 1
-#   undef  TEMPLATE_PP_MMXEXT
-#   define TEMPLATE_PP_MMXEXT 1
-#   define RENAME(a) a ## _SSE2
-#else
-#   define TEMPLATE_PP_SSE2 0
-#endif
-
-#undef REAL_PAVGB
-#undef PAVGB
-#undef PMINUB
-#undef PMAXUB
-
-#if   TEMPLATE_PP_MMXEXT
-#define REAL_PAVGB(a,b) "pavgb " #a ", " #b " \n\t"
-#elif TEMPLATE_PP_3DNOW
-#define REAL_PAVGB(a,b) "pavgusb " #a ", " #b " \n\t"
-#endif
-#define PAVGB(a,b)  REAL_PAVGB(a,b)
-
-#if   TEMPLATE_PP_MMXEXT
-#define PMINUB(a,b,t) "pminub " #a ", " #b " \n\t"
-#elif TEMPLATE_PP_MMX
-#define PMINUB(b,a,t) \
-    "movq " #a ", " #t " \n\t"\
-    "psubusb " #b ", " #t " \n\t"\
-    "psubb " #t ", " #a " \n\t"
-#endif
-
-#if   TEMPLATE_PP_MMXEXT
-#define PMAXUB(a,b) "pmaxub " #a ", " #b " \n\t"
-#elif TEMPLATE_PP_MMX
-#define PMAXUB(a,b) \
-    "psubusb " #a ", " #b " \n\t"\
-    "paddb " #a ", " #b " \n\t"
-#endif
-
-//FIXME? |255-0| = 1 (should not be a problem ...)
-#if TEMPLATE_PP_MMX
-/**
- * Check if the middle 8x8 Block in the given 8x16 block is flat
- */
-static inline int RENAME(vertClassify)(uint8_t src[], int stride, PPContext *c){
-    int numEq= 0, dcOk;
-    src+= stride*4; // src points to begin of the 8x8 Block
-    __asm__ volatile(
-        "movq %0, %%mm7                         \n\t"
-        "movq %1, %%mm6                         \n\t"
-        : : "m" (c->mmxDcOffset[c->nonBQP]),  "m" (c->mmxDcThreshold[c->nonBQP])
-        );
-
-    __asm__ volatile(
-        "lea (%2, %3), %%"REG_a"                \n\t"
-//      0       1       2       3       4       5       6       7       8       9
-//      %1      eax     eax+%2  eax+2%2 %1+4%2  ecx     ecx+%2  ecx+2%2 %1+8%2  ecx+4%2
-
-        "movq (%2), %%mm0                       \n\t"
-        "movq (%%"REG_a"), %%mm1                \n\t"
-        "movq %%mm0, %%mm3                      \n\t"
-        "movq %%mm0, %%mm4                      \n\t"
-        PMAXUB(%%mm1, %%mm4)
-        PMINUB(%%mm1, %%mm3, %%mm5)
-        "psubb %%mm1, %%mm0                     \n\t" // mm0 = difference
-        "paddb %%mm7, %%mm0                     \n\t"
-        "pcmpgtb %%mm6, %%mm0                   \n\t"
-
-        "movq (%%"REG_a",%3), %%mm2             \n\t"
-        PMAXUB(%%mm2, %%mm4)
-        PMINUB(%%mm2, %%mm3, %%mm5)
-        "psubb %%mm2, %%mm1                     \n\t"
-        "paddb %%mm7, %%mm1                     \n\t"
-        "pcmpgtb %%mm6, %%mm1                   \n\t"
-        "paddb %%mm1, %%mm0                     \n\t"
-
-        "movq (%%"REG_a", %3, 2), %%mm1         \n\t"
-        PMAXUB(%%mm1, %%mm4)
-        PMINUB(%%mm1, %%mm3, %%mm5)
-        "psubb %%mm1, %%mm2                     \n\t"
-        "paddb %%mm7, %%mm2                     \n\t"
-        "pcmpgtb %%mm6, %%mm2                   \n\t"
-        "paddb %%mm2, %%mm0                     \n\t"
-
-        "lea (%%"REG_a", %3, 4), %%"REG_a"      \n\t"
-
-        "movq (%2, %3, 4), %%mm2                \n\t"
-        PMAXUB(%%mm2, %%mm4)
-        PMINUB(%%mm2, %%mm3, %%mm5)
-        "psubb %%mm2, %%mm1                     \n\t"
-        "paddb %%mm7, %%mm1                     \n\t"
-        "pcmpgtb %%mm6, %%mm1                   \n\t"
-        "paddb %%mm1, %%mm0                     \n\t"
-
-        "movq (%%"REG_a"), %%mm1                \n\t"
-        PMAXUB(%%mm1, %%mm4)
-        PMINUB(%%mm1, %%mm3, %%mm5)
-        "psubb %%mm1, %%mm2                     \n\t"
-        "paddb %%mm7, %%mm2                     \n\t"
-        "pcmpgtb %%mm6, %%mm2                   \n\t"
-        "paddb %%mm2, %%mm0                     \n\t"
-
-        "movq (%%"REG_a", %3), %%mm2            \n\t"
-        PMAXUB(%%mm2, %%mm4)
-        PMINUB(%%mm2, %%mm3, %%mm5)
-        "psubb %%mm2, %%mm1                     \n\t"
-        "paddb %%mm7, %%mm1                     \n\t"
-        "pcmpgtb %%mm6, %%mm1                   \n\t"
-        "paddb %%mm1, %%mm0                     \n\t"
-
-        "movq (%%"REG_a", %3, 2), %%mm1         \n\t"
-        PMAXUB(%%mm1, %%mm4)
-        PMINUB(%%mm1, %%mm3, %%mm5)
-        "psubb %%mm1, %%mm2                     \n\t"
-        "paddb %%mm7, %%mm2                     \n\t"
-        "pcmpgtb %%mm6, %%mm2                   \n\t"
-        "paddb %%mm2, %%mm0                     \n\t"
-        "psubusb %%mm3, %%mm4                   \n\t"
-
-        "                                       \n\t"
-#if TEMPLATE_PP_MMXEXT
-        "pxor %%mm7, %%mm7                      \n\t"
-        "psadbw %%mm7, %%mm0                    \n\t"
-#else
-        "movq %%mm0, %%mm1                      \n\t"
-        "psrlw $8, %%mm0                        \n\t"
-        "paddb %%mm1, %%mm0                     \n\t"
-        "movq %%mm0, %%mm1                      \n\t"
-        "psrlq $16, %%mm0                       \n\t"
-        "paddb %%mm1, %%mm0                     \n\t"
-        "movq %%mm0, %%mm1                      \n\t"
-        "psrlq $32, %%mm0                       \n\t"
-        "paddb %%mm1, %%mm0                     \n\t"
-#endif
-        "movq %4, %%mm7                         \n\t" // QP,..., QP
-        "paddusb %%mm7, %%mm7                   \n\t" // 2QP ... 2QP
-        "psubusb %%mm7, %%mm4                   \n\t" // Diff <= 2QP -> 0
-        "packssdw %%mm4, %%mm4                  \n\t"
-        "movd %%mm0, %0                         \n\t"
-        "movd %%mm4, %1                         \n\t"
-
-        : "=r" (numEq), "=r" (dcOk)
-        : "r" (src), "r" ((x86_reg)stride), "m" (c->pQPb)
-        : "%"REG_a
-        );
-
-    numEq= (-numEq) &0xFF;
-    if(numEq > c->ppMode.flatnessThreshold){
-        if(dcOk) return 0;
-        else     return 1;
-    }else{
-        return 2;
-    }
-}
-#endif //TEMPLATE_PP_MMX
-
-/**
- * Do a vertical low pass filter on the 8x16 block (only write to the 8x8 block in the middle)
- * using the 9-Tap Filter (1,1,2,2,4,2,2,1,1)/16
- */
-#if !TEMPLATE_PP_ALTIVEC
-static inline void RENAME(doVertLowPass)(uint8_t *src, int stride, PPContext *c)
-{
-#if TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-    src+= stride*3;
-    __asm__ volatile(        //"movv %0 %1 %2\n\t"
-        "movq %2, %%mm0                         \n\t"  // QP,..., QP
-        "pxor %%mm4, %%mm4                      \n\t"
-
-        "movq (%0), %%mm6                       \n\t"
-        "movq (%0, %1), %%mm5                   \n\t"
-        "movq %%mm5, %%mm1                      \n\t"
-        "movq %%mm6, %%mm2                      \n\t"
-        "psubusb %%mm6, %%mm5                   \n\t"
-        "psubusb %%mm1, %%mm2                   \n\t"
-        "por %%mm5, %%mm2                       \n\t" // ABS Diff of lines
-        "psubusb %%mm0, %%mm2                   \n\t" // diff <= QP -> 0
-        "pcmpeqb %%mm4, %%mm2                   \n\t" // diff <= QP -> FF
-
-        "pand %%mm2, %%mm6                      \n\t"
-        "pandn %%mm1, %%mm2                     \n\t"
-        "por %%mm2, %%mm6                       \n\t"// First Line to Filter
-
-        "movq (%0, %1, 8), %%mm5                \n\t"
-        "lea (%0, %1, 4), %%"REG_a"             \n\t"
-        "lea (%0, %1, 8), %%"REG_c"             \n\t"
-        "sub %1, %%"REG_c"                      \n\t"
-        "add %1, %0                             \n\t" // %0 points to line 1 not 0
-        "movq (%0, %1, 8), %%mm7                \n\t"
-        "movq %%mm5, %%mm1                      \n\t"
-        "movq %%mm7, %%mm2                      \n\t"
-        "psubusb %%mm7, %%mm5                   \n\t"
-        "psubusb %%mm1, %%mm2                   \n\t"
-        "por %%mm5, %%mm2                       \n\t" // ABS Diff of lines
-        "psubusb %%mm0, %%mm2                   \n\t" // diff <= QP -> 0
-        "pcmpeqb %%mm4, %%mm2                   \n\t" // diff <= QP -> FF
-
-        "pand %%mm2, %%mm7                      \n\t"
-        "pandn %%mm1, %%mm2                     \n\t"
-        "por %%mm2, %%mm7                       \n\t" // First Line to Filter
-
-
-        //      1       2       3       4       5       6       7       8
-        //      %0      %0+%1   %0+2%1  eax     %0+4%1  eax+2%1 ecx     eax+4%1
-        // 6 4 2 2 1 1
-        // 6 4 4 2
-        // 6 8 2
-
-        "movq (%0, %1), %%mm0                   \n\t" //  1
-        "movq %%mm0, %%mm1                      \n\t" //  1
-        PAVGB(%%mm6, %%mm0)                           //1 1        /2
-        PAVGB(%%mm6, %%mm0)                           //3 1        /4
-
-        "movq (%0, %1, 4), %%mm2                \n\t" //     1
-        "movq %%mm2, %%mm5                      \n\t" //     1
-        PAVGB((%%REGa), %%mm2)                        //    11        /2
-        PAVGB((%0, %1, 2), %%mm2)                     //   211        /4
-        "movq %%mm2, %%mm3                      \n\t" //   211        /4
-        "movq (%0), %%mm4                       \n\t" // 1
-        PAVGB(%%mm4, %%mm3)                           // 4 211        /8
-        PAVGB(%%mm0, %%mm3)                           //642211        /16
-        "movq %%mm3, (%0)                       \n\t" // X
-        // mm1=2 mm2=3(211) mm4=1 mm5=5 mm6=0 mm7=9
-        "movq %%mm1, %%mm0                      \n\t" //  1
-        PAVGB(%%mm6, %%mm0)                           //1 1        /2
-        "movq %%mm4, %%mm3                      \n\t" // 1
-        PAVGB((%0,%1,2), %%mm3)                       // 1 1        /2
-        PAVGB((%%REGa,%1,2), %%mm5)                   //     11        /2
-        PAVGB((%%REGa), %%mm5)                        //    211 /4
-        PAVGB(%%mm5, %%mm3)                           // 2 2211 /8
-        PAVGB(%%mm0, %%mm3)                           //4242211 /16
-        "movq %%mm3, (%0,%1)                    \n\t" //  X
-        // mm1=2 mm2=3(211) mm4=1 mm5=4(211) mm6=0 mm7=9
-        PAVGB(%%mm4, %%mm6)                                   //11        /2
-        "movq (%%"REG_c"), %%mm0                \n\t" //       1
-        PAVGB((%%REGa, %1, 2), %%mm0)                 //      11/2
-        "movq %%mm0, %%mm3                      \n\t" //      11/2
-        PAVGB(%%mm1, %%mm0)                           //  2   11/4
-        PAVGB(%%mm6, %%mm0)                           //222   11/8
-        PAVGB(%%mm2, %%mm0)                           //22242211/16
-        "movq (%0, %1, 2), %%mm2                \n\t" //   1
-        "movq %%mm0, (%0, %1, 2)                \n\t" //   X
-        // mm1=2 mm2=3 mm3=6(11) mm4=1 mm5=4(211) mm6=0(11) mm7=9
-        "movq (%%"REG_a", %1, 4), %%mm0         \n\t" //        1
-        PAVGB((%%REGc), %%mm0)                        //       11        /2
-        PAVGB(%%mm0, %%mm6)                           //11     11        /4
-        PAVGB(%%mm1, %%mm4)                           // 11                /2
-        PAVGB(%%mm2, %%mm1)                           //  11                /2
-        PAVGB(%%mm1, %%mm6)                           //1122   11        /8
-        PAVGB(%%mm5, %%mm6)                           //112242211        /16
-        "movq (%%"REG_a"), %%mm5                \n\t" //    1
-        "movq %%mm6, (%%"REG_a")                \n\t" //    X
-        // mm0=7(11) mm1=2(11) mm2=3 mm3=6(11) mm4=1(11) mm5=4 mm7=9
-        "movq (%%"REG_a", %1, 4), %%mm6         \n\t" //        1
-        PAVGB(%%mm7, %%mm6)                           //        11        /2
-        PAVGB(%%mm4, %%mm6)                           // 11     11        /4
-        PAVGB(%%mm3, %%mm6)                           // 11   2211        /8
-        PAVGB(%%mm5, %%mm2)                           //   11                /2
-        "movq (%0, %1, 4), %%mm4                \n\t" //     1
-        PAVGB(%%mm4, %%mm2)                           //   112                /4
-        PAVGB(%%mm2, %%mm6)                           // 112242211        /16
-        "movq %%mm6, (%0, %1, 4)                \n\t" //     X
-        // mm0=7(11) mm1=2(11) mm2=3(112) mm3=6(11) mm4=5 mm5=4 mm7=9
-        PAVGB(%%mm7, %%mm1)                           //  11     2        /4
-        PAVGB(%%mm4, %%mm5)                           //    11                /2
-        PAVGB(%%mm5, %%mm0)                           //    11 11        /4
-        "movq (%%"REG_a", %1, 2), %%mm6         \n\t" //      1
-        PAVGB(%%mm6, %%mm1)                           //  11  4  2        /8
-        PAVGB(%%mm0, %%mm1)                           //  11224222        /16
-        "movq %%mm1, (%%"REG_a", %1, 2)         \n\t" //      X
-        // mm2=3(112) mm3=6(11) mm4=5 mm5=4(11) mm6=6 mm7=9
-        PAVGB((%%REGc), %%mm2)                        //   112 4        /8
-        "movq (%%"REG_a", %1, 4), %%mm0         \n\t" //        1
-        PAVGB(%%mm0, %%mm6)                           //      1 1        /2
-        PAVGB(%%mm7, %%mm6)                           //      1 12        /4
-        PAVGB(%%mm2, %%mm6)                           //   1122424        /4
-        "movq %%mm6, (%%"REG_c")                \n\t" //       X
-        // mm0=8 mm3=6(11) mm4=5 mm5=4(11) mm7=9
-        PAVGB(%%mm7, %%mm5)                           //    11   2        /4
-        PAVGB(%%mm7, %%mm5)                           //    11   6        /8
-
-        PAVGB(%%mm3, %%mm0)                           //      112        /4
-        PAVGB(%%mm0, %%mm5)                           //    112246        /16
-        "movq %%mm5, (%%"REG_a", %1, 4)         \n\t" //        X
-        "sub %1, %0                             \n\t"
-
-        :
-        : "r" (src), "r" ((x86_reg)stride), "m" (c->pQPb)
-        : "%"REG_a, "%"REG_c
-    );
-#else //TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-    const int l1= stride;
-    const int l2= stride + l1;
-    const int l3= stride + l2;
-    const int l4= stride + l3;
-    const int l5= stride + l4;
-    const int l6= stride + l5;
-    const int l7= stride + l6;
-    const int l8= stride + l7;
-    const int l9= stride + l8;
-    int x;
-    src+= stride*3;
-    for(x=0; x<BLOCK_SIZE; x++){
-        const int first= FFABS(src[0] - src[l1]) < c->QP ? src[0] : src[l1];
-        const int last= FFABS(src[l8] - src[l9]) < c->QP ? src[l9] : src[l8];
-
-        int sums[10];
-        sums[0] = 4*first + src[l1] + src[l2] + src[l3] + 4;
-        sums[1] = sums[0] - first  + src[l4];
-        sums[2] = sums[1] - first  + src[l5];
-        sums[3] = sums[2] - first  + src[l6];
-        sums[4] = sums[3] - first  + src[l7];
-        sums[5] = sums[4] - src[l1] + src[l8];
-        sums[6] = sums[5] - src[l2] + last;
-        sums[7] = sums[6] - src[l3] + last;
-        sums[8] = sums[7] - src[l4] + last;
-        sums[9] = sums[8] - src[l5] + last;
-
-        src[l1]= (sums[0] + sums[2] + 2*src[l1])>>4;
-        src[l2]= (sums[1] + sums[3] + 2*src[l2])>>4;
-        src[l3]= (sums[2] + sums[4] + 2*src[l3])>>4;
-        src[l4]= (sums[3] + sums[5] + 2*src[l4])>>4;
-        src[l5]= (sums[4] + sums[6] + 2*src[l5])>>4;
-        src[l6]= (sums[5] + sums[7] + 2*src[l6])>>4;
-        src[l7]= (sums[6] + sums[8] + 2*src[l7])>>4;
-        src[l8]= (sums[7] + sums[9] + 2*src[l8])>>4;
-
-        src++;
-    }
-#endif //TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-}
-#endif //TEMPLATE_PP_ALTIVEC
-
-/**
- * Experimental Filter 1
- * will not damage linear gradients
- * Flat blocks should look like they were passed through the (1,1,2,2,4,2,2,1,1) 9-Tap filter
- * can only smooth blocks at the expected locations (it cannot smooth them if they did move)
- * MMX2 version does correct clipping C version does not
- */
-static inline void RENAME(vertX1Filter)(uint8_t *src, int stride, PPContext *co)
-{
-#if TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-    src+= stride*3;
-
-    __asm__ volatile(
-        "pxor %%mm7, %%mm7                      \n\t" // 0
-        "lea (%0, %1), %%"REG_a"                \n\t"
-        "lea (%%"REG_a", %1, 4), %%"REG_c"      \n\t"
-//      0       1       2       3       4       5       6       7       8       9
-//      %0      eax     eax+%1  eax+2%1 %0+4%1  ecx     ecx+%1  ecx+2%1 %0+8%1  ecx+4%1
-        "movq (%%"REG_a", %1, 2), %%mm0         \n\t" // line 3
-        "movq (%0, %1, 4), %%mm1                \n\t" // line 4
-        "movq %%mm1, %%mm2                      \n\t" // line 4
-        "psubusb %%mm0, %%mm1                   \n\t"
-        "psubusb %%mm2, %%mm0                   \n\t"
-        "por %%mm1, %%mm0                       \n\t" // |l2 - l3|
-        "movq (%%"REG_c"), %%mm3                \n\t" // line 5
-        "movq (%%"REG_c", %1), %%mm4            \n\t" // line 6
-        "movq %%mm3, %%mm5                      \n\t" // line 5
-        "psubusb %%mm4, %%mm3                   \n\t"
-        "psubusb %%mm5, %%mm4                   \n\t"
-        "por %%mm4, %%mm3                       \n\t" // |l5 - l6|
-        PAVGB(%%mm3, %%mm0)                           // (|l2 - l3| + |l5 - l6|)/2
-        "movq %%mm2, %%mm1                      \n\t" // line 4
-        "psubusb %%mm5, %%mm2                   \n\t"
-        "movq %%mm2, %%mm4                      \n\t"
-        "pcmpeqb %%mm7, %%mm2                   \n\t" // (l4 - l5) <= 0 ? -1 : 0
-        "psubusb %%mm1, %%mm5                   \n\t"
-        "por %%mm5, %%mm4                       \n\t" // |l4 - l5|
-        "psubusb %%mm0, %%mm4                   \n\t" //d = MAX(0, |l4-l5| - (|l2-l3| + |l5-l6|)/2)
-        "movq %%mm4, %%mm3                      \n\t" // d
-        "movq %2, %%mm0                         \n\t"
-        "paddusb %%mm0, %%mm0                   \n\t"
-        "psubusb %%mm0, %%mm4                   \n\t"
-        "pcmpeqb %%mm7, %%mm4                   \n\t" // d <= QP ? -1 : 0
-        "psubusb "MANGLE(b01)", %%mm3           \n\t"
-        "pand %%mm4, %%mm3                      \n\t" // d <= QP ? d : 0
-
-        PAVGB(%%mm7, %%mm3)                           // d/2
-        "movq %%mm3, %%mm1                      \n\t" // d/2
-        PAVGB(%%mm7, %%mm3)                           // d/4
-        PAVGB(%%mm1, %%mm3)                           // 3*d/8
-
-        "movq (%0, %1, 4), %%mm0                \n\t" // line 4
-        "pxor %%mm2, %%mm0                      \n\t" //(l4 - l5) <= 0 ? -l4-1 : l4
-        "psubusb %%mm3, %%mm0                   \n\t"
-        "pxor %%mm2, %%mm0                      \n\t"
-        "movq %%mm0, (%0, %1, 4)                \n\t" // line 4
-
-        "movq (%%"REG_c"), %%mm0                \n\t" // line 5
-        "pxor %%mm2, %%mm0                      \n\t" //(l4 - l5) <= 0 ? -l5-1 : l5
-        "paddusb %%mm3, %%mm0                   \n\t"
-        "pxor %%mm2, %%mm0                      \n\t"
-        "movq %%mm0, (%%"REG_c")                \n\t" // line 5
-
-        PAVGB(%%mm7, %%mm1)                           // d/4
-
-        "movq (%%"REG_a", %1, 2), %%mm0         \n\t" // line 3
-        "pxor %%mm2, %%mm0                      \n\t" //(l4 - l5) <= 0 ? -l4-1 : l4
-        "psubusb %%mm1, %%mm0                   \n\t"
-        "pxor %%mm2, %%mm0                      \n\t"
-        "movq %%mm0, (%%"REG_a", %1, 2)         \n\t" // line 3
-
-        "movq (%%"REG_c", %1), %%mm0            \n\t" // line 6
-        "pxor %%mm2, %%mm0                      \n\t" //(l4 - l5) <= 0 ? -l5-1 : l5
-        "paddusb %%mm1, %%mm0                   \n\t"
-        "pxor %%mm2, %%mm0                      \n\t"
-        "movq %%mm0, (%%"REG_c", %1)            \n\t" // line 6
-
-        PAVGB(%%mm7, %%mm1)                           // d/8
-
-        "movq (%%"REG_a", %1), %%mm0            \n\t" // line 2
-        "pxor %%mm2, %%mm0                      \n\t" //(l4 - l5) <= 0 ? -l2-1 : l2
-        "psubusb %%mm1, %%mm0                   \n\t"
-        "pxor %%mm2, %%mm0                      \n\t"
-        "movq %%mm0, (%%"REG_a", %1)            \n\t" // line 2
-
-        "movq (%%"REG_c", %1, 2), %%mm0         \n\t" // line 7
-        "pxor %%mm2, %%mm0                      \n\t" //(l4 - l5) <= 0 ? -l7-1 : l7
-        "paddusb %%mm1, %%mm0                   \n\t"
-        "pxor %%mm2, %%mm0                      \n\t"
-        "movq %%mm0, (%%"REG_c", %1, 2)         \n\t" // line 7
-
-        :
-        : "r" (src), "r" ((x86_reg)stride), "m" (co->pQPb)
-        : "%"REG_a, "%"REG_c
-    );
-#else //TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-
-    const int l1= stride;
-    const int l2= stride + l1;
-    const int l3= stride + l2;
-    const int l4= stride + l3;
-    const int l5= stride + l4;
-    const int l6= stride + l5;
-    const int l7= stride + l6;
-//    const int l8= stride + l7;
-//    const int l9= stride + l8;
-    int x;
-
-    src+= stride*3;
-    for(x=0; x<BLOCK_SIZE; x++){
-        int a= src[l3] - src[l4];
-        int b= src[l4] - src[l5];
-        int c= src[l5] - src[l6];
-
-        int d= FFABS(b) - ((FFABS(a) + FFABS(c))>>1);
-        d= FFMAX(d, 0);
-
-        if(d < co->QP*2){
-            int v = d * FFSIGN(-b);
-
-            src[l2] +=v>>3;
-            src[l3] +=v>>2;
-            src[l4] +=(3*v)>>3;
-            src[l5] -=(3*v)>>3;
-            src[l6] -=v>>2;
-            src[l7] -=v>>3;
-        }
-        src++;
-    }
-#endif //TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-}
-
-#if !TEMPLATE_PP_ALTIVEC
-static inline void RENAME(doVertDefFilter)(uint8_t src[], int stride, PPContext *c)
-{
-#if TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-/*
-    uint8_t tmp[16];
-    const int l1= stride;
-    const int l2= stride + l1;
-    const int l3= stride + l2;
-    const int l4= (int)tmp - (int)src - stride*3;
-    const int l5= (int)tmp - (int)src - stride*3 + 8;
-    const int l6= stride*3 + l3;
-    const int l7= stride + l6;
-    const int l8= stride + l7;
-
-    memcpy(tmp, src+stride*7, 8);
-    memcpy(tmp+8, src+stride*8, 8);
-*/
-    src+= stride*4;
-    __asm__ volatile(
-
-#if 0 //slightly more accurate and slightly slower
-        "pxor %%mm7, %%mm7                      \n\t" // 0
-        "lea (%0, %1), %%"REG_a"                \n\t"
-        "lea (%%"REG_a", %1, 4), %%"REG_c"      \n\t"
-//      0       1       2       3       4       5       6       7
-//      %0      %0+%1   %0+2%1  eax+2%1 %0+4%1  eax+4%1 ecx+%1  ecx+2%1
-//      %0      eax     eax+%1  eax+2%1 %0+4%1  ecx     ecx+%1  ecx+2%1
-
-
-        "movq (%0, %1, 2), %%mm0                \n\t" // l2
-        "movq (%0), %%mm1                       \n\t" // l0
-        "movq %%mm0, %%mm2                      \n\t" // l2
-        PAVGB(%%mm7, %%mm0)                           // ~l2/2
-        PAVGB(%%mm1, %%mm0)                           // ~(l2 + 2l0)/4
-        PAVGB(%%mm2, %%mm0)                           // ~(5l2 + 2l0)/8
-
-        "movq (%%"REG_a"), %%mm1                \n\t" // l1
-        "movq (%%"REG_a", %1, 2), %%mm3         \n\t" // l3
-        "movq %%mm1, %%mm4                      \n\t" // l1
-        PAVGB(%%mm7, %%mm1)                           // ~l1/2
-        PAVGB(%%mm3, %%mm1)                           // ~(l1 + 2l3)/4
-        PAVGB(%%mm4, %%mm1)                           // ~(5l1 + 2l3)/8
-
-        "movq %%mm0, %%mm4                      \n\t" // ~(5l2 + 2l0)/8
-        "psubusb %%mm1, %%mm0                   \n\t"
-        "psubusb %%mm4, %%mm1                   \n\t"
-        "por %%mm0, %%mm1                       \n\t" // ~|2l0 - 5l1 + 5l2 - 2l3|/8
-// mm1= |lenergy|, mm2= l2, mm3= l3, mm7=0
-
-        "movq (%0, %1, 4), %%mm0                \n\t" // l4
-        "movq %%mm0, %%mm4                      \n\t" // l4
-        PAVGB(%%mm7, %%mm0)                           // ~l4/2
-        PAVGB(%%mm2, %%mm0)                           // ~(l4 + 2l2)/4
-        PAVGB(%%mm4, %%mm0)                           // ~(5l4 + 2l2)/8
-
-        "movq (%%"REG_c"), %%mm2                \n\t" // l5
-        "movq %%mm3, %%mm5                      \n\t" // l3
-        PAVGB(%%mm7, %%mm3)                           // ~l3/2
-        PAVGB(%%mm2, %%mm3)                           // ~(l3 + 2l5)/4
-        PAVGB(%%mm5, %%mm3)                           // ~(5l3 + 2l5)/8
-
-        "movq %%mm0, %%mm6                      \n\t" // ~(5l4 + 2l2)/8
-        "psubusb %%mm3, %%mm0                   \n\t"
-        "psubusb %%mm6, %%mm3                   \n\t"
-        "por %%mm0, %%mm3                       \n\t" // ~|2l2 - 5l3 + 5l4 - 2l5|/8
-        "pcmpeqb %%mm7, %%mm0                   \n\t" // SIGN(2l2 - 5l3 + 5l4 - 2l5)
-// mm0= SIGN(menergy), mm1= |lenergy|, mm2= l5, mm3= |menergy|, mm4=l4, mm5= l3, mm7=0
-
-        "movq (%%"REG_c", %1), %%mm6            \n\t" // l6
-        "movq %%mm6, %%mm5                      \n\t" // l6
-        PAVGB(%%mm7, %%mm6)                           // ~l6/2
-        PAVGB(%%mm4, %%mm6)                           // ~(l6 + 2l4)/4
-        PAVGB(%%mm5, %%mm6)                           // ~(5l6 + 2l4)/8
-
-        "movq (%%"REG_c", %1, 2), %%mm5         \n\t" // l7
-        "movq %%mm2, %%mm4                      \n\t" // l5
-        PAVGB(%%mm7, %%mm2)                           // ~l5/2
-        PAVGB(%%mm5, %%mm2)                           // ~(l5 + 2l7)/4
-        PAVGB(%%mm4, %%mm2)                           // ~(5l5 + 2l7)/8
-
-        "movq %%mm6, %%mm4                      \n\t" // ~(5l6 + 2l4)/8
-        "psubusb %%mm2, %%mm6                   \n\t"
-        "psubusb %%mm4, %%mm2                   \n\t"
-        "por %%mm6, %%mm2                       \n\t" // ~|2l4 - 5l5 + 5l6 - 2l7|/8
-// mm0= SIGN(menergy), mm1= |lenergy|/8, mm2= |renergy|/8, mm3= |menergy|/8, mm7=0
-
-
-        PMINUB(%%mm2, %%mm1, %%mm4)                   // MIN(|lenergy|,|renergy|)/8
-        "movq %2, %%mm4                         \n\t" // QP //FIXME QP+1 ?
-        "paddusb "MANGLE(b01)", %%mm4           \n\t"
-        "pcmpgtb %%mm3, %%mm4                   \n\t" // |menergy|/8 < QP
-        "psubusb %%mm1, %%mm3                   \n\t" // d=|menergy|/8-MIN(|lenergy|,|renergy|)/8
-        "pand %%mm4, %%mm3                      \n\t"
-
-        "movq %%mm3, %%mm1                      \n\t"
-//        "psubusb "MANGLE(b01)", %%mm3           \n\t"
-        PAVGB(%%mm7, %%mm3)
-        PAVGB(%%mm7, %%mm3)
-        "paddusb %%mm1, %%mm3                   \n\t"
-//        "paddusb "MANGLE(b01)", %%mm3           \n\t"
-
-        "movq (%%"REG_a", %1, 2), %%mm6         \n\t" //l3
-        "movq (%0, %1, 4), %%mm5                \n\t" //l4
-        "movq (%0, %1, 4), %%mm4                \n\t" //l4
-        "psubusb %%mm6, %%mm5                   \n\t"
-        "psubusb %%mm4, %%mm6                   \n\t"
-        "por %%mm6, %%mm5                       \n\t" // |l3-l4|
-        "pcmpeqb %%mm7, %%mm6                   \n\t" // SIGN(l3-l4)
-        "pxor %%mm6, %%mm0                      \n\t"
-        "pand %%mm0, %%mm3                      \n\t"
-        PMINUB(%%mm5, %%mm3, %%mm0)
-
-        "psubusb "MANGLE(b01)", %%mm3           \n\t"
-        PAVGB(%%mm7, %%mm3)
-
-        "movq (%%"REG_a", %1, 2), %%mm0         \n\t"
-        "movq (%0, %1, 4), %%mm2                \n\t"
-        "pxor %%mm6, %%mm0                      \n\t"
-        "pxor %%mm6, %%mm2                      \n\t"
-        "psubb %%mm3, %%mm0                     \n\t"
-        "paddb %%mm3, %%mm2                     \n\t"
-        "pxor %%mm6, %%mm0                      \n\t"
-        "pxor %%mm6, %%mm2                      \n\t"
-        "movq %%mm0, (%%"REG_a", %1, 2)         \n\t"
-        "movq %%mm2, (%0, %1, 4)                \n\t"
-#endif //0
-
-        "lea (%0, %1), %%"REG_a"                \n\t"
-        "pcmpeqb %%mm6, %%mm6                   \n\t" // -1
-//      0       1       2       3       4       5       6       7
-//      %0      %0+%1   %0+2%1  eax+2%1 %0+4%1  eax+4%1 ecx+%1  ecx+2%1
-//      %0      eax     eax+%1  eax+2%1 %0+4%1  ecx     ecx+%1  ecx+2%1
-
-
-        "movq (%%"REG_a", %1, 2), %%mm1         \n\t" // l3
-        "movq (%0, %1, 4), %%mm0                \n\t" // l4
-        "pxor %%mm6, %%mm1                      \n\t" // -l3-1
-        PAVGB(%%mm1, %%mm0)                           // -q+128 = (l4-l3+256)/2
-// mm1=-l3-1, mm0=128-q
-
-        "movq (%%"REG_a", %1, 4), %%mm2         \n\t" // l5
-        "movq (%%"REG_a", %1), %%mm3            \n\t" // l2
-        "pxor %%mm6, %%mm2                      \n\t" // -l5-1
-        "movq %%mm2, %%mm5                      \n\t" // -l5-1
-        "movq "MANGLE(b80)", %%mm4              \n\t" // 128
-        "lea (%%"REG_a", %1, 4), %%"REG_c"      \n\t"
-        PAVGB(%%mm3, %%mm2)                           // (l2-l5+256)/2
-        PAVGB(%%mm0, %%mm4)                           // ~(l4-l3)/4 + 128
-        PAVGB(%%mm2, %%mm4)                           // ~(l2-l5)/4 +(l4-l3)/8 + 128
-        PAVGB(%%mm0, %%mm4)                           // ~(l2-l5)/8 +5(l4-l3)/16 + 128
-// mm1=-l3-1, mm0=128-q, mm3=l2, mm4=menergy/16 + 128, mm5= -l5-1
-
-        "movq (%%"REG_a"), %%mm2                \n\t" // l1
-        "pxor %%mm6, %%mm2                      \n\t" // -l1-1
-        PAVGB(%%mm3, %%mm2)                           // (l2-l1+256)/2
-        PAVGB((%0), %%mm1)                            // (l0-l3+256)/2
-        "movq "MANGLE(b80)", %%mm3              \n\t" // 128
-        PAVGB(%%mm2, %%mm3)                           // ~(l2-l1)/4 + 128
-        PAVGB(%%mm1, %%mm3)                           // ~(l0-l3)/4 +(l2-l1)/8 + 128
-        PAVGB(%%mm2, %%mm3)                           // ~(l0-l3)/8 +5(l2-l1)/16 + 128
-// mm0=128-q, mm3=lenergy/16 + 128, mm4= menergy/16 + 128, mm5= -l5-1
-
-        PAVGB((%%REGc, %1), %%mm5)                    // (l6-l5+256)/2
-        "movq (%%"REG_c", %1, 2), %%mm1         \n\t" // l7
-        "pxor %%mm6, %%mm1                      \n\t" // -l7-1
-        PAVGB((%0, %1, 4), %%mm1)                     // (l4-l7+256)/2
-        "movq "MANGLE(b80)", %%mm2              \n\t" // 128
-        PAVGB(%%mm5, %%mm2)                           // ~(l6-l5)/4 + 128
-        PAVGB(%%mm1, %%mm2)                           // ~(l4-l7)/4 +(l6-l5)/8 + 128
-        PAVGB(%%mm5, %%mm2)                           // ~(l4-l7)/8 +5(l6-l5)/16 + 128
-// mm0=128-q, mm2=renergy/16 + 128, mm3=lenergy/16 + 128, mm4= menergy/16 + 128
-
-        "movq "MANGLE(b00)", %%mm1              \n\t" // 0
-        "movq "MANGLE(b00)", %%mm5              \n\t" // 0
-        "psubb %%mm2, %%mm1                     \n\t" // 128 - renergy/16
-        "psubb %%mm3, %%mm5                     \n\t" // 128 - lenergy/16
-        PMAXUB(%%mm1, %%mm2)                          // 128 + |renergy/16|
-        PMAXUB(%%mm5, %%mm3)                          // 128 + |lenergy/16|
-        PMINUB(%%mm2, %%mm3, %%mm1)                   // 128 + MIN(|lenergy|,|renergy|)/16
-
-// mm0=128-q, mm3=128 + MIN(|lenergy|,|renergy|)/16, mm4= menergy/16 + 128
-
-        "movq "MANGLE(b00)", %%mm7              \n\t" // 0
-        "movq %2, %%mm2                         \n\t" // QP
-        PAVGB(%%mm6, %%mm2)                           // 128 + QP/2
-        "psubb %%mm6, %%mm2                     \n\t"
-
-        "movq %%mm4, %%mm1                      \n\t"
-        "pcmpgtb %%mm7, %%mm1                   \n\t" // SIGN(menergy)
-        "pxor %%mm1, %%mm4                      \n\t"
-        "psubb %%mm1, %%mm4                     \n\t" // 128 + |menergy|/16
-        "pcmpgtb %%mm4, %%mm2                   \n\t" // |menergy|/16 < QP/2
-        "psubusb %%mm3, %%mm4                   \n\t" //d=|menergy|/16 - MIN(|lenergy|,|renergy|)/16
-// mm0=128-q, mm1= SIGN(menergy), mm2= |menergy|/16 < QP/2, mm4= d/16
-
-        "movq %%mm4, %%mm3                      \n\t" // d
-        "psubusb "MANGLE(b01)", %%mm4           \n\t"
-        PAVGB(%%mm7, %%mm4)                           // d/32
-        PAVGB(%%mm7, %%mm4)                           // (d + 32)/64
-        "paddb %%mm3, %%mm4                     \n\t" // 5d/64
-        "pand %%mm2, %%mm4                      \n\t"
-
-        "movq "MANGLE(b80)", %%mm5              \n\t" // 128
-        "psubb %%mm0, %%mm5                     \n\t" // q
-        "paddsb %%mm6, %%mm5                    \n\t" // fix bad rounding
-        "pcmpgtb %%mm5, %%mm7                   \n\t" // SIGN(q)
-        "pxor %%mm7, %%mm5                      \n\t"
-
-        PMINUB(%%mm5, %%mm4, %%mm3)                   // MIN(|q|, 5d/64)
-        "pxor %%mm1, %%mm7                      \n\t" // SIGN(d*q)
-
-        "pand %%mm7, %%mm4                      \n\t"
-        "movq (%%"REG_a", %1, 2), %%mm0         \n\t"
-        "movq (%0, %1, 4), %%mm2                \n\t"
-        "pxor %%mm1, %%mm0                      \n\t"
-        "pxor %%mm1, %%mm2                      \n\t"
-        "paddb %%mm4, %%mm0                     \n\t"
-        "psubb %%mm4, %%mm2                     \n\t"
-        "pxor %%mm1, %%mm0                      \n\t"
-        "pxor %%mm1, %%mm2                      \n\t"
-        "movq %%mm0, (%%"REG_a", %1, 2)         \n\t"
-        "movq %%mm2, (%0, %1, 4)                \n\t"
-
-        :
-        : "r" (src), "r" ((x86_reg)stride), "m" (c->pQPb)
-        : "%"REG_a, "%"REG_c
-    );
-
-/*
-    {
-    int x;
-    src-= stride;
-    for(x=0; x<BLOCK_SIZE; x++){
-        const int middleEnergy= 5*(src[l5] - src[l4]) + 2*(src[l3] - src[l6]);
-        if(FFABS(middleEnergy)< 8*QP){
-            const int q=(src[l4] - src[l5])/2;
-            const int leftEnergy=  5*(src[l3] - src[l2]) + 2*(src[l1] - src[l4]);
-            const int rightEnergy= 5*(src[l7] - src[l6]) + 2*(src[l5] - src[l8]);
-
-            int d= FFABS(middleEnergy) - FFMIN( FFABS(leftEnergy), FFABS(rightEnergy) );
-            d= FFMAX(d, 0);
-
-            d= (5*d + 32) >> 6;
-            d*= FFSIGN(-middleEnergy);
-
-            if(q>0){
-                d= d<0 ? 0 : d;
-                d= d>q ? q : d;
-            }else{
-                d= d>0 ? 0 : d;
-                d= d<q ? q : d;
-            }
-
-            src[l4]-= d;
-            src[l5]+= d;
-        }
-        src++;
-    }
-    src-=8;
-    for(x=0; x<8; x++){
-        int y;
-        for(y=4; y<6; y++){
-            int d= src[x+y*stride] - tmp[x+(y-4)*8];
-            int ad= FFABS(d);
-            static int max=0;
-            static int sum=0;
-            static int num=0;
-            static int bias=0;
-
-            if(max<ad) max=ad;
-            sum+= ad>3 ? 1 : 0;
-            if(ad>3){
-                src[0] = src[7] = src[stride*7] = src[(stride+1)*7]=255;
-            }
-            if(y==4) bias+=d;
-            num++;
-            if(num%1000000 == 0){
-                av_log(c, AV_LOG_INFO, " %d %d %d %d\n", num, sum, max, bias);
-            }
-        }
-    }
-}
-*/
-#elif TEMPLATE_PP_MMX
-    DECLARE_ALIGNED(8, uint64_t, tmp)[4]; // make space for 4 8-byte vars
-    src+= stride*4;
-    __asm__ volatile(
-        "pxor %%mm7, %%mm7                      \n\t"
-//      0       1       2       3       4       5       6       7
-//      %0      %0+%1   %0+2%1  eax+2%1 %0+4%1  eax+4%1 edx+%1  edx+2%1
-//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1
-
-        "movq (%0), %%mm0                       \n\t"
-        "movq %%mm0, %%mm1                      \n\t"
-        "punpcklbw %%mm7, %%mm0                 \n\t" // low part of line 0
-        "punpckhbw %%mm7, %%mm1                 \n\t" // high part of line 0
-
-        "movq (%0, %1), %%mm2                   \n\t"
-        "lea (%0, %1, 2), %%"REG_a"             \n\t"
-        "movq %%mm2, %%mm3                      \n\t"
-        "punpcklbw %%mm7, %%mm2                 \n\t" // low part of line 1
-        "punpckhbw %%mm7, %%mm3                 \n\t" // high part of line 1
-
-        "movq (%%"REG_a"), %%mm4                \n\t"
-        "movq %%mm4, %%mm5                      \n\t"
-        "punpcklbw %%mm7, %%mm4                 \n\t" // low part of line 2
-        "punpckhbw %%mm7, %%mm5                 \n\t" // high part of line 2
-
-        "paddw %%mm0, %%mm0                     \n\t" // 2L0
-        "paddw %%mm1, %%mm1                     \n\t" // 2H0
-        "psubw %%mm4, %%mm2                     \n\t" // L1 - L2
-        "psubw %%mm5, %%mm3                     \n\t" // H1 - H2
-        "psubw %%mm2, %%mm0                     \n\t" // 2L0 - L1 + L2
-        "psubw %%mm3, %%mm1                     \n\t" // 2H0 - H1 + H2
-
-        "psllw $2, %%mm2                        \n\t" // 4L1 - 4L2
-        "psllw $2, %%mm3                        \n\t" // 4H1 - 4H2
-        "psubw %%mm2, %%mm0                     \n\t" // 2L0 - 5L1 + 5L2
-        "psubw %%mm3, %%mm1                     \n\t" // 2H0 - 5H1 + 5H2
-
-        "movq (%%"REG_a", %1), %%mm2            \n\t"
-        "movq %%mm2, %%mm3                      \n\t"
-        "punpcklbw %%mm7, %%mm2                 \n\t" // L3
-        "punpckhbw %%mm7, %%mm3                 \n\t" // H3
-
-        "psubw %%mm2, %%mm0                     \n\t" // 2L0 - 5L1 + 5L2 - L3
-        "psubw %%mm3, %%mm1                     \n\t" // 2H0 - 5H1 + 5H2 - H3
-        "psubw %%mm2, %%mm0                     \n\t" // 2L0 - 5L1 + 5L2 - 2L3
-        "psubw %%mm3, %%mm1                     \n\t" // 2H0 - 5H1 + 5H2 - 2H3
-        "movq %%mm0, (%3)                       \n\t" // 2L0 - 5L1 + 5L2 - 2L3
-        "movq %%mm1, 8(%3)                      \n\t" // 2H0 - 5H1 + 5H2 - 2H3
-
-        "movq (%%"REG_a", %1, 2), %%mm0         \n\t"
-        "movq %%mm0, %%mm1                      \n\t"
-        "punpcklbw %%mm7, %%mm0                 \n\t" // L4
-        "punpckhbw %%mm7, %%mm1                 \n\t" // H4
-
-        "psubw %%mm0, %%mm2                     \n\t" // L3 - L4
-        "psubw %%mm1, %%mm3                     \n\t" // H3 - H4
-        "movq %%mm2, 16(%3)                     \n\t" // L3 - L4
-        "movq %%mm3, 24(%3)                     \n\t" // H3 - H4
-        "paddw %%mm4, %%mm4                     \n\t" // 2L2
-        "paddw %%mm5, %%mm5                     \n\t" // 2H2
-        "psubw %%mm2, %%mm4                     \n\t" // 2L2 - L3 + L4
-        "psubw %%mm3, %%mm5                     \n\t" // 2H2 - H3 + H4
-
-        "lea (%%"REG_a", %1), %0                \n\t"
-        "psllw $2, %%mm2                        \n\t" // 4L3 - 4L4
-        "psllw $2, %%mm3                        \n\t" // 4H3 - 4H4
-        "psubw %%mm2, %%mm4                     \n\t" // 2L2 - 5L3 + 5L4
-        "psubw %%mm3, %%mm5                     \n\t" // 2H2 - 5H3 + 5H4
-//50 opcodes so far
-        "movq (%0, %1, 2), %%mm2                \n\t"
-        "movq %%mm2, %%mm3                      \n\t"
-        "punpcklbw %%mm7, %%mm2                 \n\t" // L5
-        "punpckhbw %%mm7, %%mm3                 \n\t" // H5
-        "psubw %%mm2, %%mm4                     \n\t" // 2L2 - 5L3 + 5L4 - L5
-        "psubw %%mm3, %%mm5                     \n\t" // 2H2 - 5H3 + 5H4 - H5
-        "psubw %%mm2, %%mm4                     \n\t" // 2L2 - 5L3 + 5L4 - 2L5
-        "psubw %%mm3, %%mm5                     \n\t" // 2H2 - 5H3 + 5H4 - 2H5
-
-        "movq (%%"REG_a", %1, 4), %%mm6         \n\t"
-        "punpcklbw %%mm7, %%mm6                 \n\t" // L6
-        "psubw %%mm6, %%mm2                     \n\t" // L5 - L6
-        "movq (%%"REG_a", %1, 4), %%mm6         \n\t"
-        "punpckhbw %%mm7, %%mm6                 \n\t" // H6
-        "psubw %%mm6, %%mm3                     \n\t" // H5 - H6
-
-        "paddw %%mm0, %%mm0                     \n\t" // 2L4
-        "paddw %%mm1, %%mm1                     \n\t" // 2H4
-        "psubw %%mm2, %%mm0                     \n\t" // 2L4 - L5 + L6
-        "psubw %%mm3, %%mm1                     \n\t" // 2H4 - H5 + H6
-
-        "psllw $2, %%mm2                        \n\t" // 4L5 - 4L6
-        "psllw $2, %%mm3                        \n\t" // 4H5 - 4H6
-        "psubw %%mm2, %%mm0                     \n\t" // 2L4 - 5L5 + 5L6
-        "psubw %%mm3, %%mm1                     \n\t" // 2H4 - 5H5 + 5H6
-
-        "movq (%0, %1, 4), %%mm2                \n\t"
-        "movq %%mm2, %%mm3                      \n\t"
-        "punpcklbw %%mm7, %%mm2                 \n\t" // L7
-        "punpckhbw %%mm7, %%mm3                 \n\t" // H7
-
-        "paddw %%mm2, %%mm2                     \n\t" // 2L7
-        "paddw %%mm3, %%mm3                     \n\t" // 2H7
-        "psubw %%mm2, %%mm0                     \n\t" // 2L4 - 5L5 + 5L6 - 2L7
-        "psubw %%mm3, %%mm1                     \n\t" // 2H4 - 5H5 + 5H6 - 2H7
-
-        "movq (%3), %%mm2                       \n\t" // 2L0 - 5L1 + 5L2 - 2L3
-        "movq 8(%3), %%mm3                      \n\t" // 2H0 - 5H1 + 5H2 - 2H3
-
-#if TEMPLATE_PP_MMXEXT
-        "movq %%mm7, %%mm6                      \n\t" // 0
-        "psubw %%mm0, %%mm6                     \n\t"
-        "pmaxsw %%mm6, %%mm0                    \n\t" // |2L4 - 5L5 + 5L6 - 2L7|
-        "movq %%mm7, %%mm6                      \n\t" // 0
-        "psubw %%mm1, %%mm6                     \n\t"
-        "pmaxsw %%mm6, %%mm1                    \n\t" // |2H4 - 5H5 + 5H6 - 2H7|
-        "movq %%mm7, %%mm6                      \n\t" // 0
-        "psubw %%mm2, %%mm6                     \n\t"
-        "pmaxsw %%mm6, %%mm2                    \n\t" // |2L0 - 5L1 + 5L2 - 2L3|
-        "movq %%mm7, %%mm6                      \n\t" // 0
-        "psubw %%mm3, %%mm6                     \n\t"
-        "pmaxsw %%mm6, %%mm3                    \n\t" // |2H0 - 5H1 + 5H2 - 2H3|
-#else
-        "movq %%mm7, %%mm6                      \n\t" // 0
-        "pcmpgtw %%mm0, %%mm6                   \n\t"
-        "pxor %%mm6, %%mm0                      \n\t"
-        "psubw %%mm6, %%mm0                     \n\t" // |2L4 - 5L5 + 5L6 - 2L7|
-        "movq %%mm7, %%mm6                      \n\t" // 0
-        "pcmpgtw %%mm1, %%mm6                   \n\t"
-        "pxor %%mm6, %%mm1                      \n\t"
-        "psubw %%mm6, %%mm1                     \n\t" // |2H4 - 5H5 + 5H6 - 2H7|
-        "movq %%mm7, %%mm6                      \n\t" // 0
-        "pcmpgtw %%mm2, %%mm6                   \n\t"
-        "pxor %%mm6, %%mm2                      \n\t"
-        "psubw %%mm6, %%mm2                     \n\t" // |2L0 - 5L1 + 5L2 - 2L3|
-        "movq %%mm7, %%mm6                      \n\t" // 0
-        "pcmpgtw %%mm3, %%mm6                   \n\t"
-        "pxor %%mm6, %%mm3                      \n\t"
-        "psubw %%mm6, %%mm3                     \n\t" // |2H0 - 5H1 + 5H2 - 2H3|
-#endif
-
-#if TEMPLATE_PP_MMXEXT
-        "pminsw %%mm2, %%mm0                    \n\t"
-        "pminsw %%mm3, %%mm1                    \n\t"
-#else
-        "movq %%mm0, %%mm6                      \n\t"
-        "psubusw %%mm2, %%mm6                   \n\t"
-        "psubw %%mm6, %%mm0                     \n\t"
-        "movq %%mm1, %%mm6                      \n\t"
-        "psubusw %%mm3, %%mm6                   \n\t"
-        "psubw %%mm6, %%mm1                     \n\t"
-#endif
-
-        "movd %2, %%mm2                         \n\t" // QP
-        "punpcklbw %%mm7, %%mm2                 \n\t"
-
-        "movq %%mm7, %%mm6                      \n\t" // 0
-        "pcmpgtw %%mm4, %%mm6                   \n\t" // sign(2L2 - 5L3 + 5L4 - 2L5)
-        "pxor %%mm6, %%mm4                      \n\t"
-        "psubw %%mm6, %%mm4                     \n\t" // |2L2 - 5L3 + 5L4 - 2L5|
-        "pcmpgtw %%mm5, %%mm7                   \n\t" // sign(2H2 - 5H3 + 5H4 - 2H5)
-        "pxor %%mm7, %%mm5                      \n\t"
-        "psubw %%mm7, %%mm5                     \n\t" // |2H2 - 5H3 + 5H4 - 2H5|
-// 100 opcodes
-        "psllw $3, %%mm2                        \n\t" // 8QP
-        "movq %%mm2, %%mm3                      \n\t" // 8QP
-        "pcmpgtw %%mm4, %%mm2                   \n\t"
-        "pcmpgtw %%mm5, %%mm3                   \n\t"
-        "pand %%mm2, %%mm4                      \n\t"
-        "pand %%mm3, %%mm5                      \n\t"
-
-
-        "psubusw %%mm0, %%mm4                   \n\t" // hd
-        "psubusw %%mm1, %%mm5                   \n\t" // ld
-
-
-        "movq "MANGLE(w05)", %%mm2              \n\t" // 5
-        "pmullw %%mm2, %%mm4                    \n\t"
-        "pmullw %%mm2, %%mm5                    \n\t"
-        "movq "MANGLE(w20)", %%mm2              \n\t" // 32
-        "paddw %%mm2, %%mm4                     \n\t"
-        "paddw %%mm2, %%mm5                     \n\t"
-        "psrlw $6, %%mm4                        \n\t"
-        "psrlw $6, %%mm5                        \n\t"
-
-        "movq 16(%3), %%mm0                     \n\t" // L3 - L4
-        "movq 24(%3), %%mm1                     \n\t" // H3 - H4
-
-        "pxor %%mm2, %%mm2                      \n\t"
-        "pxor %%mm3, %%mm3                      \n\t"
-
-        "pcmpgtw %%mm0, %%mm2                   \n\t" // sign (L3-L4)
-        "pcmpgtw %%mm1, %%mm3                   \n\t" // sign (H3-H4)
-        "pxor %%mm2, %%mm0                      \n\t"
-        "pxor %%mm3, %%mm1                      \n\t"
-        "psubw %%mm2, %%mm0                     \n\t" // |L3-L4|
-        "psubw %%mm3, %%mm1                     \n\t" // |H3-H4|
-        "psrlw $1, %%mm0                        \n\t" // |L3 - L4|/2
-        "psrlw $1, %%mm1                        \n\t" // |H3 - H4|/2
-
-        "pxor %%mm6, %%mm2                      \n\t"
-        "pxor %%mm7, %%mm3                      \n\t"
-        "pand %%mm2, %%mm4                      \n\t"
-        "pand %%mm3, %%mm5                      \n\t"
-
-#if TEMPLATE_PP_MMXEXT
-        "pminsw %%mm0, %%mm4                    \n\t"
-        "pminsw %%mm1, %%mm5                    \n\t"
-#else
-        "movq %%mm4, %%mm2                      \n\t"
-        "psubusw %%mm0, %%mm2                   \n\t"
-        "psubw %%mm2, %%mm4                     \n\t"
-        "movq %%mm5, %%mm2                      \n\t"
-        "psubusw %%mm1, %%mm2                   \n\t"
-        "psubw %%mm2, %%mm5                     \n\t"
-#endif
-        "pxor %%mm6, %%mm4                      \n\t"
-        "pxor %%mm7, %%mm5                      \n\t"
-        "psubw %%mm6, %%mm4                     \n\t"
-        "psubw %%mm7, %%mm5                     \n\t"
-        "packsswb %%mm5, %%mm4                  \n\t"
-        "movq (%0), %%mm0                       \n\t"
-        "paddb   %%mm4, %%mm0                   \n\t"
-        "movq %%mm0, (%0)                       \n\t"
-        "movq (%0, %1), %%mm0                   \n\t"
-        "psubb %%mm4, %%mm0                     \n\t"
-        "movq %%mm0, (%0, %1)                   \n\t"
-
-        : "+r" (src)
-        : "r" ((x86_reg)stride), "m" (c->pQPb), "r"(tmp)
-        : "%"REG_a
-    );
-#else //TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-    const int l1= stride;
-    const int l2= stride + l1;
-    const int l3= stride + l2;
-    const int l4= stride + l3;
-    const int l5= stride + l4;
-    const int l6= stride + l5;
-    const int l7= stride + l6;
-    const int l8= stride + l7;
-//    const int l9= stride + l8;
-    int x;
-    src+= stride*3;
-    for(x=0; x<BLOCK_SIZE; x++){
-        const int middleEnergy= 5*(src[l5] - src[l4]) + 2*(src[l3] - src[l6]);
-        if(FFABS(middleEnergy) < 8*c->QP){
-            const int q=(src[l4] - src[l5])/2;
-            const int leftEnergy=  5*(src[l3] - src[l2]) + 2*(src[l1] - src[l4]);
-            const int rightEnergy= 5*(src[l7] - src[l6]) + 2*(src[l5] - src[l8]);
-
-            int d= FFABS(middleEnergy) - FFMIN( FFABS(leftEnergy), FFABS(rightEnergy) );
-            d= FFMAX(d, 0);
-
-            d= (5*d + 32) >> 6;
-            d*= FFSIGN(-middleEnergy);
-
-            if(q>0){
-                d= d<0 ? 0 : d;
-                d= d>q ? q : d;
-            }else{
-                d= d>0 ? 0 : d;
-                d= d<q ? q : d;
-            }
-
-            src[l4]-= d;
-            src[l5]+= d;
-        }
-        src++;
-    }
-#endif //TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-}
-#endif //TEMPLATE_PP_ALTIVEC
-
-#if !TEMPLATE_PP_ALTIVEC
-static inline void RENAME(dering)(uint8_t src[], int stride, PPContext *c)
-{
-#if HAVE_7REGS && (TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW)
-    DECLARE_ALIGNED(8, uint64_t, tmp)[3];
-    __asm__ volatile(
-        "pxor %%mm6, %%mm6                      \n\t"
-        "pcmpeqb %%mm7, %%mm7                   \n\t"
-        "movq %2, %%mm0                         \n\t"
-        "punpcklbw %%mm6, %%mm0                 \n\t"
-        "psrlw $1, %%mm0                        \n\t"
-        "psubw %%mm7, %%mm0                     \n\t"
-        "packuswb %%mm0, %%mm0                  \n\t"
-        "movq %%mm0, %3                         \n\t"
-
-        "lea (%0, %1), %%"REG_a"                \n\t"
-        "lea (%%"REG_a", %1, 4), %%"REG_d"      \n\t"
-
-//        0        1        2        3        4        5        6        7        8        9
-//        %0        eax        eax+%1        eax+2%1        %0+4%1        edx        edx+%1        edx+2%1        %0+8%1        edx+4%1
-
-#undef REAL_FIND_MIN_MAX
-#undef FIND_MIN_MAX
-#if TEMPLATE_PP_MMXEXT
-#define REAL_FIND_MIN_MAX(addr)\
-        "movq " #addr ", %%mm0                  \n\t"\
-        "pminub %%mm0, %%mm7                    \n\t"\
-        "pmaxub %%mm0, %%mm6                    \n\t"
-#else
-#define REAL_FIND_MIN_MAX(addr)\
-        "movq " #addr ", %%mm0                  \n\t"\
-        "movq %%mm7, %%mm1                      \n\t"\
-        "psubusb %%mm0, %%mm6                   \n\t"\
-        "paddb %%mm0, %%mm6                     \n\t"\
-        "psubusb %%mm0, %%mm1                   \n\t"\
-        "psubb %%mm1, %%mm7                     \n\t"
-#endif
-#define FIND_MIN_MAX(addr)  REAL_FIND_MIN_MAX(addr)
-
-FIND_MIN_MAX((%%REGa))
-FIND_MIN_MAX((%%REGa, %1))
-FIND_MIN_MAX((%%REGa, %1, 2))
-FIND_MIN_MAX((%0, %1, 4))
-FIND_MIN_MAX((%%REGd))
-FIND_MIN_MAX((%%REGd, %1))
-FIND_MIN_MAX((%%REGd, %1, 2))
-FIND_MIN_MAX((%0, %1, 8))
-
-        "movq %%mm7, %%mm4                      \n\t"
-        "psrlq $8, %%mm7                        \n\t"
-#if TEMPLATE_PP_MMXEXT
-        "pminub %%mm4, %%mm7                    \n\t" // min of pixels
-        "pshufw $0xF9, %%mm7, %%mm4             \n\t"
-        "pminub %%mm4, %%mm7                    \n\t" // min of pixels
-        "pshufw $0xFE, %%mm7, %%mm4             \n\t"
-        "pminub %%mm4, %%mm7                    \n\t"
-#else
-        "movq %%mm7, %%mm1                      \n\t"
-        "psubusb %%mm4, %%mm1                   \n\t"
-        "psubb %%mm1, %%mm7                     \n\t"
-        "movq %%mm7, %%mm4                      \n\t"
-        "psrlq $16, %%mm7                       \n\t"
-        "movq %%mm7, %%mm1                      \n\t"
-        "psubusb %%mm4, %%mm1                   \n\t"
-        "psubb %%mm1, %%mm7                     \n\t"
-        "movq %%mm7, %%mm4                      \n\t"
-        "psrlq $32, %%mm7                       \n\t"
-        "movq %%mm7, %%mm1                      \n\t"
-        "psubusb %%mm4, %%mm1                   \n\t"
-        "psubb %%mm1, %%mm7                     \n\t"
-#endif
-
-
-        "movq %%mm6, %%mm4                      \n\t"
-        "psrlq $8, %%mm6                        \n\t"
-#if TEMPLATE_PP_MMXEXT
-        "pmaxub %%mm4, %%mm6                    \n\t" // max of pixels
-        "pshufw $0xF9, %%mm6, %%mm4             \n\t"
-        "pmaxub %%mm4, %%mm6                    \n\t"
-        "pshufw $0xFE, %%mm6, %%mm4             \n\t"
-        "pmaxub %%mm4, %%mm6                    \n\t"
-#else
-        "psubusb %%mm4, %%mm6                   \n\t"
-        "paddb %%mm4, %%mm6                     \n\t"
-        "movq %%mm6, %%mm4                      \n\t"
-        "psrlq $16, %%mm6                       \n\t"
-        "psubusb %%mm4, %%mm6                   \n\t"
-        "paddb %%mm4, %%mm6                     \n\t"
-        "movq %%mm6, %%mm4                      \n\t"
-        "psrlq $32, %%mm6                       \n\t"
-        "psubusb %%mm4, %%mm6                   \n\t"
-        "paddb %%mm4, %%mm6                     \n\t"
-#endif
-        "movq %%mm6, %%mm0                      \n\t" // max
-        "psubb %%mm7, %%mm6                     \n\t" // max - min
-        "push %4                              \n\t"
-        "movd %%mm6, %k4                        \n\t"
-        "cmpb "MANGLE(deringThreshold)", %b4    \n\t"
-        "pop %4                               \n\t"
-        " jb 1f                                 \n\t"
-        PAVGB(%%mm0, %%mm7)                           // a=(max + min)/2
-        "punpcklbw %%mm7, %%mm7                 \n\t"
-        "punpcklbw %%mm7, %%mm7                 \n\t"
-        "punpcklbw %%mm7, %%mm7                 \n\t"
-        "movq %%mm7, (%4)                       \n\t"
-
-        "movq (%0), %%mm0                       \n\t" // L10
-        "movq %%mm0, %%mm1                      \n\t" // L10
-        "movq %%mm0, %%mm2                      \n\t" // L10
-        "psllq $8, %%mm1                        \n\t"
-        "psrlq $8, %%mm2                        \n\t"
-        "movd -4(%0), %%mm3                     \n\t"
-        "movd 8(%0), %%mm4                      \n\t"
-        "psrlq $24, %%mm3                       \n\t"
-        "psllq $56, %%mm4                       \n\t"
-        "por %%mm3, %%mm1                       \n\t" // L00
-        "por %%mm4, %%mm2                       \n\t" // L20
-        "movq %%mm1, %%mm3                      \n\t" // L00
-        PAVGB(%%mm2, %%mm1)                           // (L20 + L00)/2
-        PAVGB(%%mm0, %%mm1)                           // (L20 + L00 + 2L10)/4
-        "psubusb %%mm7, %%mm0                   \n\t"
-        "psubusb %%mm7, %%mm2                   \n\t"
-        "psubusb %%mm7, %%mm3                   \n\t"
-        "pcmpeqb "MANGLE(b00)", %%mm0           \n\t" // L10 > a ? 0 : -1
-        "pcmpeqb "MANGLE(b00)", %%mm2           \n\t" // L20 > a ? 0 : -1
-        "pcmpeqb "MANGLE(b00)", %%mm3           \n\t" // L00 > a ? 0 : -1
-        "paddb %%mm2, %%mm0                     \n\t"
-        "paddb %%mm3, %%mm0                     \n\t"
-
-        "movq (%%"REG_a"), %%mm2                \n\t" // L11
-        "movq %%mm2, %%mm3                      \n\t" // L11
-        "movq %%mm2, %%mm4                      \n\t" // L11
-        "psllq $8, %%mm3                        \n\t"
-        "psrlq $8, %%mm4                        \n\t"
-        "movd -4(%%"REG_a"), %%mm5              \n\t"
-        "movd 8(%%"REG_a"), %%mm6               \n\t"
-        "psrlq $24, %%mm5                       \n\t"
-        "psllq $56, %%mm6                       \n\t"
-        "por %%mm5, %%mm3                       \n\t" // L01
-        "por %%mm6, %%mm4                       \n\t" // L21
-        "movq %%mm3, %%mm5                      \n\t" // L01
-        PAVGB(%%mm4, %%mm3)                           // (L21 + L01)/2
-        PAVGB(%%mm2, %%mm3)                           // (L21 + L01 + 2L11)/4
-        "psubusb %%mm7, %%mm2                   \n\t"
-        "psubusb %%mm7, %%mm4                   \n\t"
-        "psubusb %%mm7, %%mm5                   \n\t"
-        "pcmpeqb "MANGLE(b00)", %%mm2           \n\t" // L11 > a ? 0 : -1
-        "pcmpeqb "MANGLE(b00)", %%mm4           \n\t" // L21 > a ? 0 : -1
-        "pcmpeqb "MANGLE(b00)", %%mm5           \n\t" // L01 > a ? 0 : -1
-        "paddb %%mm4, %%mm2                     \n\t"
-        "paddb %%mm5, %%mm2                     \n\t"
-// 0, 2, 3, 1
-#define REAL_DERING_CORE(dst,src,ppsx,psx,sx,pplx,plx,lx,t0,t1) \
-        "movq " #src ", " #sx "                 \n\t" /* src[0] */\
-        "movq " #sx ", " #lx "                  \n\t" /* src[0] */\
-        "movq " #sx ", " #t0 "                  \n\t" /* src[0] */\
-        "psllq $8, " #lx "                      \n\t"\
-        "psrlq $8, " #t0 "                      \n\t"\
-        "movd -4" #src ", " #t1 "               \n\t"\
-        "psrlq $24, " #t1 "                     \n\t"\
-        "por " #t1 ", " #lx "                   \n\t" /* src[-1] */\
-        "movd 8" #src ", " #t1 "                \n\t"\
-        "psllq $56, " #t1 "                     \n\t"\
-        "por " #t1 ", " #t0 "                   \n\t" /* src[+1] */\
-        "movq " #lx ", " #t1 "                  \n\t" /* src[-1] */\
-        PAVGB(t0, lx)                                 /* (src[-1] + src[+1])/2 */\
-        PAVGB(sx, lx)                                 /* (src[-1] + 2src[0] + src[+1])/4 */\
-        PAVGB(lx, pplx)                                     \
-        "movq " #lx ", 8(%4)                    \n\t"\
-        "movq (%4), " #lx "                     \n\t"\
-        "psubusb " #lx ", " #t1 "               \n\t"\
-        "psubusb " #lx ", " #t0 "               \n\t"\
-        "psubusb " #lx ", " #sx "               \n\t"\
-        "movq "MANGLE(b00)", " #lx "            \n\t"\
-        "pcmpeqb " #lx ", " #t1 "               \n\t" /* src[-1] > a ? 0 : -1*/\
-        "pcmpeqb " #lx ", " #t0 "               \n\t" /* src[+1] > a ? 0 : -1*/\
-        "pcmpeqb " #lx ", " #sx "               \n\t" /* src[0]  > a ? 0 : -1*/\
-        "paddb " #t1 ", " #t0 "                 \n\t"\
-        "paddb " #t0 ", " #sx "                 \n\t"\
-\
-        PAVGB(plx, pplx)                              /* filtered */\
-        "movq " #dst ", " #t0 "                 \n\t" /* dst */\
-        "movq " #t0 ", " #t1 "                  \n\t" /* dst */\
-        "psubusb %3, " #t0 "                    \n\t"\
-        "paddusb %3, " #t1 "                    \n\t"\
-        PMAXUB(t0, pplx)\
-        PMINUB(t1, pplx, t0)\
-        "paddb " #sx ", " #ppsx "               \n\t"\
-        "paddb " #psx ", " #ppsx "              \n\t"\
-        "#paddb "MANGLE(b02)", " #ppsx "        \n\t"\
-        "pand "MANGLE(b08)", " #ppsx "          \n\t"\
-        "pcmpeqb " #lx ", " #ppsx "             \n\t"\
-        "pand " #ppsx ", " #pplx "              \n\t"\
-        "pandn " #dst ", " #ppsx "              \n\t"\
-        "por " #pplx ", " #ppsx "               \n\t"\
-        "movq " #ppsx ", " #dst "               \n\t"\
-        "movq 8(%4), " #lx "                    \n\t"
-
-#define DERING_CORE(dst,src,ppsx,psx,sx,pplx,plx,lx,t0,t1) \
-   REAL_DERING_CORE(dst,src,ppsx,psx,sx,pplx,plx,lx,t0,t1)
-/*
-0000000
-1111111
-
-1111110
-1111101
-1111100
-1111011
-1111010
-1111001
-
-1111000
-1110111
-
-*/
-//DERING_CORE(dst          ,src            ,ppsx ,psx  ,sx   ,pplx ,plx  ,lx   ,t0   ,t1)
-DERING_CORE((%%REGa)       ,(%%REGa, %1)   ,%%mm0,%%mm2,%%mm4,%%mm1,%%mm3,%%mm5,%%mm6,%%mm7)
-DERING_CORE((%%REGa, %1)   ,(%%REGa, %1, 2),%%mm2,%%mm4,%%mm0,%%mm3,%%mm5,%%mm1,%%mm6,%%mm7)
-DERING_CORE((%%REGa, %1, 2),(%0, %1, 4)    ,%%mm4,%%mm0,%%mm2,%%mm5,%%mm1,%%mm3,%%mm6,%%mm7)
-DERING_CORE((%0, %1, 4)    ,(%%REGd)       ,%%mm0,%%mm2,%%mm4,%%mm1,%%mm3,%%mm5,%%mm6,%%mm7)
-DERING_CORE((%%REGd)       ,(%%REGd, %1)   ,%%mm2,%%mm4,%%mm0,%%mm3,%%mm5,%%mm1,%%mm6,%%mm7)
-DERING_CORE((%%REGd, %1)   ,(%%REGd, %1, 2),%%mm4,%%mm0,%%mm2,%%mm5,%%mm1,%%mm3,%%mm6,%%mm7)
-DERING_CORE((%%REGd, %1, 2),(%0, %1, 8)    ,%%mm0,%%mm2,%%mm4,%%mm1,%%mm3,%%mm5,%%mm6,%%mm7)
-DERING_CORE((%0, %1, 8)    ,(%%REGd, %1, 4),%%mm2,%%mm4,%%mm0,%%mm3,%%mm5,%%mm1,%%mm6,%%mm7)
-
-        "1:                        \n\t"
-        : : "r" (src), "r" ((x86_reg)stride), "m" (c->pQPb), "m"(c->pQPb2), "q"(tmp)
-        : "%"REG_a, "%"REG_d, "%"REG_SP
-    );
-#else // HAVE_7REGS && (TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW)
-    int y;
-    int min=255;
-    int max=0;
-    int avg;
-    uint8_t *p;
-    int s[10];
-    const int QP2= c->QP/2 + 1;
-
-    src --;
-    for(y=1; y<9; y++){
-        int x;
-        p= src + stride*y;
-        for(x=1; x<9; x++){
-            p++;
-            if(*p > max) max= *p;
-            if(*p < min) min= *p;
-        }
-    }
-    avg= (min + max + 1)>>1;
-
-    if(max - min <deringThreshold) return;
-
-    for(y=0; y<10; y++){
-        int t = 0;
-
-        if(src[stride*y + 0] > avg) t+= 1;
-        if(src[stride*y + 1] > avg) t+= 2;
-        if(src[stride*y + 2] > avg) t+= 4;
-        if(src[stride*y + 3] > avg) t+= 8;
-        if(src[stride*y + 4] > avg) t+= 16;
-        if(src[stride*y + 5] > avg) t+= 32;
-        if(src[stride*y + 6] > avg) t+= 64;
-        if(src[stride*y + 7] > avg) t+= 128;
-        if(src[stride*y + 8] > avg) t+= 256;
-        if(src[stride*y + 9] > avg) t+= 512;
-
-        t |= (~t)<<16;
-        t &= (t<<1) & (t>>1);
-        s[y] = t;
-    }
-
-    for(y=1; y<9; y++){
-        int t = s[y-1] & s[y] & s[y+1];
-        t|= t>>16;
-        s[y-1]= t;
-    }
-
-    for(y=1; y<9; y++){
-        int x;
-        int t = s[y-1];
-
-        p= src + stride*y;
-        for(x=1; x<9; x++){
-            p++;
-            if(t & (1<<x)){
-                int f= (*(p-stride-1)) + 2*(*(p-stride)) + (*(p-stride+1))
-                      +2*(*(p     -1)) + 4*(*p         ) + 2*(*(p     +1))
-                      +(*(p+stride-1)) + 2*(*(p+stride)) + (*(p+stride+1));
-                f= (f + 8)>>4;
-
-#ifdef DEBUG_DERING_THRESHOLD
-                    __asm__ volatile("emms\n\t":);
-                    {
-                    static long long numPixels=0;
-                    if(x!=1 && x!=8 && y!=1 && y!=8) numPixels++;
-//                    if((max-min)<20 || (max-min)*QP<200)
-//                    if((max-min)*QP < 500)
-//                    if(max-min<QP/2)
-                    if(max-min < 20){
-                        static int numSkipped=0;
-                        static int errorSum=0;
-                        static int worstQP=0;
-                        static int worstRange=0;
-                        static int worstDiff=0;
-                        int diff= (f - *p);
-                        int absDiff= FFABS(diff);
-                        int error= diff*diff;
-
-                        if(x==1 || x==8 || y==1 || y==8) continue;
-
-                        numSkipped++;
-                        if(absDiff > worstDiff){
-                            worstDiff= absDiff;
-                            worstQP= QP;
-                            worstRange= max-min;
-                        }
-                        errorSum+= error;
-
-                        if(1024LL*1024LL*1024LL % numSkipped == 0){
-                            av_log(c, AV_LOG_INFO, "sum:%1.3f, skip:%d, wQP:%d, "
-                                   "wRange:%d, wDiff:%d, relSkip:%1.3f\n",
-                                   (float)errorSum/numSkipped, numSkipped, worstQP, worstRange,
-                                   worstDiff, (float)numSkipped/numPixels);
-                        }
-                    }
-                    }
-#endif
-                    if     (*p + QP2 < f) *p= *p + QP2;
-                    else if(*p - QP2 > f) *p= *p - QP2;
-                    else *p=f;
-            }
-        }
-    }
-#ifdef DEBUG_DERING_THRESHOLD
-    if(max-min < 20){
-        for(y=1; y<9; y++){
-            int x;
-            int t = 0;
-            p= src + stride*y;
-            for(x=1; x<9; x++){
-                p++;
-                *p = FFMIN(*p + 20, 255);
-            }
-        }
-//        src[0] = src[7]=src[stride*7]=src[stride*7 + 7]=255;
-    }
-#endif
-#endif //TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-}
-#endif //TEMPLATE_PP_ALTIVEC
-
-/**
- * Deinterlace the given block by linearly interpolating every second line.
- * will be called for every 8x8 block and can read & write from line 4-15
- * lines 0-3 have been passed through the deblock / dering filters already, but can be read, too.
- * lines 4-12 will be read into the deblocking filter and should be deinterlaced
- */
-static inline void RENAME(deInterlaceInterpolateLinear)(uint8_t src[], int stride)
-{
-#if TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-    src+= 4*stride;
-    __asm__ volatile(
-        "lea (%0, %1), %%"REG_a"                \n\t"
-        "lea (%%"REG_a", %1, 4), %%"REG_c"      \n\t"
-//      0       1       2       3       4       5       6       7       8       9
-//      %0      eax     eax+%1  eax+2%1 %0+4%1  ecx     ecx+%1  ecx+2%1 %0+8%1  ecx+4%1
-
-        "movq (%0), %%mm0                       \n\t"
-        "movq (%%"REG_a", %1), %%mm1            \n\t"
-        PAVGB(%%mm1, %%mm0)
-        "movq %%mm0, (%%"REG_a")                \n\t"
-        "movq (%0, %1, 4), %%mm0                \n\t"
-        PAVGB(%%mm0, %%mm1)
-        "movq %%mm1, (%%"REG_a", %1, 2)         \n\t"
-        "movq (%%"REG_c", %1), %%mm1            \n\t"
-        PAVGB(%%mm1, %%mm0)
-        "movq %%mm0, (%%"REG_c")                \n\t"
-        "movq (%0, %1, 8), %%mm0                \n\t"
-        PAVGB(%%mm0, %%mm1)
-        "movq %%mm1, (%%"REG_c", %1, 2)         \n\t"
-
-        : : "r" (src), "r" ((x86_reg)stride)
-        : "%"REG_a, "%"REG_c
-    );
-#else
-    int a, b, x;
-    src+= 4*stride;
-
-    for(x=0; x<2; x++){
-        a= *(uint32_t*)&src[stride*0];
-        b= *(uint32_t*)&src[stride*2];
-        *(uint32_t*)&src[stride*1]= (a|b) - (((a^b)&0xFEFEFEFEUL)>>1);
-        a= *(uint32_t*)&src[stride*4];
-        *(uint32_t*)&src[stride*3]= (a|b) - (((a^b)&0xFEFEFEFEUL)>>1);
-        b= *(uint32_t*)&src[stride*6];
-        *(uint32_t*)&src[stride*5]= (a|b) - (((a^b)&0xFEFEFEFEUL)>>1);
-        a= *(uint32_t*)&src[stride*8];
-        *(uint32_t*)&src[stride*7]= (a|b) - (((a^b)&0xFEFEFEFEUL)>>1);
-        src += 4;
-    }
-#endif
-}
-
-/**
- * Deinterlace the given block by cubic interpolating every second line.
- * will be called for every 8x8 block and can read & write from line 4-15
- * lines 0-3 have been passed through the deblock / dering filters already, but can be read, too.
- * lines 4-12 will be read into the deblocking filter and should be deinterlaced
- * this filter will read lines 3-15 and write 7-13
- */
-static inline void RENAME(deInterlaceInterpolateCubic)(uint8_t src[], int stride)
-{
-#if TEMPLATE_PP_SSE2 || TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-    src+= stride*3;
-    __asm__ volatile(
-        "lea (%0, %1), %%"REG_a"                \n\t"
-        "lea (%%"REG_a", %1, 4), %%"REG_d"      \n\t"
-        "lea (%%"REG_d", %1, 4), %%"REG_c"      \n\t"
-        "add %1, %%"REG_c"                      \n\t"
-#if TEMPLATE_PP_SSE2
-        "pxor %%xmm7, %%xmm7                    \n\t"
-#define REAL_DEINT_CUBIC(a,b,c,d,e)\
-        "movq " #a ", %%xmm0                    \n\t"\
-        "movq " #b ", %%xmm1                    \n\t"\
-        "movq " #d ", %%xmm2                    \n\t"\
-        "movq " #e ", %%xmm3                    \n\t"\
-        "pavgb %%xmm2, %%xmm1                   \n\t"\
-        "pavgb %%xmm3, %%xmm0                   \n\t"\
-        "punpcklbw %%xmm7, %%xmm0               \n\t"\
-        "punpcklbw %%xmm7, %%xmm1               \n\t"\
-        "psubw %%xmm1, %%xmm0                   \n\t"\
-        "psraw $3, %%xmm0                       \n\t"\
-        "psubw %%xmm0, %%xmm1                   \n\t"\
-        "packuswb %%xmm1, %%xmm1                \n\t"\
-        "movlps %%xmm1, " #c "                  \n\t"
-#else //TEMPLATE_PP_SSE2
-        "pxor %%mm7, %%mm7                      \n\t"
-//      0       1       2       3       4       5       6       7       8       9       10
-//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1 ecx
-
-#define REAL_DEINT_CUBIC(a,b,c,d,e)\
-        "movq " #a ", %%mm0                     \n\t"\
-        "movq " #b ", %%mm1                     \n\t"\
-        "movq " #d ", %%mm2                     \n\t"\
-        "movq " #e ", %%mm3                     \n\t"\
-        PAVGB(%%mm2, %%mm1)                             /* (b+d) /2 */\
-        PAVGB(%%mm3, %%mm0)                             /* (a+e) /2 */\
-        "movq %%mm0, %%mm2                      \n\t"\
-        "punpcklbw %%mm7, %%mm0                 \n\t"\
-        "punpckhbw %%mm7, %%mm2                 \n\t"\
-        "movq %%mm1, %%mm3                      \n\t"\
-        "punpcklbw %%mm7, %%mm1                 \n\t"\
-        "punpckhbw %%mm7, %%mm3                 \n\t"\
-        "psubw %%mm1, %%mm0                     \n\t"   /* L(a+e - (b+d))/2 */\
-        "psubw %%mm3, %%mm2                     \n\t"   /* H(a+e - (b+d))/2 */\
-        "psraw $3, %%mm0                        \n\t"   /* L(a+e - (b+d))/16 */\
-        "psraw $3, %%mm2                        \n\t"   /* H(a+e - (b+d))/16 */\
-        "psubw %%mm0, %%mm1                     \n\t"   /* L(9b + 9d - a - e)/16 */\
-        "psubw %%mm2, %%mm3                     \n\t"   /* H(9b + 9d - a - e)/16 */\
-        "packuswb %%mm3, %%mm1                  \n\t"\
-        "movq %%mm1, " #c "                     \n\t"
-#endif //TEMPLATE_PP_SSE2
-#define DEINT_CUBIC(a,b,c,d,e)  REAL_DEINT_CUBIC(a,b,c,d,e)
-
-DEINT_CUBIC((%0)        , (%%REGa, %1), (%%REGa, %1, 2), (%0, %1, 4) , (%%REGd, %1))
-DEINT_CUBIC((%%REGa, %1), (%0, %1, 4) , (%%REGd)       , (%%REGd, %1), (%0, %1, 8))
-DEINT_CUBIC((%0, %1, 4) , (%%REGd, %1), (%%REGd, %1, 2), (%0, %1, 8) , (%%REGc))
-DEINT_CUBIC((%%REGd, %1), (%0, %1, 8) , (%%REGd, %1, 4), (%%REGc)    , (%%REGc, %1, 2))
-
-        : : "r" (src), "r" ((x86_reg)stride)
-        :
-#if TEMPLATE_PP_SSE2
-        XMM_CLOBBERS("%xmm0", "%xmm1", "%xmm2", "%xmm3", "%xmm7",)
-#endif
-        "%"REG_a, "%"REG_d, "%"REG_c
-    );
-#undef REAL_DEINT_CUBIC
-#else //TEMPLATE_PP_SSE2 || TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-    int x;
-    src+= stride*3;
-    for(x=0; x<8; x++){
-        src[stride*3] = CLIP((-src[0]        + 9*src[stride*2] + 9*src[stride*4] - src[stride*6])>>4);
-        src[stride*5] = CLIP((-src[stride*2] + 9*src[stride*4] + 9*src[stride*6] - src[stride*8])>>4);
-        src[stride*7] = CLIP((-src[stride*4] + 9*src[stride*6] + 9*src[stride*8] - src[stride*10])>>4);
-        src[stride*9] = CLIP((-src[stride*6] + 9*src[stride*8] + 9*src[stride*10] - src[stride*12])>>4);
-        src++;
-    }
-#endif //TEMPLATE_PP_SSE2 || TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-}
-
-/**
- * Deinterlace the given block by filtering every second line with a (-1 4 2 4 -1) filter.
- * will be called for every 8x8 block and can read & write from line 4-15
- * lines 0-3 have been passed through the deblock / dering filters already, but can be read, too.
- * lines 4-12 will be read into the deblocking filter and should be deinterlaced
- * this filter will read lines 4-13 and write 5-11
- */
-static inline void RENAME(deInterlaceFF)(uint8_t src[], int stride, uint8_t *tmp)
-{
-#if TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-    src+= stride*4;
-    __asm__ volatile(
-        "lea (%0, %1), %%"REG_a"                \n\t"
-        "lea (%%"REG_a", %1, 4), %%"REG_d"      \n\t"
-        "pxor %%mm7, %%mm7                      \n\t"
-        "movq (%2), %%mm0                       \n\t"
-//      0       1       2       3       4       5       6       7       8       9       10
-//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1 ecx
-
-#define REAL_DEINT_FF(a,b,c,d)\
-        "movq " #a ", %%mm1                     \n\t"\
-        "movq " #b ", %%mm2                     \n\t"\
-        "movq " #c ", %%mm3                     \n\t"\
-        "movq " #d ", %%mm4                     \n\t"\
-        PAVGB(%%mm3, %%mm1)                          \
-        PAVGB(%%mm4, %%mm0)                          \
-        "movq %%mm0, %%mm3                      \n\t"\
-        "punpcklbw %%mm7, %%mm0                 \n\t"\
-        "punpckhbw %%mm7, %%mm3                 \n\t"\
-        "movq %%mm1, %%mm4                      \n\t"\
-        "punpcklbw %%mm7, %%mm1                 \n\t"\
-        "punpckhbw %%mm7, %%mm4                 \n\t"\
-        "psllw $2, %%mm1                        \n\t"\
-        "psllw $2, %%mm4                        \n\t"\
-        "psubw %%mm0, %%mm1                     \n\t"\
-        "psubw %%mm3, %%mm4                     \n\t"\
-        "movq %%mm2, %%mm5                      \n\t"\
-        "movq %%mm2, %%mm0                      \n\t"\
-        "punpcklbw %%mm7, %%mm2                 \n\t"\
-        "punpckhbw %%mm7, %%mm5                 \n\t"\
-        "paddw %%mm2, %%mm1                     \n\t"\
-        "paddw %%mm5, %%mm4                     \n\t"\
-        "psraw $2, %%mm1                        \n\t"\
-        "psraw $2, %%mm4                        \n\t"\
-        "packuswb %%mm4, %%mm1                  \n\t"\
-        "movq %%mm1, " #b "                     \n\t"\
-
-#define DEINT_FF(a,b,c,d)  REAL_DEINT_FF(a,b,c,d)
-
-DEINT_FF((%0)        , (%%REGa)       , (%%REGa, %1), (%%REGa, %1, 2))
-DEINT_FF((%%REGa, %1), (%%REGa, %1, 2), (%0, %1, 4) , (%%REGd)       )
-DEINT_FF((%0, %1, 4) , (%%REGd)       , (%%REGd, %1), (%%REGd, %1, 2))
-DEINT_FF((%%REGd, %1), (%%REGd, %1, 2), (%0, %1, 8) , (%%REGd, %1, 4))
-
-        "movq %%mm0, (%2)                       \n\t"
-        : : "r" (src), "r" ((x86_reg)stride), "r"(tmp)
-        : "%"REG_a, "%"REG_d
-    );
-#else //TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-    int x;
-    src+= stride*4;
-    for(x=0; x<8; x++){
-        int t1= tmp[x];
-        int t2= src[stride*1];
-
-        src[stride*1]= CLIP((-t1 + 4*src[stride*0] + 2*t2 + 4*src[stride*2] - src[stride*3] + 4)>>3);
-        t1= src[stride*4];
-        src[stride*3]= CLIP((-t2 + 4*src[stride*2] + 2*t1 + 4*src[stride*4] - src[stride*5] + 4)>>3);
-        t2= src[stride*6];
-        src[stride*5]= CLIP((-t1 + 4*src[stride*4] + 2*t2 + 4*src[stride*6] - src[stride*7] + 4)>>3);
-        t1= src[stride*8];
-        src[stride*7]= CLIP((-t2 + 4*src[stride*6] + 2*t1 + 4*src[stride*8] - src[stride*9] + 4)>>3);
-        tmp[x]= t1;
-
-        src++;
-    }
-#endif //TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-}
-
-/**
- * Deinterlace the given block by filtering every line with a (-1 2 6 2 -1) filter.
- * will be called for every 8x8 block and can read & write from line 4-15
- * lines 0-3 have been passed through the deblock / dering filters already, but can be read, too.
- * lines 4-12 will be read into the deblocking filter and should be deinterlaced
- * this filter will read lines 4-13 and write 4-11
- */
-static inline void RENAME(deInterlaceL5)(uint8_t src[], int stride, uint8_t *tmp, uint8_t *tmp2)
-{
-#if TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-    src+= stride*4;
-    __asm__ volatile(
-        "lea (%0, %1), %%"REG_a"                \n\t"
-        "lea (%%"REG_a", %1, 4), %%"REG_d"      \n\t"
-        "pxor %%mm7, %%mm7                      \n\t"
-        "movq (%2), %%mm0                       \n\t"
-        "movq (%3), %%mm1                       \n\t"
-//      0       1       2       3       4       5       6       7       8       9       10
-//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1 ecx
-
-#define REAL_DEINT_L5(t1,t2,a,b,c)\
-        "movq " #a ", %%mm2                     \n\t"\
-        "movq " #b ", %%mm3                     \n\t"\
-        "movq " #c ", %%mm4                     \n\t"\
-        PAVGB(t2, %%mm3)                             \
-        PAVGB(t1, %%mm4)                             \
-        "movq %%mm2, %%mm5                      \n\t"\
-        "movq %%mm2, " #t1 "                    \n\t"\
-        "punpcklbw %%mm7, %%mm2                 \n\t"\
-        "punpckhbw %%mm7, %%mm5                 \n\t"\
-        "movq %%mm2, %%mm6                      \n\t"\
-        "paddw %%mm2, %%mm2                     \n\t"\
-        "paddw %%mm6, %%mm2                     \n\t"\
-        "movq %%mm5, %%mm6                      \n\t"\
-        "paddw %%mm5, %%mm5                     \n\t"\
-        "paddw %%mm6, %%mm5                     \n\t"\
-        "movq %%mm3, %%mm6                      \n\t"\
-        "punpcklbw %%mm7, %%mm3                 \n\t"\
-        "punpckhbw %%mm7, %%mm6                 \n\t"\
-        "paddw %%mm3, %%mm3                     \n\t"\
-        "paddw %%mm6, %%mm6                     \n\t"\
-        "paddw %%mm3, %%mm2                     \n\t"\
-        "paddw %%mm6, %%mm5                     \n\t"\
-        "movq %%mm4, %%mm6                      \n\t"\
-        "punpcklbw %%mm7, %%mm4                 \n\t"\
-        "punpckhbw %%mm7, %%mm6                 \n\t"\
-        "psubw %%mm4, %%mm2                     \n\t"\
-        "psubw %%mm6, %%mm5                     \n\t"\
-        "psraw $2, %%mm2                        \n\t"\
-        "psraw $2, %%mm5                        \n\t"\
-        "packuswb %%mm5, %%mm2                  \n\t"\
-        "movq %%mm2, " #a "                     \n\t"\
-
-#define DEINT_L5(t1,t2,a,b,c)  REAL_DEINT_L5(t1,t2,a,b,c)
-
-DEINT_L5(%%mm0, %%mm1, (%0)           , (%%REGa)       , (%%REGa, %1)   )
-DEINT_L5(%%mm1, %%mm0, (%%REGa)       , (%%REGa, %1)   , (%%REGa, %1, 2))
-DEINT_L5(%%mm0, %%mm1, (%%REGa, %1)   , (%%REGa, %1, 2), (%0, %1, 4)   )
-DEINT_L5(%%mm1, %%mm0, (%%REGa, %1, 2), (%0, %1, 4)    , (%%REGd)       )
-DEINT_L5(%%mm0, %%mm1, (%0, %1, 4)    , (%%REGd)       , (%%REGd, %1)   )
-DEINT_L5(%%mm1, %%mm0, (%%REGd)       , (%%REGd, %1)   , (%%REGd, %1, 2))
-DEINT_L5(%%mm0, %%mm1, (%%REGd, %1)   , (%%REGd, %1, 2), (%0, %1, 8)   )
-DEINT_L5(%%mm1, %%mm0, (%%REGd, %1, 2), (%0, %1, 8)    , (%%REGd, %1, 4))
-
-        "movq %%mm0, (%2)                       \n\t"
-        "movq %%mm1, (%3)                       \n\t"
-        : : "r" (src), "r" ((x86_reg)stride), "r"(tmp), "r"(tmp2)
-        : "%"REG_a, "%"REG_d
-    );
-#else //TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-    int x;
-    src+= stride*4;
-    for(x=0; x<8; x++){
-        int t1= tmp[x];
-        int t2= tmp2[x];
-        int t3= src[0];
-
-        src[stride*0]= CLIP((-(t1 + src[stride*2]) + 2*(t2 + src[stride*1]) + 6*t3 + 4)>>3);
-        t1= src[stride*1];
-        src[stride*1]= CLIP((-(t2 + src[stride*3]) + 2*(t3 + src[stride*2]) + 6*t1 + 4)>>3);
-        t2= src[stride*2];
-        src[stride*2]= CLIP((-(t3 + src[stride*4]) + 2*(t1 + src[stride*3]) + 6*t2 + 4)>>3);
-        t3= src[stride*3];
-        src[stride*3]= CLIP((-(t1 + src[stride*5]) + 2*(t2 + src[stride*4]) + 6*t3 + 4)>>3);
-        t1= src[stride*4];
-        src[stride*4]= CLIP((-(t2 + src[stride*6]) + 2*(t3 + src[stride*5]) + 6*t1 + 4)>>3);
-        t2= src[stride*5];
-        src[stride*5]= CLIP((-(t3 + src[stride*7]) + 2*(t1 + src[stride*6]) + 6*t2 + 4)>>3);
-        t3= src[stride*6];
-        src[stride*6]= CLIP((-(t1 + src[stride*8]) + 2*(t2 + src[stride*7]) + 6*t3 + 4)>>3);
-        t1= src[stride*7];
-        src[stride*7]= CLIP((-(t2 + src[stride*9]) + 2*(t3 + src[stride*8]) + 6*t1 + 4)>>3);
-
-        tmp[x]= t3;
-        tmp2[x]= t1;
-
-        src++;
-    }
-#endif //TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-}
-
-/**
- * Deinterlace the given block by filtering all lines with a (1 2 1) filter.
- * will be called for every 8x8 block and can read & write from line 4-15
- * lines 0-3 have been passed through the deblock / dering filters already, but can be read, too.
- * lines 4-12 will be read into the deblocking filter and should be deinterlaced
- * this filter will read lines 4-13 and write 4-11
- */
-static inline void RENAME(deInterlaceBlendLinear)(uint8_t src[], int stride, uint8_t *tmp)
-{
-#if TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-    src+= 4*stride;
-    __asm__ volatile(
-        "lea (%0, %1), %%"REG_a"                \n\t"
-        "lea (%%"REG_a", %1, 4), %%"REG_d"      \n\t"
-//      0       1       2       3       4       5       6       7       8       9
-//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1
-
-        "movq (%2), %%mm0                       \n\t" // L0
-        "movq (%%"REG_a"), %%mm1                \n\t" // L2
-        PAVGB(%%mm1, %%mm0)                           // L0+L2
-        "movq (%0), %%mm2                       \n\t" // L1
-        PAVGB(%%mm2, %%mm0)
-        "movq %%mm0, (%0)                       \n\t"
-        "movq (%%"REG_a", %1), %%mm0            \n\t" // L3
-        PAVGB(%%mm0, %%mm2)                           // L1+L3
-        PAVGB(%%mm1, %%mm2)                           // 2L2 + L1 + L3
-        "movq %%mm2, (%%"REG_a")                \n\t"
-        "movq (%%"REG_a", %1, 2), %%mm2         \n\t" // L4
-        PAVGB(%%mm2, %%mm1)                           // L2+L4
-        PAVGB(%%mm0, %%mm1)                           // 2L3 + L2 + L4
-        "movq %%mm1, (%%"REG_a", %1)            \n\t"
-        "movq (%0, %1, 4), %%mm1                \n\t" // L5
-        PAVGB(%%mm1, %%mm0)                           // L3+L5
-        PAVGB(%%mm2, %%mm0)                           // 2L4 + L3 + L5
-        "movq %%mm0, (%%"REG_a", %1, 2)         \n\t"
-        "movq (%%"REG_d"), %%mm0                \n\t" // L6
-        PAVGB(%%mm0, %%mm2)                           // L4+L6
-        PAVGB(%%mm1, %%mm2)                           // 2L5 + L4 + L6
-        "movq %%mm2, (%0, %1, 4)                \n\t"
-        "movq (%%"REG_d", %1), %%mm2            \n\t" // L7
-        PAVGB(%%mm2, %%mm1)                           // L5+L7
-        PAVGB(%%mm0, %%mm1)                           // 2L6 + L5 + L7
-        "movq %%mm1, (%%"REG_d")                \n\t"
-        "movq (%%"REG_d", %1, 2), %%mm1         \n\t" // L8
-        PAVGB(%%mm1, %%mm0)                           // L6+L8
-        PAVGB(%%mm2, %%mm0)                           // 2L7 + L6 + L8
-        "movq %%mm0, (%%"REG_d", %1)            \n\t"
-        "movq (%0, %1, 8), %%mm0                \n\t" // L9
-        PAVGB(%%mm0, %%mm2)                           // L7+L9
-        PAVGB(%%mm1, %%mm2)                           // 2L8 + L7 + L9
-        "movq %%mm2, (%%"REG_d", %1, 2)         \n\t"
-        "movq %%mm1, (%2)                       \n\t"
-
-        : : "r" (src), "r" ((x86_reg)stride), "r" (tmp)
-        : "%"REG_a, "%"REG_d
-    );
-#else //TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-    int a, b, c, x;
-    src+= 4*stride;
-
-    for(x=0; x<2; x++){
-        a= *(uint32_t*)&tmp[stride*0];
-        b= *(uint32_t*)&src[stride*0];
-        c= *(uint32_t*)&src[stride*1];
-        a= (a&c) + (((a^c)&0xFEFEFEFEUL)>>1);
-        *(uint32_t*)&src[stride*0]= (a|b) - (((a^b)&0xFEFEFEFEUL)>>1);
-
-        a= *(uint32_t*)&src[stride*2];
-        b= (a&b) + (((a^b)&0xFEFEFEFEUL)>>1);
-        *(uint32_t*)&src[stride*1]= (c|b) - (((c^b)&0xFEFEFEFEUL)>>1);
-
-        b= *(uint32_t*)&src[stride*3];
-        c= (b&c) + (((b^c)&0xFEFEFEFEUL)>>1);
-        *(uint32_t*)&src[stride*2]= (c|a) - (((c^a)&0xFEFEFEFEUL)>>1);
-
-        c= *(uint32_t*)&src[stride*4];
-        a= (a&c) + (((a^c)&0xFEFEFEFEUL)>>1);
-        *(uint32_t*)&src[stride*3]= (a|b) - (((a^b)&0xFEFEFEFEUL)>>1);
-
-        a= *(uint32_t*)&src[stride*5];
-        b= (a&b) + (((a^b)&0xFEFEFEFEUL)>>1);
-        *(uint32_t*)&src[stride*4]= (c|b) - (((c^b)&0xFEFEFEFEUL)>>1);
-
-        b= *(uint32_t*)&src[stride*6];
-        c= (b&c) + (((b^c)&0xFEFEFEFEUL)>>1);
-        *(uint32_t*)&src[stride*5]= (c|a) - (((c^a)&0xFEFEFEFEUL)>>1);
-
-        c= *(uint32_t*)&src[stride*7];
-        a= (a&c) + (((a^c)&0xFEFEFEFEUL)>>1);
-        *(uint32_t*)&src[stride*6]= (a|b) - (((a^b)&0xFEFEFEFEUL)>>1);
-
-        a= *(uint32_t*)&src[stride*8];
-        b= (a&b) + (((a^b)&0xFEFEFEFEUL)>>1);
-        *(uint32_t*)&src[stride*7]= (c|b) - (((c^b)&0xFEFEFEFEUL)>>1);
-
-        *(uint32_t*)&tmp[stride*0]= c;
-        src += 4;
-        tmp += 4;
-    }
-#endif //TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-}
-
-/**
- * Deinterlace the given block by applying a median filter to every second line.
- * will be called for every 8x8 block and can read & write from line 4-15,
- * lines 0-3 have been passed through the deblock / dering filters already, but can be read, too.
- * lines 4-12 will be read into the deblocking filter and should be deinterlaced
- */
-static inline void RENAME(deInterlaceMedian)(uint8_t src[], int stride)
-{
-#if TEMPLATE_PP_MMX
-    src+= 4*stride;
-#if TEMPLATE_PP_MMXEXT
-    __asm__ volatile(
-        "lea (%0, %1), %%"REG_a"                \n\t"
-        "lea (%%"REG_a", %1, 4), %%"REG_d"      \n\t"
-//      0       1       2       3       4       5       6       7       8       9
-//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1
-
-        "movq (%0), %%mm0                       \n\t"
-        "movq (%%"REG_a", %1), %%mm2            \n\t"
-        "movq (%%"REG_a"), %%mm1                \n\t"
-        "movq %%mm0, %%mm3                      \n\t"
-        "pmaxub %%mm1, %%mm0                    \n\t"
-        "pminub %%mm3, %%mm1                    \n\t"
-        "pmaxub %%mm2, %%mm1                    \n\t"
-        "pminub %%mm1, %%mm0                    \n\t"
-        "movq %%mm0, (%%"REG_a")                \n\t"
-
-        "movq (%0, %1, 4), %%mm0                \n\t"
-        "movq (%%"REG_a", %1, 2), %%mm1         \n\t"
-        "movq %%mm2, %%mm3                      \n\t"
-        "pmaxub %%mm1, %%mm2                    \n\t"
-        "pminub %%mm3, %%mm1                    \n\t"
-        "pmaxub %%mm0, %%mm1                    \n\t"
-        "pminub %%mm1, %%mm2                    \n\t"
-        "movq %%mm2, (%%"REG_a", %1, 2)         \n\t"
-
-        "movq (%%"REG_d"), %%mm2                \n\t"
-        "movq (%%"REG_d", %1), %%mm1            \n\t"
-        "movq %%mm2, %%mm3                      \n\t"
-        "pmaxub %%mm0, %%mm2                    \n\t"
-        "pminub %%mm3, %%mm0                    \n\t"
-        "pmaxub %%mm1, %%mm0                    \n\t"
-        "pminub %%mm0, %%mm2                    \n\t"
-        "movq %%mm2, (%%"REG_d")                \n\t"
-
-        "movq (%%"REG_d", %1, 2), %%mm2         \n\t"
-        "movq (%0, %1, 8), %%mm0                \n\t"
-        "movq %%mm2, %%mm3                      \n\t"
-        "pmaxub %%mm0, %%mm2                    \n\t"
-        "pminub %%mm3, %%mm0                    \n\t"
-        "pmaxub %%mm1, %%mm0                    \n\t"
-        "pminub %%mm0, %%mm2                    \n\t"
-        "movq %%mm2, (%%"REG_d", %1, 2)         \n\t"
-
-
-        : : "r" (src), "r" ((x86_reg)stride)
-        : "%"REG_a, "%"REG_d
-    );
-
-#else // MMX without MMX2
-    __asm__ volatile(
-        "lea (%0, %1), %%"REG_a"                \n\t"
-        "lea (%%"REG_a", %1, 4), %%"REG_d"      \n\t"
-//      0       1       2       3       4       5       6       7       8       9
-//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1
-        "pxor %%mm7, %%mm7                      \n\t"
-
-#define REAL_MEDIAN(a,b,c)\
-        "movq " #a ", %%mm0                     \n\t"\
-        "movq " #b ", %%mm2                     \n\t"\
-        "movq " #c ", %%mm1                     \n\t"\
-        "movq %%mm0, %%mm3                      \n\t"\
-        "movq %%mm1, %%mm4                      \n\t"\
-        "movq %%mm2, %%mm5                      \n\t"\
-        "psubusb %%mm1, %%mm3                   \n\t"\
-        "psubusb %%mm2, %%mm4                   \n\t"\
-        "psubusb %%mm0, %%mm5                   \n\t"\
-        "pcmpeqb %%mm7, %%mm3                   \n\t"\
-        "pcmpeqb %%mm7, %%mm4                   \n\t"\
-        "pcmpeqb %%mm7, %%mm5                   \n\t"\
-        "movq %%mm3, %%mm6                      \n\t"\
-        "pxor %%mm4, %%mm3                      \n\t"\
-        "pxor %%mm5, %%mm4                      \n\t"\
-        "pxor %%mm6, %%mm5                      \n\t"\
-        "por %%mm3, %%mm1                       \n\t"\
-        "por %%mm4, %%mm2                       \n\t"\
-        "por %%mm5, %%mm0                       \n\t"\
-        "pand %%mm2, %%mm0                      \n\t"\
-        "pand %%mm1, %%mm0                      \n\t"\
-        "movq %%mm0, " #b "                     \n\t"
-#define MEDIAN(a,b,c)  REAL_MEDIAN(a,b,c)
-
-MEDIAN((%0)        , (%%REGa)       , (%%REGa, %1))
-MEDIAN((%%REGa, %1), (%%REGa, %1, 2), (%0, %1, 4))
-MEDIAN((%0, %1, 4) , (%%REGd)       , (%%REGd, %1))
-MEDIAN((%%REGd, %1), (%%REGd, %1, 2), (%0, %1, 8))
-
-        : : "r" (src), "r" ((x86_reg)stride)
-        : "%"REG_a, "%"REG_d
-    );
-#endif //TEMPLATE_PP_MMXEXT
-#else //TEMPLATE_PP_MMX
-    int x, y;
-    src+= 4*stride;
-    // FIXME - there should be a way to do a few columns in parallel like w/mmx
-    for(x=0; x<8; x++){
-        uint8_t *colsrc = src;
-        for (y=0; y<4; y++){
-            int a, b, c, d, e, f;
-            a = colsrc[0       ];
-            b = colsrc[stride  ];
-            c = colsrc[stride*2];
-            d = (a-b)>>31;
-            e = (b-c)>>31;
-            f = (c-a)>>31;
-            colsrc[stride  ] = (a|(d^f)) & (b|(d^e)) & (c|(e^f));
-            colsrc += stride*2;
-        }
-        src++;
-    }
-#endif //TEMPLATE_PP_MMX
-}
-
-#if TEMPLATE_PP_MMX
-/**
- * Transpose and shift the given 8x8 Block into dst1 and dst2.
- */
-static inline void RENAME(transpose1)(uint8_t *dst1, uint8_t *dst2, uint8_t *src, int srcStride)
-{
-    __asm__(
-        "lea (%0, %1), %%"REG_a"                \n\t"
-//      0       1       2       3       4       5       6       7       8       9
-//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1
-        "movq (%0), %%mm0                       \n\t" // 12345678
-        "movq (%%"REG_a"), %%mm1                \n\t" // abcdefgh
-        "movq %%mm0, %%mm2                      \n\t" // 12345678
-        "punpcklbw %%mm1, %%mm0                 \n\t" // 1a2b3c4d
-        "punpckhbw %%mm1, %%mm2                 \n\t" // 5e6f7g8h
-
-        "movq (%%"REG_a", %1), %%mm1            \n\t"
-        "movq (%%"REG_a", %1, 2), %%mm3         \n\t"
-        "movq %%mm1, %%mm4                      \n\t"
-        "punpcklbw %%mm3, %%mm1                 \n\t"
-        "punpckhbw %%mm3, %%mm4                 \n\t"
-
-        "movq %%mm0, %%mm3                      \n\t"
-        "punpcklwd %%mm1, %%mm0                 \n\t"
-        "punpckhwd %%mm1, %%mm3                 \n\t"
-        "movq %%mm2, %%mm1                      \n\t"
-        "punpcklwd %%mm4, %%mm2                 \n\t"
-        "punpckhwd %%mm4, %%mm1                 \n\t"
-
-        "movd %%mm0, 128(%2)                    \n\t"
-        "psrlq $32, %%mm0                       \n\t"
-        "movd %%mm0, 144(%2)                    \n\t"
-        "movd %%mm3, 160(%2)                    \n\t"
-        "psrlq $32, %%mm3                       \n\t"
-        "movd %%mm3, 176(%2)                    \n\t"
-        "movd %%mm3, 48(%3)                     \n\t"
-        "movd %%mm2, 192(%2)                    \n\t"
-        "movd %%mm2, 64(%3)                     \n\t"
-        "psrlq $32, %%mm2                       \n\t"
-        "movd %%mm2, 80(%3)                     \n\t"
-        "movd %%mm1, 96(%3)                     \n\t"
-        "psrlq $32, %%mm1                       \n\t"
-        "movd %%mm1, 112(%3)                    \n\t"
-
-        "lea (%%"REG_a", %1, 4), %%"REG_a"      \n\t"
-
-        "movq (%0, %1, 4), %%mm0                \n\t" // 12345678
-        "movq (%%"REG_a"), %%mm1                \n\t" // abcdefgh
-        "movq %%mm0, %%mm2                      \n\t" // 12345678
-        "punpcklbw %%mm1, %%mm0                 \n\t" // 1a2b3c4d
-        "punpckhbw %%mm1, %%mm2                 \n\t" // 5e6f7g8h
-
-        "movq (%%"REG_a", %1), %%mm1            \n\t"
-        "movq (%%"REG_a", %1, 2), %%mm3         \n\t"
-        "movq %%mm1, %%mm4                      \n\t"
-        "punpcklbw %%mm3, %%mm1                 \n\t"
-        "punpckhbw %%mm3, %%mm4                 \n\t"
-
-        "movq %%mm0, %%mm3                      \n\t"
-        "punpcklwd %%mm1, %%mm0                 \n\t"
-        "punpckhwd %%mm1, %%mm3                 \n\t"
-        "movq %%mm2, %%mm1                      \n\t"
-        "punpcklwd %%mm4, %%mm2                 \n\t"
-        "punpckhwd %%mm4, %%mm1                 \n\t"
-
-        "movd %%mm0, 132(%2)                    \n\t"
-        "psrlq $32, %%mm0                       \n\t"
-        "movd %%mm0, 148(%2)                    \n\t"
-        "movd %%mm3, 164(%2)                    \n\t"
-        "psrlq $32, %%mm3                       \n\t"
-        "movd %%mm3, 180(%2)                    \n\t"
-        "movd %%mm3, 52(%3)                     \n\t"
-        "movd %%mm2, 196(%2)                    \n\t"
-        "movd %%mm2, 68(%3)                     \n\t"
-        "psrlq $32, %%mm2                       \n\t"
-        "movd %%mm2, 84(%3)                     \n\t"
-        "movd %%mm1, 100(%3)                    \n\t"
-        "psrlq $32, %%mm1                       \n\t"
-        "movd %%mm1, 116(%3)                    \n\t"
-
-
-        :: "r" (src), "r" ((x86_reg)srcStride), "r" (dst1), "r" (dst2)
-        : "%"REG_a
-    );
-}
-
-/**
- * Transpose the given 8x8 block.
- */
-static inline void RENAME(transpose2)(uint8_t *dst, int dstStride, uint8_t *src)
-{
-    __asm__(
-        "lea (%0, %1), %%"REG_a"                \n\t"
-        "lea (%%"REG_a",%1,4), %%"REG_d"        \n\t"
-//      0       1       2       3       4       5       6       7       8       9
-//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1
-        "movq (%2), %%mm0                       \n\t" // 12345678
-        "movq 16(%2), %%mm1                     \n\t" // abcdefgh
-        "movq %%mm0, %%mm2                      \n\t" // 12345678
-        "punpcklbw %%mm1, %%mm0                 \n\t" // 1a2b3c4d
-        "punpckhbw %%mm1, %%mm2                 \n\t" // 5e6f7g8h
-
-        "movq 32(%2), %%mm1                     \n\t"
-        "movq 48(%2), %%mm3                     \n\t"
-        "movq %%mm1, %%mm4                      \n\t"
-        "punpcklbw %%mm3, %%mm1                 \n\t"
-        "punpckhbw %%mm3, %%mm4                 \n\t"
-
-        "movq %%mm0, %%mm3                      \n\t"
-        "punpcklwd %%mm1, %%mm0                 \n\t"
-        "punpckhwd %%mm1, %%mm3                 \n\t"
-        "movq %%mm2, %%mm1                      \n\t"
-        "punpcklwd %%mm4, %%mm2                 \n\t"
-        "punpckhwd %%mm4, %%mm1                 \n\t"
-
-        "movd %%mm0, (%0)                       \n\t"
-        "psrlq $32, %%mm0                       \n\t"
-        "movd %%mm0, (%%"REG_a")                \n\t"
-        "movd %%mm3, (%%"REG_a", %1)            \n\t"
-        "psrlq $32, %%mm3                       \n\t"
-        "movd %%mm3, (%%"REG_a", %1, 2)         \n\t"
-        "movd %%mm2, (%0, %1, 4)                \n\t"
-        "psrlq $32, %%mm2                       \n\t"
-        "movd %%mm2, (%%"REG_d")                \n\t"
-        "movd %%mm1, (%%"REG_d", %1)            \n\t"
-        "psrlq $32, %%mm1                       \n\t"
-        "movd %%mm1, (%%"REG_d", %1, 2)         \n\t"
-
-
-        "movq 64(%2), %%mm0                     \n\t" // 12345678
-        "movq 80(%2), %%mm1                     \n\t" // abcdefgh
-        "movq %%mm0, %%mm2                      \n\t" // 12345678
-        "punpcklbw %%mm1, %%mm0                 \n\t" // 1a2b3c4d
-        "punpckhbw %%mm1, %%mm2                 \n\t" // 5e6f7g8h
-
-        "movq 96(%2), %%mm1                     \n\t"
-        "movq 112(%2), %%mm3                    \n\t"
-        "movq %%mm1, %%mm4                      \n\t"
-        "punpcklbw %%mm3, %%mm1                 \n\t"
-        "punpckhbw %%mm3, %%mm4                 \n\t"
-
-        "movq %%mm0, %%mm3                      \n\t"
-        "punpcklwd %%mm1, %%mm0                 \n\t"
-        "punpckhwd %%mm1, %%mm3                 \n\t"
-        "movq %%mm2, %%mm1                      \n\t"
-        "punpcklwd %%mm4, %%mm2                 \n\t"
-        "punpckhwd %%mm4, %%mm1                 \n\t"
-
-        "movd %%mm0, 4(%0)                      \n\t"
-        "psrlq $32, %%mm0                       \n\t"
-        "movd %%mm0, 4(%%"REG_a")               \n\t"
-        "movd %%mm3, 4(%%"REG_a", %1)           \n\t"
-        "psrlq $32, %%mm3                       \n\t"
-        "movd %%mm3, 4(%%"REG_a", %1, 2)        \n\t"
-        "movd %%mm2, 4(%0, %1, 4)               \n\t"
-        "psrlq $32, %%mm2                       \n\t"
-        "movd %%mm2, 4(%%"REG_d")               \n\t"
-        "movd %%mm1, 4(%%"REG_d", %1)           \n\t"
-        "psrlq $32, %%mm1                       \n\t"
-        "movd %%mm1, 4(%%"REG_d", %1, 2)        \n\t"
-
-        :: "r" (dst), "r" ((x86_reg)dstStride), "r" (src)
-        : "%"REG_a, "%"REG_d
-    );
-}
-#endif //TEMPLATE_PP_MMX
-//static long test=0;
-
-#if !TEMPLATE_PP_ALTIVEC
-static inline void RENAME(tempNoiseReducer)(uint8_t *src, int stride,
-                                    uint8_t *tempBlurred, uint32_t *tempBlurredPast, int *maxNoise)
-{
-    // to save a register (FIXME do this outside of the loops)
-    tempBlurredPast[127]= maxNoise[0];
-    tempBlurredPast[128]= maxNoise[1];
-    tempBlurredPast[129]= maxNoise[2];
-
-#define FAST_L2_DIFF
-//#define L1_DIFF //u should change the thresholds too if u try that one
-#if TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-    __asm__ volatile(
-        "lea (%2, %2, 2), %%"REG_a"             \n\t" // 3*stride
-        "lea (%2, %2, 4), %%"REG_d"             \n\t" // 5*stride
-        "lea (%%"REG_d", %2, 2), %%"REG_c"      \n\t" // 7*stride
-//      0       1       2       3       4       5       6       7       8       9
-//      %x      %x+%2   %x+2%2  %x+eax  %x+4%2  %x+edx  %x+2eax %x+ecx  %x+8%2
-//FIXME reorder?
-#ifdef L1_DIFF //needs mmx2
-        "movq (%0), %%mm0                       \n\t" // L0
-        "psadbw (%1), %%mm0                     \n\t" // |L0-R0|
-        "movq (%0, %2), %%mm1                   \n\t" // L1
-        "psadbw (%1, %2), %%mm1                 \n\t" // |L1-R1|
-        "movq (%0, %2, 2), %%mm2                \n\t" // L2
-        "psadbw (%1, %2, 2), %%mm2              \n\t" // |L2-R2|
-        "movq (%0, %%"REG_a"), %%mm3            \n\t" // L3
-        "psadbw (%1, %%"REG_a"), %%mm3          \n\t" // |L3-R3|
-
-        "movq (%0, %2, 4), %%mm4                \n\t" // L4
-        "paddw %%mm1, %%mm0                     \n\t"
-        "psadbw (%1, %2, 4), %%mm4              \n\t" // |L4-R4|
-        "movq (%0, %%"REG_d"), %%mm5            \n\t" // L5
-        "paddw %%mm2, %%mm0                     \n\t"
-        "psadbw (%1, %%"REG_d"), %%mm5          \n\t" // |L5-R5|
-        "movq (%0, %%"REG_a", 2), %%mm6         \n\t" // L6
-        "paddw %%mm3, %%mm0                     \n\t"
-        "psadbw (%1, %%"REG_a", 2), %%mm6       \n\t" // |L6-R6|
-        "movq (%0, %%"REG_c"), %%mm7            \n\t" // L7
-        "paddw %%mm4, %%mm0                     \n\t"
-        "psadbw (%1, %%"REG_c"), %%mm7          \n\t" // |L7-R7|
-        "paddw %%mm5, %%mm6                     \n\t"
-        "paddw %%mm7, %%mm6                     \n\t"
-        "paddw %%mm6, %%mm0                     \n\t"
-#else //L1_DIFF
-#if defined (FAST_L2_DIFF)
-        "pcmpeqb %%mm7, %%mm7                   \n\t"
-        "movq "MANGLE(b80)", %%mm6              \n\t"
-        "pxor %%mm0, %%mm0                      \n\t"
-#define REAL_L2_DIFF_CORE(a, b)\
-        "movq " #a ", %%mm5                     \n\t"\
-        "movq " #b ", %%mm2                     \n\t"\
-        "pxor %%mm7, %%mm2                      \n\t"\
-        PAVGB(%%mm2, %%mm5)\
-        "paddb %%mm6, %%mm5                     \n\t"\
-        "movq %%mm5, %%mm2                      \n\t"\
-        "psllw $8, %%mm5                        \n\t"\
-        "pmaddwd %%mm5, %%mm5                   \n\t"\
-        "pmaddwd %%mm2, %%mm2                   \n\t"\
-        "paddd %%mm2, %%mm5                     \n\t"\
-        "psrld $14, %%mm5                       \n\t"\
-        "paddd %%mm5, %%mm0                     \n\t"
-
-#else //defined (FAST_L2_DIFF)
-        "pxor %%mm7, %%mm7                      \n\t"
-        "pxor %%mm0, %%mm0                      \n\t"
-#define REAL_L2_DIFF_CORE(a, b)\
-        "movq " #a ", %%mm5                     \n\t"\
-        "movq " #b ", %%mm2                     \n\t"\
-        "movq %%mm5, %%mm1                      \n\t"\
-        "movq %%mm2, %%mm3                      \n\t"\
-        "punpcklbw %%mm7, %%mm5                 \n\t"\
-        "punpckhbw %%mm7, %%mm1                 \n\t"\
-        "punpcklbw %%mm7, %%mm2                 \n\t"\
-        "punpckhbw %%mm7, %%mm3                 \n\t"\
-        "psubw %%mm2, %%mm5                     \n\t"\
-        "psubw %%mm3, %%mm1                     \n\t"\
-        "pmaddwd %%mm5, %%mm5                   \n\t"\
-        "pmaddwd %%mm1, %%mm1                   \n\t"\
-        "paddd %%mm1, %%mm5                     \n\t"\
-        "paddd %%mm5, %%mm0                     \n\t"
-
-#endif //defined (FAST_L2_DIFF)
-
-#define L2_DIFF_CORE(a, b)  REAL_L2_DIFF_CORE(a, b)
-
-L2_DIFF_CORE((%0)          , (%1))
-L2_DIFF_CORE((%0, %2)      , (%1, %2))
-L2_DIFF_CORE((%0, %2, 2)   , (%1, %2, 2))
-L2_DIFF_CORE((%0, %%REGa)  , (%1, %%REGa))
-L2_DIFF_CORE((%0, %2, 4)   , (%1, %2, 4))
-L2_DIFF_CORE((%0, %%REGd)  , (%1, %%REGd))
-L2_DIFF_CORE((%0, %%REGa,2), (%1, %%REGa,2))
-L2_DIFF_CORE((%0, %%REGc)  , (%1, %%REGc))
-
-#endif //L1_DIFF
-
-        "movq %%mm0, %%mm4                      \n\t"
-        "psrlq $32, %%mm0                       \n\t"
-        "paddd %%mm0, %%mm4                     \n\t"
-        "movd %%mm4, %%ecx                      \n\t"
-        "shll $2, %%ecx                         \n\t"
-        "mov %3, %%"REG_d"                      \n\t"
-        "addl -4(%%"REG_d"), %%ecx              \n\t"
-        "addl 4(%%"REG_d"), %%ecx               \n\t"
-        "addl -1024(%%"REG_d"), %%ecx           \n\t"
-        "addl $4, %%ecx                         \n\t"
-        "addl 1024(%%"REG_d"), %%ecx            \n\t"
-        "shrl $3, %%ecx                         \n\t"
-        "movl %%ecx, (%%"REG_d")                \n\t"
-
-//        "mov %3, %%"REG_c"                      \n\t"
-//        "mov %%"REG_c", test                    \n\t"
-//        "jmp 4f                                 \n\t"
-        "cmpl 512(%%"REG_d"), %%ecx             \n\t"
-        " jb 2f                                 \n\t"
-        "cmpl 516(%%"REG_d"), %%ecx             \n\t"
-        " jb 1f                                 \n\t"
-
-        "lea (%%"REG_a", %2, 2), %%"REG_d"      \n\t" // 5*stride
-        "lea (%%"REG_d", %2, 2), %%"REG_c"      \n\t" // 7*stride
-        "movq (%0), %%mm0                       \n\t" // L0
-        "movq (%0, %2), %%mm1                   \n\t" // L1
-        "movq (%0, %2, 2), %%mm2                \n\t" // L2
-        "movq (%0, %%"REG_a"), %%mm3            \n\t" // L3
-        "movq (%0, %2, 4), %%mm4                \n\t" // L4
-        "movq (%0, %%"REG_d"), %%mm5            \n\t" // L5
-        "movq (%0, %%"REG_a", 2), %%mm6         \n\t" // L6
-        "movq (%0, %%"REG_c"), %%mm7            \n\t" // L7
-        "movq %%mm0, (%1)                       \n\t" // L0
-        "movq %%mm1, (%1, %2)                   \n\t" // L1
-        "movq %%mm2, (%1, %2, 2)                \n\t" // L2
-        "movq %%mm3, (%1, %%"REG_a")            \n\t" // L3
-        "movq %%mm4, (%1, %2, 4)                \n\t" // L4
-        "movq %%mm5, (%1, %%"REG_d")            \n\t" // L5
-        "movq %%mm6, (%1, %%"REG_a", 2)         \n\t" // L6
-        "movq %%mm7, (%1, %%"REG_c")            \n\t" // L7
-        "jmp 4f                                 \n\t"
-
-        "1:                                     \n\t"
-        "lea (%%"REG_a", %2, 2), %%"REG_d"      \n\t" // 5*stride
-        "lea (%%"REG_d", %2, 2), %%"REG_c"      \n\t" // 7*stride
-        "movq (%0), %%mm0                       \n\t" // L0
-        PAVGB((%1), %%mm0)                            // L0
-        "movq (%0, %2), %%mm1                   \n\t" // L1
-        PAVGB((%1, %2), %%mm1)                        // L1
-        "movq (%0, %2, 2), %%mm2                \n\t" // L2
-        PAVGB((%1, %2, 2), %%mm2)                     // L2
-        "movq (%0, %%"REG_a"), %%mm3            \n\t" // L3
-        PAVGB((%1, %%REGa), %%mm3)                    // L3
-        "movq (%0, %2, 4), %%mm4                \n\t" // L4
-        PAVGB((%1, %2, 4), %%mm4)                     // L4
-        "movq (%0, %%"REG_d"), %%mm5            \n\t" // L5
-        PAVGB((%1, %%REGd), %%mm5)                    // L5
-        "movq (%0, %%"REG_a", 2), %%mm6         \n\t" // L6
-        PAVGB((%1, %%REGa, 2), %%mm6)                 // L6
-        "movq (%0, %%"REG_c"), %%mm7            \n\t" // L7
-        PAVGB((%1, %%REGc), %%mm7)                    // L7
-        "movq %%mm0, (%1)                       \n\t" // R0
-        "movq %%mm1, (%1, %2)                   \n\t" // R1
-        "movq %%mm2, (%1, %2, 2)                \n\t" // R2
-        "movq %%mm3, (%1, %%"REG_a")            \n\t" // R3
-        "movq %%mm4, (%1, %2, 4)                \n\t" // R4
-        "movq %%mm5, (%1, %%"REG_d")            \n\t" // R5
-        "movq %%mm6, (%1, %%"REG_a", 2)         \n\t" // R6
-        "movq %%mm7, (%1, %%"REG_c")            \n\t" // R7
-        "movq %%mm0, (%0)                       \n\t" // L0
-        "movq %%mm1, (%0, %2)                   \n\t" // L1
-        "movq %%mm2, (%0, %2, 2)                \n\t" // L2
-        "movq %%mm3, (%0, %%"REG_a")            \n\t" // L3
-        "movq %%mm4, (%0, %2, 4)                \n\t" // L4
-        "movq %%mm5, (%0, %%"REG_d")            \n\t" // L5
-        "movq %%mm6, (%0, %%"REG_a", 2)         \n\t" // L6
-        "movq %%mm7, (%0, %%"REG_c")            \n\t" // L7
-        "jmp 4f                                 \n\t"
-
-        "2:                                     \n\t"
-        "cmpl 508(%%"REG_d"), %%ecx             \n\t"
-        " jb 3f                                 \n\t"
-
-        "lea (%%"REG_a", %2, 2), %%"REG_d"      \n\t" // 5*stride
-        "lea (%%"REG_d", %2, 2), %%"REG_c"      \n\t" // 7*stride
-        "movq (%0), %%mm0                       \n\t" // L0
-        "movq (%0, %2), %%mm1                   \n\t" // L1
-        "movq (%0, %2, 2), %%mm2                \n\t" // L2
-        "movq (%0, %%"REG_a"), %%mm3            \n\t" // L3
-        "movq (%1), %%mm4                       \n\t" // R0
-        "movq (%1, %2), %%mm5                   \n\t" // R1
-        "movq (%1, %2, 2), %%mm6                \n\t" // R2
-        "movq (%1, %%"REG_a"), %%mm7            \n\t" // R3
-        PAVGB(%%mm4, %%mm0)
-        PAVGB(%%mm5, %%mm1)
-        PAVGB(%%mm6, %%mm2)
-        PAVGB(%%mm7, %%mm3)
-        PAVGB(%%mm4, %%mm0)
-        PAVGB(%%mm5, %%mm1)
-        PAVGB(%%mm6, %%mm2)
-        PAVGB(%%mm7, %%mm3)
-        "movq %%mm0, (%1)                       \n\t" // R0
-        "movq %%mm1, (%1, %2)                   \n\t" // R1
-        "movq %%mm2, (%1, %2, 2)                \n\t" // R2
-        "movq %%mm3, (%1, %%"REG_a")            \n\t" // R3
-        "movq %%mm0, (%0)                       \n\t" // L0
-        "movq %%mm1, (%0, %2)                   \n\t" // L1
-        "movq %%mm2, (%0, %2, 2)                \n\t" // L2
-        "movq %%mm3, (%0, %%"REG_a")            \n\t" // L3
-
-        "movq (%0, %2, 4), %%mm0                \n\t" // L4
-        "movq (%0, %%"REG_d"), %%mm1            \n\t" // L5
-        "movq (%0, %%"REG_a", 2), %%mm2         \n\t" // L6
-        "movq (%0, %%"REG_c"), %%mm3            \n\t" // L7
-        "movq (%1, %2, 4), %%mm4                \n\t" // R4
-        "movq (%1, %%"REG_d"), %%mm5            \n\t" // R5
-        "movq (%1, %%"REG_a", 2), %%mm6         \n\t" // R6
-        "movq (%1, %%"REG_c"), %%mm7            \n\t" // R7
-        PAVGB(%%mm4, %%mm0)
-        PAVGB(%%mm5, %%mm1)
-        PAVGB(%%mm6, %%mm2)
-        PAVGB(%%mm7, %%mm3)
-        PAVGB(%%mm4, %%mm0)
-        PAVGB(%%mm5, %%mm1)
-        PAVGB(%%mm6, %%mm2)
-        PAVGB(%%mm7, %%mm3)
-        "movq %%mm0, (%1, %2, 4)                \n\t" // R4
-        "movq %%mm1, (%1, %%"REG_d")            \n\t" // R5
-        "movq %%mm2, (%1, %%"REG_a", 2)         \n\t" // R6
-        "movq %%mm3, (%1, %%"REG_c")            \n\t" // R7
-        "movq %%mm0, (%0, %2, 4)                \n\t" // L4
-        "movq %%mm1, (%0, %%"REG_d")            \n\t" // L5
-        "movq %%mm2, (%0, %%"REG_a", 2)         \n\t" // L6
-        "movq %%mm3, (%0, %%"REG_c")            \n\t" // L7
-        "jmp 4f                                 \n\t"
-
-        "3:                                     \n\t"
-        "lea (%%"REG_a", %2, 2), %%"REG_d"      \n\t" // 5*stride
-        "lea (%%"REG_d", %2, 2), %%"REG_c"      \n\t" // 7*stride
-        "movq (%0), %%mm0                       \n\t" // L0
-        "movq (%0, %2), %%mm1                   \n\t" // L1
-        "movq (%0, %2, 2), %%mm2                \n\t" // L2
-        "movq (%0, %%"REG_a"), %%mm3            \n\t" // L3
-        "movq (%1), %%mm4                       \n\t" // R0
-        "movq (%1, %2), %%mm5                   \n\t" // R1
-        "movq (%1, %2, 2), %%mm6                \n\t" // R2
-        "movq (%1, %%"REG_a"), %%mm7            \n\t" // R3
-        PAVGB(%%mm4, %%mm0)
-        PAVGB(%%mm5, %%mm1)
-        PAVGB(%%mm6, %%mm2)
-        PAVGB(%%mm7, %%mm3)
-        PAVGB(%%mm4, %%mm0)
-        PAVGB(%%mm5, %%mm1)
-        PAVGB(%%mm6, %%mm2)
-        PAVGB(%%mm7, %%mm3)
-        PAVGB(%%mm4, %%mm0)
-        PAVGB(%%mm5, %%mm1)
-        PAVGB(%%mm6, %%mm2)
-        PAVGB(%%mm7, %%mm3)
-        "movq %%mm0, (%1)                       \n\t" // R0
-        "movq %%mm1, (%1, %2)                   \n\t" // R1
-        "movq %%mm2, (%1, %2, 2)                \n\t" // R2
-        "movq %%mm3, (%1, %%"REG_a")            \n\t" // R3
-        "movq %%mm0, (%0)                       \n\t" // L0
-        "movq %%mm1, (%0, %2)                   \n\t" // L1
-        "movq %%mm2, (%0, %2, 2)                \n\t" // L2
-        "movq %%mm3, (%0, %%"REG_a")            \n\t" // L3
-
-        "movq (%0, %2, 4), %%mm0                \n\t" // L4
-        "movq (%0, %%"REG_d"), %%mm1            \n\t" // L5
-        "movq (%0, %%"REG_a", 2), %%mm2         \n\t" // L6
-        "movq (%0, %%"REG_c"), %%mm3            \n\t" // L7
-        "movq (%1, %2, 4), %%mm4                \n\t" // R4
-        "movq (%1, %%"REG_d"), %%mm5            \n\t" // R5
-        "movq (%1, %%"REG_a", 2), %%mm6         \n\t" // R6
-        "movq (%1, %%"REG_c"), %%mm7            \n\t" // R7
-        PAVGB(%%mm4, %%mm0)
-        PAVGB(%%mm5, %%mm1)
-        PAVGB(%%mm6, %%mm2)
-        PAVGB(%%mm7, %%mm3)
-        PAVGB(%%mm4, %%mm0)
-        PAVGB(%%mm5, %%mm1)
-        PAVGB(%%mm6, %%mm2)
-        PAVGB(%%mm7, %%mm3)
-        PAVGB(%%mm4, %%mm0)
-        PAVGB(%%mm5, %%mm1)
-        PAVGB(%%mm6, %%mm2)
-        PAVGB(%%mm7, %%mm3)
-        "movq %%mm0, (%1, %2, 4)                \n\t" // R4
-        "movq %%mm1, (%1, %%"REG_d")            \n\t" // R5
-        "movq %%mm2, (%1, %%"REG_a", 2)         \n\t" // R6
-        "movq %%mm3, (%1, %%"REG_c")            \n\t" // R7
-        "movq %%mm0, (%0, %2, 4)                \n\t" // L4
-        "movq %%mm1, (%0, %%"REG_d")            \n\t" // L5
-        "movq %%mm2, (%0, %%"REG_a", 2)         \n\t" // L6
-        "movq %%mm3, (%0, %%"REG_c")            \n\t" // L7
-
-        "4:                                     \n\t"
-
-        :: "r" (src), "r" (tempBlurred), "r"((x86_reg)stride), "m" (tempBlurredPast)
-        : "%"REG_a, "%"REG_d, "%"REG_c, "memory"
-    );
-#else //TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-{
-    int y;
-    int d=0;
-//    int sysd=0;
-    int i;
-
-    for(y=0; y<8; y++){
-        int x;
-        for(x=0; x<8; x++){
-            int ref= tempBlurred[ x + y*stride ];
-            int cur= src[ x + y*stride ];
-            int d1=ref - cur;
-//            if(x==0 || x==7) d1+= d1>>1;
-//            if(y==0 || y==7) d1+= d1>>1;
-//            d+= FFABS(d1);
-            d+= d1*d1;
-//            sysd+= d1;
-        }
-    }
-    i=d;
-    d=  (
-        4*d
-        +(*(tempBlurredPast-256))
-        +(*(tempBlurredPast-1))+ (*(tempBlurredPast+1))
-        +(*(tempBlurredPast+256))
-        +4)>>3;
-    *tempBlurredPast=i;
-//    ((*tempBlurredPast)*3 + d + 2)>>2;
-
-/*
-Switch between
- 1  0  0  0  0  0  0  (0)
-64 32 16  8  4  2  1  (1)
-64 48 36 27 20 15 11 (33) (approx)
-64 56 49 43 37 33 29 (200) (approx)
-*/
-    if(d > maxNoise[1]){
-        if(d < maxNoise[2]){
-            for(y=0; y<8; y++){
-                int x;
-                for(x=0; x<8; x++){
-                    int ref= tempBlurred[ x + y*stride ];
-                    int cur= src[ x + y*stride ];
-                    tempBlurred[ x + y*stride ]=
-                    src[ x + y*stride ]=
-                        (ref + cur + 1)>>1;
-                }
-            }
-        }else{
-            for(y=0; y<8; y++){
-                int x;
-                for(x=0; x<8; x++){
-                    tempBlurred[ x + y*stride ]= src[ x + y*stride ];
-                }
-            }
-        }
-    }else{
-        if(d < maxNoise[0]){
-            for(y=0; y<8; y++){
-                int x;
-                for(x=0; x<8; x++){
-                    int ref= tempBlurred[ x + y*stride ];
-                    int cur= src[ x + y*stride ];
-                    tempBlurred[ x + y*stride ]=
-                    src[ x + y*stride ]=
-                        (ref*7 + cur + 4)>>3;
-                }
-            }
-        }else{
-            for(y=0; y<8; y++){
-                int x;
-                for(x=0; x<8; x++){
-                    int ref= tempBlurred[ x + y*stride ];
-                    int cur= src[ x + y*stride ];
-                    tempBlurred[ x + y*stride ]=
-                    src[ x + y*stride ]=
-                        (ref*3 + cur + 2)>>2;
-                }
-            }
-        }
-    }
-}
-#endif //TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW
-}
-#endif //TEMPLATE_PP_ALTIVEC
-
-#if TEMPLATE_PP_MMX
-/**
- * accurate deblock filter
- */
-static av_always_inline void RENAME(do_a_deblock)(uint8_t *src, int step, int stride, PPContext *c){
-    int64_t dc_mask, eq_mask, both_masks;
-    int64_t sums[10*8*2];
-    src+= step*3; // src points to begin of the 8x8 Block
-    //{ START_TIMER
-    __asm__ volatile(
-        "movq %0, %%mm7                         \n\t"
-        "movq %1, %%mm6                         \n\t"
-        : : "m" (c->mmxDcOffset[c->nonBQP]),  "m" (c->mmxDcThreshold[c->nonBQP])
-        );
-
-    __asm__ volatile(
-        "lea (%2, %3), %%"REG_a"                \n\t"
-//      0       1       2       3       4       5       6       7       8       9
-//      %1      eax     eax+%2  eax+2%2 %1+4%2  ecx     ecx+%2  ecx+2%2 %1+8%2  ecx+4%2
-
-        "movq (%2), %%mm0                       \n\t"
-        "movq (%%"REG_a"), %%mm1                \n\t"
-        "movq %%mm1, %%mm3                      \n\t"
-        "movq %%mm1, %%mm4                      \n\t"
-        "psubb %%mm1, %%mm0                     \n\t" // mm0 = difference
-        "paddb %%mm7, %%mm0                     \n\t"
-        "pcmpgtb %%mm6, %%mm0                   \n\t"
-
-        "movq (%%"REG_a",%3), %%mm2             \n\t"
-        PMAXUB(%%mm2, %%mm4)
-        PMINUB(%%mm2, %%mm3, %%mm5)
-        "psubb %%mm2, %%mm1                     \n\t"
-        "paddb %%mm7, %%mm1                     \n\t"
-        "pcmpgtb %%mm6, %%mm1                   \n\t"
-        "paddb %%mm1, %%mm0                     \n\t"
-
-        "movq (%%"REG_a", %3, 2), %%mm1         \n\t"
-        PMAXUB(%%mm1, %%mm4)
-        PMINUB(%%mm1, %%mm3, %%mm5)
-        "psubb %%mm1, %%mm2                     \n\t"
-        "paddb %%mm7, %%mm2                     \n\t"
-        "pcmpgtb %%mm6, %%mm2                   \n\t"
-        "paddb %%mm2, %%mm0                     \n\t"
-
-        "lea (%%"REG_a", %3, 4), %%"REG_a"      \n\t"
-
-        "movq (%2, %3, 4), %%mm2                \n\t"
-        PMAXUB(%%mm2, %%mm4)
-        PMINUB(%%mm2, %%mm3, %%mm5)
-        "psubb %%mm2, %%mm1                     \n\t"
-        "paddb %%mm7, %%mm1                     \n\t"
-        "pcmpgtb %%mm6, %%mm1                   \n\t"
-        "paddb %%mm1, %%mm0                     \n\t"
-
-        "movq (%%"REG_a"), %%mm1                \n\t"
-        PMAXUB(%%mm1, %%mm4)
-        PMINUB(%%mm1, %%mm3, %%mm5)
-        "psubb %%mm1, %%mm2                     \n\t"
-        "paddb %%mm7, %%mm2                     \n\t"
-        "pcmpgtb %%mm6, %%mm2                   \n\t"
-        "paddb %%mm2, %%mm0                     \n\t"
-
-        "movq (%%"REG_a", %3), %%mm2            \n\t"
-        PMAXUB(%%mm2, %%mm4)
-        PMINUB(%%mm2, %%mm3, %%mm5)
-        "psubb %%mm2, %%mm1                     \n\t"
-        "paddb %%mm7, %%mm1                     \n\t"
-        "pcmpgtb %%mm6, %%mm1                   \n\t"
-        "paddb %%mm1, %%mm0                     \n\t"
-
-        "movq (%%"REG_a", %3, 2), %%mm1         \n\t"
-        PMAXUB(%%mm1, %%mm4)
-        PMINUB(%%mm1, %%mm3, %%mm5)
-        "psubb %%mm1, %%mm2                     \n\t"
-        "paddb %%mm7, %%mm2                     \n\t"
-        "pcmpgtb %%mm6, %%mm2                   \n\t"
-        "paddb %%mm2, %%mm0                     \n\t"
-
-        "movq (%2, %3, 8), %%mm2                \n\t"
-        PMAXUB(%%mm2, %%mm4)
-        PMINUB(%%mm2, %%mm3, %%mm5)
-        "psubb %%mm2, %%mm1                     \n\t"
-        "paddb %%mm7, %%mm1                     \n\t"
-        "pcmpgtb %%mm6, %%mm1                   \n\t"
-        "paddb %%mm1, %%mm0                     \n\t"
-
-        "movq (%%"REG_a", %3, 4), %%mm1         \n\t"
-        "psubb %%mm1, %%mm2                     \n\t"
-        "paddb %%mm7, %%mm2                     \n\t"
-        "pcmpgtb %%mm6, %%mm2                   \n\t"
-        "paddb %%mm2, %%mm0                     \n\t"
-        "psubusb %%mm3, %%mm4                   \n\t"
-
-        "pxor %%mm6, %%mm6                      \n\t"
-        "movq %4, %%mm7                         \n\t" // QP,..., QP
-        "paddusb %%mm7, %%mm7                   \n\t" // 2QP ... 2QP
-        "psubusb %%mm4, %%mm7                   \n\t" // Diff >=2QP -> 0
-        "pcmpeqb %%mm6, %%mm7                   \n\t" // Diff < 2QP -> 0
-        "pcmpeqb %%mm6, %%mm7                   \n\t" // Diff < 2QP -> 0
-        "movq %%mm7, %1                         \n\t"
-
-        "movq %5, %%mm7                         \n\t"
-        "punpcklbw %%mm7, %%mm7                 \n\t"
-        "punpcklbw %%mm7, %%mm7                 \n\t"
-        "punpcklbw %%mm7, %%mm7                 \n\t"
-        "psubb %%mm0, %%mm6                     \n\t"
-        "pcmpgtb %%mm7, %%mm6                   \n\t"
-        "movq %%mm6, %0                         \n\t"
-
-        : "=m" (eq_mask), "=m" (dc_mask)
-        : "r" (src), "r" ((x86_reg)step), "m" (c->pQPb), "m"(c->ppMode.flatnessThreshold)
-        : "%"REG_a
-    );
-
-    both_masks = dc_mask & eq_mask;
-
-    if(both_masks){
-        x86_reg offset= -8*step;
-        int64_t *temp_sums= sums;
-
-        __asm__ volatile(
-            "movq %2, %%mm0                         \n\t"  // QP,..., QP
-            "pxor %%mm4, %%mm4                      \n\t"
-
-            "movq (%0), %%mm6                       \n\t"
-            "movq (%0, %1), %%mm5                   \n\t"
-            "movq %%mm5, %%mm1                      \n\t"
-            "movq %%mm6, %%mm2                      \n\t"
-            "psubusb %%mm6, %%mm5                   \n\t"
-            "psubusb %%mm1, %%mm2                   \n\t"
-            "por %%mm5, %%mm2                       \n\t" // ABS Diff of lines
-            "psubusb %%mm2, %%mm0                   \n\t" // diff >= QP -> 0
-            "pcmpeqb %%mm4, %%mm0                   \n\t" // diff >= QP -> FF
-
-            "pxor %%mm6, %%mm1                      \n\t"
-            "pand %%mm0, %%mm1                      \n\t"
-            "pxor %%mm1, %%mm6                      \n\t"
-            // 0:QP  6:First
-
-            "movq (%0, %1, 8), %%mm5                \n\t"
-            "add %1, %0                             \n\t" // %0 points to line 1 not 0
-            "movq (%0, %1, 8), %%mm7                \n\t"
-            "movq %%mm5, %%mm1                      \n\t"
-            "movq %%mm7, %%mm2                      \n\t"
-            "psubusb %%mm7, %%mm5                   \n\t"
-            "psubusb %%mm1, %%mm2                   \n\t"
-            "por %%mm5, %%mm2                       \n\t" // ABS Diff of lines
-            "movq %2, %%mm0                         \n\t"  // QP,..., QP
-            "psubusb %%mm2, %%mm0                   \n\t" // diff >= QP -> 0
-            "pcmpeqb %%mm4, %%mm0                   \n\t" // diff >= QP -> FF
-
-            "pxor %%mm7, %%mm1                      \n\t"
-            "pand %%mm0, %%mm1                      \n\t"
-            "pxor %%mm1, %%mm7                      \n\t"
-
-            "movq %%mm6, %%mm5                      \n\t"
-            "punpckhbw %%mm4, %%mm6                 \n\t"
-            "punpcklbw %%mm4, %%mm5                 \n\t"
-            // 4:0 5/6:First 7:Last
-
-            "movq %%mm5, %%mm0                      \n\t"
-            "movq %%mm6, %%mm1                      \n\t"
-            "psllw $2, %%mm0                        \n\t"
-            "psllw $2, %%mm1                        \n\t"
-            "paddw "MANGLE(w04)", %%mm0             \n\t"
-            "paddw "MANGLE(w04)", %%mm1             \n\t"
-
-#define NEXT\
-            "movq (%0), %%mm2                       \n\t"\
-            "movq (%0), %%mm3                       \n\t"\
-            "add %1, %0                             \n\t"\
-            "punpcklbw %%mm4, %%mm2                 \n\t"\
-            "punpckhbw %%mm4, %%mm3                 \n\t"\
-            "paddw %%mm2, %%mm0                     \n\t"\
-            "paddw %%mm3, %%mm1                     \n\t"
-
-#define PREV\
-            "movq (%0), %%mm2                       \n\t"\
-            "movq (%0), %%mm3                       \n\t"\
-            "add %1, %0                             \n\t"\
-            "punpcklbw %%mm4, %%mm2                 \n\t"\
-            "punpckhbw %%mm4, %%mm3                 \n\t"\
-            "psubw %%mm2, %%mm0                     \n\t"\
-            "psubw %%mm3, %%mm1                     \n\t"
-
-
-            NEXT //0
-            NEXT //1
-            NEXT //2
-            "movq %%mm0, (%3)                       \n\t"
-            "movq %%mm1, 8(%3)                      \n\t"
-
-            NEXT //3
-            "psubw %%mm5, %%mm0                     \n\t"
-            "psubw %%mm6, %%mm1                     \n\t"
-            "movq %%mm0, 16(%3)                     \n\t"
-            "movq %%mm1, 24(%3)                     \n\t"
-
-            NEXT //4
-            "psubw %%mm5, %%mm0                     \n\t"
-            "psubw %%mm6, %%mm1                     \n\t"
-            "movq %%mm0, 32(%3)                     \n\t"
-            "movq %%mm1, 40(%3)                     \n\t"
-
-            NEXT //5
-            "psubw %%mm5, %%mm0                     \n\t"
-            "psubw %%mm6, %%mm1                     \n\t"
-            "movq %%mm0, 48(%3)                     \n\t"
-            "movq %%mm1, 56(%3)                     \n\t"
-
-            NEXT //6
-            "psubw %%mm5, %%mm0                     \n\t"
-            "psubw %%mm6, %%mm1                     \n\t"
-            "movq %%mm0, 64(%3)                     \n\t"
-            "movq %%mm1, 72(%3)                     \n\t"
-
-            "movq %%mm7, %%mm6                      \n\t"
-            "punpckhbw %%mm4, %%mm7                 \n\t"
-            "punpcklbw %%mm4, %%mm6                 \n\t"
-
-            NEXT //7
-            "mov %4, %0                             \n\t"
-            "add %1, %0                             \n\t"
-            PREV //0
-            "movq %%mm0, 80(%3)                     \n\t"
-            "movq %%mm1, 88(%3)                     \n\t"
-
-            PREV //1
-            "paddw %%mm6, %%mm0                     \n\t"
-            "paddw %%mm7, %%mm1                     \n\t"
-            "movq %%mm0, 96(%3)                     \n\t"
-            "movq %%mm1, 104(%3)                    \n\t"
-
-            PREV //2
-            "paddw %%mm6, %%mm0                     \n\t"
-            "paddw %%mm7, %%mm1                     \n\t"
-            "movq %%mm0, 112(%3)                    \n\t"
-            "movq %%mm1, 120(%3)                    \n\t"
-
-            PREV //3
-            "paddw %%mm6, %%mm0                     \n\t"
-            "paddw %%mm7, %%mm1                     \n\t"
-            "movq %%mm0, 128(%3)                    \n\t"
-            "movq %%mm1, 136(%3)                    \n\t"
-
-            PREV //4
-            "paddw %%mm6, %%mm0                     \n\t"
-            "paddw %%mm7, %%mm1                     \n\t"
-            "movq %%mm0, 144(%3)                    \n\t"
-            "movq %%mm1, 152(%3)                    \n\t"
-
-            "mov %4, %0                             \n\t" //FIXME
-
-            : "+&r"(src)
-            : "r" ((x86_reg)step), "m" (c->pQPb), "r"(sums), "g"(src)
-        );
-
-        src+= step; // src points to begin of the 8x8 Block
-
-        __asm__ volatile(
-            "movq %4, %%mm6                         \n\t"
-            "pcmpeqb %%mm5, %%mm5                   \n\t"
-            "pxor %%mm6, %%mm5                      \n\t"
-            "pxor %%mm7, %%mm7                      \n\t"
-
-            "1:                                     \n\t"
-            "movq (%1), %%mm0                       \n\t"
-            "movq 8(%1), %%mm1                      \n\t"
-            "paddw 32(%1), %%mm0                    \n\t"
-            "paddw 40(%1), %%mm1                    \n\t"
-            "movq (%0, %3), %%mm2                   \n\t"
-            "movq %%mm2, %%mm3                      \n\t"
-            "movq %%mm2, %%mm4                      \n\t"
-            "punpcklbw %%mm7, %%mm2                 \n\t"
-            "punpckhbw %%mm7, %%mm3                 \n\t"
-            "paddw %%mm2, %%mm0                     \n\t"
-            "paddw %%mm3, %%mm1                     \n\t"
-            "paddw %%mm2, %%mm0                     \n\t"
-            "paddw %%mm3, %%mm1                     \n\t"
-            "psrlw $4, %%mm0                        \n\t"
-            "psrlw $4, %%mm1                        \n\t"
-            "packuswb %%mm1, %%mm0                  \n\t"
-            "pand %%mm6, %%mm0                      \n\t"
-            "pand %%mm5, %%mm4                      \n\t"
-            "por %%mm4, %%mm0                       \n\t"
-            "movq %%mm0, (%0, %3)                   \n\t"
-            "add $16, %1                            \n\t"
-            "add %2, %0                             \n\t"
-            " js 1b                                 \n\t"
-
-            : "+r"(offset), "+r"(temp_sums)
-            : "r" ((x86_reg)step), "r"(src - offset), "m"(both_masks)
-        );
-    }else
-        src+= step; // src points to begin of the 8x8 Block
-
-    if(eq_mask != -1LL){
-        uint8_t *temp_src= src;
-        DECLARE_ALIGNED(8, uint64_t, tmp)[4]; // make space for 4 8-byte vars
-        __asm__ volatile(
-            "pxor %%mm7, %%mm7                      \n\t"
-//      0       1       2       3       4       5       6       7       8       9
-//      %0      eax     eax+%1  eax+2%1 %0+4%1  ecx     ecx+%1  ecx+2%1 %1+8%1  ecx+4%1
-
-            "movq (%0), %%mm0                       \n\t"
-            "movq %%mm0, %%mm1                      \n\t"
-            "punpcklbw %%mm7, %%mm0                 \n\t" // low part of line 0
-            "punpckhbw %%mm7, %%mm1                 \n\t" // high part of line 0
-
-            "movq (%0, %1), %%mm2                   \n\t"
-            "lea (%0, %1, 2), %%"REG_a"             \n\t"
-            "movq %%mm2, %%mm3                      \n\t"
-            "punpcklbw %%mm7, %%mm2                 \n\t" // low part of line 1
-            "punpckhbw %%mm7, %%mm3                 \n\t" // high part of line 1
-
-            "movq (%%"REG_a"), %%mm4                \n\t"
-            "movq %%mm4, %%mm5                      \n\t"
-            "punpcklbw %%mm7, %%mm4                 \n\t" // low part of line 2
-            "punpckhbw %%mm7, %%mm5                 \n\t" // high part of line 2
-
-            "paddw %%mm0, %%mm0                     \n\t" // 2L0
-            "paddw %%mm1, %%mm1                     \n\t" // 2H0
-            "psubw %%mm4, %%mm2                     \n\t" // L1 - L2
-            "psubw %%mm5, %%mm3                     \n\t" // H1 - H2
-            "psubw %%mm2, %%mm0                     \n\t" // 2L0 - L1 + L2
-            "psubw %%mm3, %%mm1                     \n\t" // 2H0 - H1 + H2
-
-            "psllw $2, %%mm2                        \n\t" // 4L1 - 4L2
-            "psllw $2, %%mm3                        \n\t" // 4H1 - 4H2
-            "psubw %%mm2, %%mm0                     \n\t" // 2L0 - 5L1 + 5L2
-            "psubw %%mm3, %%mm1                     \n\t" // 2H0 - 5H1 + 5H2
-
-            "movq (%%"REG_a", %1), %%mm2            \n\t"
-            "movq %%mm2, %%mm3                      \n\t"
-            "punpcklbw %%mm7, %%mm2                 \n\t" // L3
-            "punpckhbw %%mm7, %%mm3                 \n\t" // H3
-
-            "psubw %%mm2, %%mm0                     \n\t" // 2L0 - 5L1 + 5L2 - L3
-            "psubw %%mm3, %%mm1                     \n\t" // 2H0 - 5H1 + 5H2 - H3
-            "psubw %%mm2, %%mm0                     \n\t" // 2L0 - 5L1 + 5L2 - 2L3
-            "psubw %%mm3, %%mm1                     \n\t" // 2H0 - 5H1 + 5H2 - 2H3
-            "movq %%mm0, (%4)                       \n\t" // 2L0 - 5L1 + 5L2 - 2L3
-            "movq %%mm1, 8(%4)                      \n\t" // 2H0 - 5H1 + 5H2 - 2H3
-
-            "movq (%%"REG_a", %1, 2), %%mm0         \n\t"
-            "movq %%mm0, %%mm1                      \n\t"
-            "punpcklbw %%mm7, %%mm0                 \n\t" // L4
-            "punpckhbw %%mm7, %%mm1                 \n\t" // H4
-
-            "psubw %%mm0, %%mm2                     \n\t" // L3 - L4
-            "psubw %%mm1, %%mm3                     \n\t" // H3 - H4
-            "movq %%mm2, 16(%4)                     \n\t" // L3 - L4
-            "movq %%mm3, 24(%4)                     \n\t" // H3 - H4
-            "paddw %%mm4, %%mm4                     \n\t" // 2L2
-            "paddw %%mm5, %%mm5                     \n\t" // 2H2
-            "psubw %%mm2, %%mm4                     \n\t" // 2L2 - L3 + L4
-            "psubw %%mm3, %%mm5                     \n\t" // 2H2 - H3 + H4
-
-            "lea (%%"REG_a", %1), %0                \n\t"
-            "psllw $2, %%mm2                        \n\t" // 4L3 - 4L4
-            "psllw $2, %%mm3                        \n\t" // 4H3 - 4H4
-            "psubw %%mm2, %%mm4                     \n\t" // 2L2 - 5L3 + 5L4
-            "psubw %%mm3, %%mm5                     \n\t" // 2H2 - 5H3 + 5H4
-//50 opcodes so far
-            "movq (%0, %1, 2), %%mm2                \n\t"
-            "movq %%mm2, %%mm3                      \n\t"
-            "punpcklbw %%mm7, %%mm2                 \n\t" // L5
-            "punpckhbw %%mm7, %%mm3                 \n\t" // H5
-            "psubw %%mm2, %%mm4                     \n\t" // 2L2 - 5L3 + 5L4 - L5
-            "psubw %%mm3, %%mm5                     \n\t" // 2H2 - 5H3 + 5H4 - H5
-            "psubw %%mm2, %%mm4                     \n\t" // 2L2 - 5L3 + 5L4 - 2L5
-            "psubw %%mm3, %%mm5                     \n\t" // 2H2 - 5H3 + 5H4 - 2H5
-
-            "movq (%%"REG_a", %1, 4), %%mm6         \n\t"
-            "punpcklbw %%mm7, %%mm6                 \n\t" // L6
-            "psubw %%mm6, %%mm2                     \n\t" // L5 - L6
-            "movq (%%"REG_a", %1, 4), %%mm6         \n\t"
-            "punpckhbw %%mm7, %%mm6                 \n\t" // H6
-            "psubw %%mm6, %%mm3                     \n\t" // H5 - H6
-
-            "paddw %%mm0, %%mm0                     \n\t" // 2L4
-            "paddw %%mm1, %%mm1                     \n\t" // 2H4
-            "psubw %%mm2, %%mm0                     \n\t" // 2L4 - L5 + L6
-            "psubw %%mm3, %%mm1                     \n\t" // 2H4 - H5 + H6
-
-            "psllw $2, %%mm2                        \n\t" // 4L5 - 4L6
-            "psllw $2, %%mm3                        \n\t" // 4H5 - 4H6
-            "psubw %%mm2, %%mm0                     \n\t" // 2L4 - 5L5 + 5L6
-            "psubw %%mm3, %%mm1                     \n\t" // 2H4 - 5H5 + 5H6
-
-            "movq (%0, %1, 4), %%mm2                \n\t"
-            "movq %%mm2, %%mm3                      \n\t"
-            "punpcklbw %%mm7, %%mm2                 \n\t" // L7
-            "punpckhbw %%mm7, %%mm3                 \n\t" // H7
-
-            "paddw %%mm2, %%mm2                     \n\t" // 2L7
-            "paddw %%mm3, %%mm3                     \n\t" // 2H7
-            "psubw %%mm2, %%mm0                     \n\t" // 2L4 - 5L5 + 5L6 - 2L7
-            "psubw %%mm3, %%mm1                     \n\t" // 2H4 - 5H5 + 5H6 - 2H7
-
-            "movq (%4), %%mm2                       \n\t" // 2L0 - 5L1 + 5L2 - 2L3
-            "movq 8(%4), %%mm3                      \n\t" // 2H0 - 5H1 + 5H2 - 2H3
-
-#if TEMPLATE_PP_MMXEXT
-            "movq %%mm7, %%mm6                      \n\t" // 0
-            "psubw %%mm0, %%mm6                     \n\t"
-            "pmaxsw %%mm6, %%mm0                    \n\t" // |2L4 - 5L5 + 5L6 - 2L7|
-            "movq %%mm7, %%mm6                      \n\t" // 0
-            "psubw %%mm1, %%mm6                     \n\t"
-            "pmaxsw %%mm6, %%mm1                    \n\t" // |2H4 - 5H5 + 5H6 - 2H7|
-            "movq %%mm7, %%mm6                      \n\t" // 0
-            "psubw %%mm2, %%mm6                     \n\t"
-            "pmaxsw %%mm6, %%mm2                    \n\t" // |2L0 - 5L1 + 5L2 - 2L3|
-            "movq %%mm7, %%mm6                      \n\t" // 0
-            "psubw %%mm3, %%mm6                     \n\t"
-            "pmaxsw %%mm6, %%mm3                    \n\t" // |2H0 - 5H1 + 5H2 - 2H3|
-#else
-            "movq %%mm7, %%mm6                      \n\t" // 0
-            "pcmpgtw %%mm0, %%mm6                   \n\t"
-            "pxor %%mm6, %%mm0                      \n\t"
-            "psubw %%mm6, %%mm0                     \n\t" // |2L4 - 5L5 + 5L6 - 2L7|
-            "movq %%mm7, %%mm6                      \n\t" // 0
-            "pcmpgtw %%mm1, %%mm6                   \n\t"
-            "pxor %%mm6, %%mm1                      \n\t"
-            "psubw %%mm6, %%mm1                     \n\t" // |2H4 - 5H5 + 5H6 - 2H7|
-            "movq %%mm7, %%mm6                      \n\t" // 0
-            "pcmpgtw %%mm2, %%mm6                   \n\t"
-            "pxor %%mm6, %%mm2                      \n\t"
-            "psubw %%mm6, %%mm2                     \n\t" // |2L0 - 5L1 + 5L2 - 2L3|
-            "movq %%mm7, %%mm6                      \n\t" // 0
-            "pcmpgtw %%mm3, %%mm6                   \n\t"
-            "pxor %%mm6, %%mm3                      \n\t"
-            "psubw %%mm6, %%mm3                     \n\t" // |2H0 - 5H1 + 5H2 - 2H3|
-#endif
-
-#if TEMPLATE_PP_MMXEXT
-            "pminsw %%mm2, %%mm0                    \n\t"
-            "pminsw %%mm3, %%mm1                    \n\t"
-#else
-            "movq %%mm0, %%mm6                      \n\t"
-            "psubusw %%mm2, %%mm6                   \n\t"
-            "psubw %%mm6, %%mm0                     \n\t"
-            "movq %%mm1, %%mm6                      \n\t"
-            "psubusw %%mm3, %%mm6                   \n\t"
-            "psubw %%mm6, %%mm1                     \n\t"
-#endif
-
-            "movd %2, %%mm2                         \n\t" // QP
-            "punpcklbw %%mm7, %%mm2                 \n\t"
-
-            "movq %%mm7, %%mm6                      \n\t" // 0
-            "pcmpgtw %%mm4, %%mm6                   \n\t" // sign(2L2 - 5L3 + 5L4 - 2L5)
-            "pxor %%mm6, %%mm4                      \n\t"
-            "psubw %%mm6, %%mm4                     \n\t" // |2L2 - 5L3 + 5L4 - 2L5|
-            "pcmpgtw %%mm5, %%mm7                   \n\t" // sign(2H2 - 5H3 + 5H4 - 2H5)
-            "pxor %%mm7, %%mm5                      \n\t"
-            "psubw %%mm7, %%mm5                     \n\t" // |2H2 - 5H3 + 5H4 - 2H5|
-// 100 opcodes
-            "psllw $3, %%mm2                        \n\t" // 8QP
-            "movq %%mm2, %%mm3                      \n\t" // 8QP
-            "pcmpgtw %%mm4, %%mm2                   \n\t"
-            "pcmpgtw %%mm5, %%mm3                   \n\t"
-            "pand %%mm2, %%mm4                      \n\t"
-            "pand %%mm3, %%mm5                      \n\t"
-
-
-            "psubusw %%mm0, %%mm4                   \n\t" // hd
-            "psubusw %%mm1, %%mm5                   \n\t" // ld
-
-
-            "movq "MANGLE(w05)", %%mm2              \n\t" // 5
-            "pmullw %%mm2, %%mm4                    \n\t"
-            "pmullw %%mm2, %%mm5                    \n\t"
-            "movq "MANGLE(w20)", %%mm2              \n\t" // 32
-            "paddw %%mm2, %%mm4                     \n\t"
-            "paddw %%mm2, %%mm5                     \n\t"
-            "psrlw $6, %%mm4                        \n\t"
-            "psrlw $6, %%mm5                        \n\t"
-
-            "movq 16(%4), %%mm0                     \n\t" // L3 - L4
-            "movq 24(%4), %%mm1                     \n\t" // H3 - H4
-
-            "pxor %%mm2, %%mm2                      \n\t"
-            "pxor %%mm3, %%mm3                      \n\t"
-
-            "pcmpgtw %%mm0, %%mm2                   \n\t" // sign (L3-L4)
-            "pcmpgtw %%mm1, %%mm3                   \n\t" // sign (H3-H4)
-            "pxor %%mm2, %%mm0                      \n\t"
-            "pxor %%mm3, %%mm1                      \n\t"
-            "psubw %%mm2, %%mm0                     \n\t" // |L3-L4|
-            "psubw %%mm3, %%mm1                     \n\t" // |H3-H4|
-            "psrlw $1, %%mm0                        \n\t" // |L3 - L4|/2
-            "psrlw $1, %%mm1                        \n\t" // |H3 - H4|/2
-
-            "pxor %%mm6, %%mm2                      \n\t"
-            "pxor %%mm7, %%mm3                      \n\t"
-            "pand %%mm2, %%mm4                      \n\t"
-            "pand %%mm3, %%mm5                      \n\t"
-
-#if TEMPLATE_PP_MMXEXT
-            "pminsw %%mm0, %%mm4                    \n\t"
-            "pminsw %%mm1, %%mm5                    \n\t"
-#else
-            "movq %%mm4, %%mm2                      \n\t"
-            "psubusw %%mm0, %%mm2                   \n\t"
-            "psubw %%mm2, %%mm4                     \n\t"
-            "movq %%mm5, %%mm2                      \n\t"
-            "psubusw %%mm1, %%mm2                   \n\t"
-            "psubw %%mm2, %%mm5                     \n\t"
-#endif
-            "pxor %%mm6, %%mm4                      \n\t"
-            "pxor %%mm7, %%mm5                      \n\t"
-            "psubw %%mm6, %%mm4                     \n\t"
-            "psubw %%mm7, %%mm5                     \n\t"
-            "packsswb %%mm5, %%mm4                  \n\t"
-            "movq %3, %%mm1                         \n\t"
-            "pandn %%mm4, %%mm1                     \n\t"
-            "movq (%0), %%mm0                       \n\t"
-            "paddb   %%mm1, %%mm0                   \n\t"
-            "movq %%mm0, (%0)                       \n\t"
-            "movq (%0, %1), %%mm0                   \n\t"
-            "psubb %%mm1, %%mm0                     \n\t"
-            "movq %%mm0, (%0, %1)                   \n\t"
-
-            : "+r" (temp_src)
-            : "r" ((x86_reg)step), "m" (c->pQPb), "m"(eq_mask), "r"(tmp)
-            : "%"REG_a
-        );
-    }
-/*if(step==16){
-    STOP_TIMER("step16")
-}else{
-    STOP_TIMER("stepX")
-}
-    } */
-}
-#endif //TEMPLATE_PP_MMX
-
-static void RENAME(postProcess)(const uint8_t src[], int srcStride, uint8_t dst[], int dstStride, int width, int height,
-                                const QP_STORE_T QPs[], int QPStride, int isColor, PPContext *c);
-
-/**
- * Copy a block from src to dst and fixes the blacklevel.
- * levelFix == 0 -> do not touch the brightness & contrast
- */
-#undef REAL_SCALED_CPY
-#undef SCALED_CPY
-
-static inline void RENAME(blockCopy)(uint8_t dst[], int dstStride, const uint8_t src[], int srcStride,
-                                     int levelFix, int64_t *packedOffsetAndScale)
-{
-#if !TEMPLATE_PP_MMX
-    int i;
-#endif
-    if(levelFix){
-#if TEMPLATE_PP_MMX
-    __asm__ volatile(
-        "movq (%%"REG_a"), %%mm2        \n\t" // packedYOffset
-        "movq 8(%%"REG_a"), %%mm3       \n\t" // packedYScale
-        "lea (%2,%4), %%"REG_a"         \n\t"
-        "lea (%3,%5), %%"REG_d"         \n\t"
-        "pxor %%mm4, %%mm4              \n\t"
-#if TEMPLATE_PP_MMXEXT
-#define REAL_SCALED_CPY(src1, src2, dst1, dst2)                                                \
-        "movq " #src1 ", %%mm0          \n\t"\
-        "movq " #src1 ", %%mm5          \n\t"\
-        "movq " #src2 ", %%mm1          \n\t"\
-        "movq " #src2 ", %%mm6          \n\t"\
-        "punpcklbw %%mm0, %%mm0         \n\t"\
-        "punpckhbw %%mm5, %%mm5         \n\t"\
-        "punpcklbw %%mm1, %%mm1         \n\t"\
-        "punpckhbw %%mm6, %%mm6         \n\t"\
-        "pmulhuw %%mm3, %%mm0           \n\t"\
-        "pmulhuw %%mm3, %%mm5           \n\t"\
-        "pmulhuw %%mm3, %%mm1           \n\t"\
-        "pmulhuw %%mm3, %%mm6           \n\t"\
-        "psubw %%mm2, %%mm0             \n\t"\
-        "psubw %%mm2, %%mm5             \n\t"\
-        "psubw %%mm2, %%mm1             \n\t"\
-        "psubw %%mm2, %%mm6             \n\t"\
-        "packuswb %%mm5, %%mm0          \n\t"\
-        "packuswb %%mm6, %%mm1          \n\t"\
-        "movq %%mm0, " #dst1 "          \n\t"\
-        "movq %%mm1, " #dst2 "          \n\t"\
-
-#else //TEMPLATE_PP_MMXEXT
-#define REAL_SCALED_CPY(src1, src2, dst1, dst2)                                        \
-        "movq " #src1 ", %%mm0          \n\t"\
-        "movq " #src1 ", %%mm5          \n\t"\
-        "punpcklbw %%mm4, %%mm0         \n\t"\
-        "punpckhbw %%mm4, %%mm5         \n\t"\
-        "psubw %%mm2, %%mm0             \n\t"\
-        "psubw %%mm2, %%mm5             \n\t"\
-        "movq " #src2 ", %%mm1          \n\t"\
-        "psllw $6, %%mm0                \n\t"\
-        "psllw $6, %%mm5                \n\t"\
-        "pmulhw %%mm3, %%mm0            \n\t"\
-        "movq " #src2 ", %%mm6          \n\t"\
-        "pmulhw %%mm3, %%mm5            \n\t"\
-        "punpcklbw %%mm4, %%mm1         \n\t"\
-        "punpckhbw %%mm4, %%mm6         \n\t"\
-        "psubw %%mm2, %%mm1             \n\t"\
-        "psubw %%mm2, %%mm6             \n\t"\
-        "psllw $6, %%mm1                \n\t"\
-        "psllw $6, %%mm6                \n\t"\
-        "pmulhw %%mm3, %%mm1            \n\t"\
-        "pmulhw %%mm3, %%mm6            \n\t"\
-        "packuswb %%mm5, %%mm0          \n\t"\
-        "packuswb %%mm6, %%mm1          \n\t"\
-        "movq %%mm0, " #dst1 "          \n\t"\
-        "movq %%mm1, " #dst2 "          \n\t"\
-
-#endif //TEMPLATE_PP_MMXEXT
-#define SCALED_CPY(src1, src2, dst1, dst2)\
-   REAL_SCALED_CPY(src1, src2, dst1, dst2)
-
-SCALED_CPY((%2)       , (%2, %4)      , (%3)       , (%3, %5))
-SCALED_CPY((%2, %4, 2), (%%REGa, %4, 2), (%3, %5, 2), (%%REGd, %5, 2))
-SCALED_CPY((%2, %4, 4), (%%REGa, %4, 4), (%3, %5, 4), (%%REGd, %5, 4))
-        "lea (%%"REG_a",%4,4), %%"REG_a"        \n\t"
-        "lea (%%"REG_d",%5,4), %%"REG_d"        \n\t"
-SCALED_CPY((%%REGa, %4), (%%REGa, %4, 2), (%%REGd, %5), (%%REGd, %5, 2))
-
-
-        : "=&a" (packedOffsetAndScale)
-        : "0" (packedOffsetAndScale),
-        "r"(src),
-        "r"(dst),
-        "r" ((x86_reg)srcStride),
-        "r" ((x86_reg)dstStride)
-        : "%"REG_d
-    );
-#else //TEMPLATE_PP_MMX
-    for(i=0; i<8; i++)
-        memcpy( &(dst[dstStride*i]),
-                &(src[srcStride*i]), BLOCK_SIZE);
-#endif //TEMPLATE_PP_MMX
-    }else{
-#if TEMPLATE_PP_MMX
-    __asm__ volatile(
-        "lea (%0,%2), %%"REG_a"                 \n\t"
-        "lea (%1,%3), %%"REG_d"                 \n\t"
-
-#define REAL_SIMPLE_CPY(src1, src2, dst1, dst2)                              \
-        "movq " #src1 ", %%mm0          \n\t"\
-        "movq " #src2 ", %%mm1          \n\t"\
-        "movq %%mm0, " #dst1 "          \n\t"\
-        "movq %%mm1, " #dst2 "          \n\t"\
-
-#define SIMPLE_CPY(src1, src2, dst1, dst2)\
-   REAL_SIMPLE_CPY(src1, src2, dst1, dst2)
-
-SIMPLE_CPY((%0)       , (%0, %2)       , (%1)       , (%1, %3))
-SIMPLE_CPY((%0, %2, 2), (%%REGa, %2, 2), (%1, %3, 2), (%%REGd, %3, 2))
-SIMPLE_CPY((%0, %2, 4), (%%REGa, %2, 4), (%1, %3, 4), (%%REGd, %3, 4))
-        "lea (%%"REG_a",%2,4), %%"REG_a"        \n\t"
-        "lea (%%"REG_d",%3,4), %%"REG_d"        \n\t"
-SIMPLE_CPY((%%REGa, %2), (%%REGa, %2, 2), (%%REGd, %3), (%%REGd, %3, 2))
-
-        : : "r" (src),
-        "r" (dst),
-        "r" ((x86_reg)srcStride),
-        "r" ((x86_reg)dstStride)
-        : "%"REG_a, "%"REG_d
-    );
-#else //TEMPLATE_PP_MMX
-    for(i=0; i<8; i++)
-        memcpy( &(dst[dstStride*i]),
-                &(src[srcStride*i]), BLOCK_SIZE);
-#endif //TEMPLATE_PP_MMX
-    }
-}
-
-/**
- * Duplicate the given 8 src pixels ? times upward
- */
-static inline void RENAME(duplicate)(uint8_t src[], int stride)
-{
-#if TEMPLATE_PP_MMX
-    __asm__ volatile(
-        "movq (%0), %%mm0               \n\t"
-        "movq %%mm0, (%0, %1, 4)        \n\t"
-        "add %1, %0                     \n\t"
-        "movq %%mm0, (%0)               \n\t"
-        "movq %%mm0, (%0, %1)           \n\t"
-        "movq %%mm0, (%0, %1, 2)        \n\t"
-        "movq %%mm0, (%0, %1, 4)        \n\t"
-        : "+r" (src)
-        : "r" ((x86_reg)-stride)
-    );
-#else
-    int i;
-    uint8_t *p=src;
-    for(i=0; i<5; i++){
-        p-= stride;
-        memcpy(p, src, 8);
-    }
-#endif
-}
-
-/**
- * Filter array of bytes (Y or U or V values)
- */
-static void RENAME(postProcess)(const uint8_t src[], int srcStride, uint8_t dst[], int dstStride, int width, int height,
-                                const QP_STORE_T QPs[], int QPStride, int isColor, PPContext *c2)
-{
-    DECLARE_ALIGNED(8, PPContext, c)= *c2; //copy to stack for faster access
-    int x,y;
-#ifdef TEMPLATE_PP_TIME_MODE
-    const int mode= TEMPLATE_PP_TIME_MODE;
-#else
-    const int mode= isColor ? c.ppMode.chromMode : c.ppMode.lumMode;
-#endif
-    int black=0, white=255; // blackest black and whitest white in the picture
-    int QPCorrecture= 256*256;
-
-    int copyAhead;
-#if TEMPLATE_PP_MMX
-    int i;
-#endif
-
-    const int qpHShift= isColor ? 4-c.hChromaSubSample : 4;
-    const int qpVShift= isColor ? 4-c.vChromaSubSample : 4;
-
-    //FIXME remove
-    uint64_t * const yHistogram= c.yHistogram;
-    uint8_t * const tempSrc= srcStride > 0 ? c.tempSrc : c.tempSrc - 23*srcStride;
-    uint8_t * const tempDst= (dstStride > 0 ? c.tempDst : c.tempDst - 23*dstStride) + 32;
-    //const int mbWidth= isColor ? (width+7)>>3 : (width+15)>>4;
-
-#if TEMPLATE_PP_MMX
-    for(i=0; i<57; i++){
-        int offset= ((i*c.ppMode.baseDcDiff)>>8) + 1;
-        int threshold= offset*2 + 1;
-        c.mmxDcOffset[i]= 0x7F - offset;
-        c.mmxDcThreshold[i]= 0x7F - threshold;
-        c.mmxDcOffset[i]*= 0x0101010101010101LL;
-        c.mmxDcThreshold[i]*= 0x0101010101010101LL;
-    }
-#endif
-
-    if(mode & CUBIC_IPOL_DEINT_FILTER) copyAhead=16;
-    else if(   (mode & LINEAR_BLEND_DEINT_FILTER)
-            || (mode & FFMPEG_DEINT_FILTER)
-            || (mode & LOWPASS5_DEINT_FILTER)) copyAhead=14;
-    else if(   (mode & V_DEBLOCK)
-            || (mode & LINEAR_IPOL_DEINT_FILTER)
-            || (mode & MEDIAN_DEINT_FILTER)
-            || (mode & V_A_DEBLOCK)) copyAhead=13;
-    else if(mode & V_X1_FILTER) copyAhead=11;
-//    else if(mode & V_RK1_FILTER) copyAhead=10;
-    else if(mode & DERING) copyAhead=9;
-    else copyAhead=8;
-
-    copyAhead-= 8;
-
-    if(!isColor){
-        uint64_t sum= 0;
-        int i;
-        uint64_t maxClipped;
-        uint64_t clipped;
-        double scale;
-
-        c.frameNum++;
-        // first frame is fscked so we ignore it
-        if(c.frameNum == 1) yHistogram[0]= width*(uint64_t)height/64*15/256;
-
-        for(i=0; i<256; i++){
-            sum+= yHistogram[i];
-        }
-
-        /* We always get a completely black picture first. */
-        maxClipped= (uint64_t)(sum * c.ppMode.maxClippedThreshold);
-
-        clipped= sum;
-        for(black=255; black>0; black--){
-            if(clipped < maxClipped) break;
-            clipped-= yHistogram[black];
-        }
-
-        clipped= sum;
-        for(white=0; white<256; white++){
-            if(clipped < maxClipped) break;
-            clipped-= yHistogram[white];
-        }
-
-        scale= (double)(c.ppMode.maxAllowedY - c.ppMode.minAllowedY) / (double)(white-black);
-
-#if TEMPLATE_PP_MMXEXT
-        c.packedYScale= (uint16_t)(scale*256.0 + 0.5);
-        c.packedYOffset= (((black*c.packedYScale)>>8) - c.ppMode.minAllowedY) & 0xFFFF;
-#else
-        c.packedYScale= (uint16_t)(scale*1024.0 + 0.5);
-        c.packedYOffset= (black - c.ppMode.minAllowedY) & 0xFFFF;
-#endif
-
-        c.packedYOffset|= c.packedYOffset<<32;
-        c.packedYOffset|= c.packedYOffset<<16;
-
-        c.packedYScale|= c.packedYScale<<32;
-        c.packedYScale|= c.packedYScale<<16;
-
-        if(mode & LEVEL_FIX)        QPCorrecture= (int)(scale*256*256 + 0.5);
-        else                        QPCorrecture= 256*256;
-    }else{
-        c.packedYScale= 0x0100010001000100LL;
-        c.packedYOffset= 0;
-        QPCorrecture= 256*256;
-    }
-
-    /* copy & deinterlace first row of blocks */
-    y=-BLOCK_SIZE;
-    {
-        const uint8_t *srcBlock= &(src[y*srcStride]);
-        uint8_t *dstBlock= tempDst + dstStride;
-
-        // From this point on it is guaranteed that we can read and write 16 lines downward
-        // finish 1 block before the next otherwise we might have a problem
-        // with the L1 Cache of the P4 ... or only a few blocks at a time or something
-        for(x=0; x<width; x+=BLOCK_SIZE){
-
-#if TEMPLATE_PP_MMXEXT
-/*
-            prefetchnta(srcBlock + (((x>>2)&6) + 5)*srcStride + 32);
-            prefetchnta(srcBlock + (((x>>2)&6) + 6)*srcStride + 32);
-            prefetcht0(dstBlock + (((x>>2)&6) + 5)*dstStride + 32);
-            prefetcht0(dstBlock + (((x>>2)&6) + 6)*dstStride + 32);
-*/
-
-            __asm__(
-                "mov %4, %%"REG_a"              \n\t"
-                "shr $2, %%"REG_a"              \n\t"
-                "and $6, %%"REG_a"              \n\t"
-                "add %5, %%"REG_a"              \n\t"
-                "mov %%"REG_a", %%"REG_d"       \n\t"
-                "imul %1, %%"REG_a"             \n\t"
-                "imul %3, %%"REG_d"             \n\t"
-                "prefetchnta 32(%%"REG_a", %0)  \n\t"
-                "prefetcht0 32(%%"REG_d", %2)   \n\t"
-                "add %1, %%"REG_a"              \n\t"
-                "add %3, %%"REG_d"              \n\t"
-                "prefetchnta 32(%%"REG_a", %0)  \n\t"
-                "prefetcht0 32(%%"REG_d", %2)   \n\t"
-                :: "r" (srcBlock), "r" ((x86_reg)srcStride), "r" (dstBlock), "r" ((x86_reg)dstStride),
-                "g" ((x86_reg)x), "g" ((x86_reg)copyAhead)
-                : "%"REG_a, "%"REG_d
-            );
-
-#elif TEMPLATE_PP_3DNOW
-//FIXME check if this is faster on an 3dnow chip or if it is faster without the prefetch or ...
-/*          prefetch(srcBlock + (((x>>3)&3) + 5)*srcStride + 32);
-            prefetch(srcBlock + (((x>>3)&3) + 9)*srcStride + 32);
-            prefetchw(dstBlock + (((x>>3)&3) + 5)*dstStride + 32);
-            prefetchw(dstBlock + (((x>>3)&3) + 9)*dstStride + 32);
-*/
-#endif
-
-            RENAME(blockCopy)(dstBlock + dstStride*8, dstStride,
-                              srcBlock + srcStride*8, srcStride, mode & LEVEL_FIX, &c.packedYOffset);
-
-            RENAME(duplicate)(dstBlock + dstStride*8, dstStride);
-
-            if(mode & LINEAR_IPOL_DEINT_FILTER)
-                RENAME(deInterlaceInterpolateLinear)(dstBlock, dstStride);
-            else if(mode & LINEAR_BLEND_DEINT_FILTER)
-                RENAME(deInterlaceBlendLinear)(dstBlock, dstStride, c.deintTemp + x);
-            else if(mode & MEDIAN_DEINT_FILTER)
-                RENAME(deInterlaceMedian)(dstBlock, dstStride);
-            else if(mode & CUBIC_IPOL_DEINT_FILTER)
-                RENAME(deInterlaceInterpolateCubic)(dstBlock, dstStride);
-            else if(mode & FFMPEG_DEINT_FILTER)
-                RENAME(deInterlaceFF)(dstBlock, dstStride, c.deintTemp + x);
-            else if(mode & LOWPASS5_DEINT_FILTER)
-                RENAME(deInterlaceL5)(dstBlock, dstStride, c.deintTemp + x, c.deintTemp + width + x);
-/*          else if(mode & CUBIC_BLEND_DEINT_FILTER)
-                RENAME(deInterlaceBlendCubic)(dstBlock, dstStride);
-*/
-            dstBlock+=8;
-            srcBlock+=8;
-        }
-        if(width==FFABS(dstStride))
-            linecpy(dst, tempDst + 9*dstStride, copyAhead, dstStride);
-        else{
-            int i;
-            for(i=0; i<copyAhead; i++){
-                memcpy(dst + i*dstStride, tempDst + (9+i)*dstStride, width);
-            }
-        }
-    }
-
-    for(y=0; y<height; y+=BLOCK_SIZE){
-        //1% speedup if these are here instead of the inner loop
-        const uint8_t *srcBlock= &(src[y*srcStride]);
-        uint8_t *dstBlock= &(dst[y*dstStride]);
-#if TEMPLATE_PP_MMX
-        uint8_t *tempBlock1= c.tempBlocks;
-        uint8_t *tempBlock2= c.tempBlocks + 8;
-#endif
-        const int8_t *QPptr= &QPs[(y>>qpVShift)*QPStride];
-        int8_t *nonBQPptr= &c.nonBQPTable[(y>>qpVShift)*FFABS(QPStride)];
-        int QP=0;
-        /* can we mess with a 8x16 block from srcBlock/dstBlock downwards and 1 line upwards
-           if not than use a temporary buffer */
-        if(y+15 >= height){
-            int i;
-            /* copy from line (copyAhead) to (copyAhead+7) of src, these will be copied with
-               blockcopy to dst later */
-            linecpy(tempSrc + srcStride*copyAhead, srcBlock + srcStride*copyAhead,
-                    FFMAX(height-y-copyAhead, 0), srcStride);
-
-            /* duplicate last line of src to fill the void up to line (copyAhead+7) */
-            for(i=FFMAX(height-y, 8); i<copyAhead+8; i++)
-                    memcpy(tempSrc + srcStride*i, src + srcStride*(height-1), FFABS(srcStride));
-
-            /* copy up to (copyAhead+1) lines of dst (line -1 to (copyAhead-1))*/
-            linecpy(tempDst, dstBlock - dstStride, FFMIN(height-y+1, copyAhead+1), dstStride);
-
-            /* duplicate last line of dst to fill the void up to line (copyAhead) */
-            for(i=height-y+1; i<=copyAhead; i++)
-                    memcpy(tempDst + dstStride*i, dst + dstStride*(height-1), FFABS(dstStride));
-
-            dstBlock= tempDst + dstStride;
-            srcBlock= tempSrc;
-        }
-
-        // From this point on it is guaranteed that we can read and write 16 lines downward
-        // finish 1 block before the next otherwise we might have a problem
-        // with the L1 Cache of the P4 ... or only a few blocks at a time or something
-        for(x=0; x<width; x+=BLOCK_SIZE){
-            const int stride= dstStride;
-#if TEMPLATE_PP_MMX
-            uint8_t *tmpXchg;
-#endif
-            if(isColor){
-                QP= QPptr[x>>qpHShift];
-                c.nonBQP= nonBQPptr[x>>qpHShift];
-            }else{
-                QP= QPptr[x>>4];
-                QP= (QP* QPCorrecture + 256*128)>>16;
-                c.nonBQP= nonBQPptr[x>>4];
-                c.nonBQP= (c.nonBQP* QPCorrecture + 256*128)>>16;
-                yHistogram[ srcBlock[srcStride*12 + 4] ]++;
-            }
-            c.QP= QP;
-#if TEMPLATE_PP_MMX
-            __asm__ volatile(
-                "movd %1, %%mm7         \n\t"
-                "packuswb %%mm7, %%mm7  \n\t" // 0, 0, 0, QP, 0, 0, 0, QP
-                "packuswb %%mm7, %%mm7  \n\t" // 0,QP, 0, QP, 0,QP, 0, QP
-                "packuswb %%mm7, %%mm7  \n\t" // QP,..., QP
-                "movq %%mm7, %0         \n\t"
-                : "=m" (c.pQPb)
-                : "r" (QP)
-            );
-#endif
-
-
-#if TEMPLATE_PP_MMXEXT
-/*
-            prefetchnta(srcBlock + (((x>>2)&6) + 5)*srcStride + 32);
-            prefetchnta(srcBlock + (((x>>2)&6) + 6)*srcStride + 32);
-            prefetcht0(dstBlock + (((x>>2)&6) + 5)*dstStride + 32);
-            prefetcht0(dstBlock + (((x>>2)&6) + 6)*dstStride + 32);
-*/
-
-            __asm__(
-                "mov %4, %%"REG_a"              \n\t"
-                "shr $2, %%"REG_a"              \n\t"
-                "and $6, %%"REG_a"              \n\t"
-                "add %5, %%"REG_a"              \n\t"
-                "mov %%"REG_a", %%"REG_d"       \n\t"
-                "imul %1, %%"REG_a"             \n\t"
-                "imul %3, %%"REG_d"             \n\t"
-                "prefetchnta 32(%%"REG_a", %0)  \n\t"
-                "prefetcht0 32(%%"REG_d", %2)   \n\t"
-                "add %1, %%"REG_a"              \n\t"
-                "add %3, %%"REG_d"              \n\t"
-                "prefetchnta 32(%%"REG_a", %0)  \n\t"
-                "prefetcht0 32(%%"REG_d", %2)   \n\t"
-                :: "r" (srcBlock), "r" ((x86_reg)srcStride), "r" (dstBlock), "r" ((x86_reg)dstStride),
-                "g" ((x86_reg)x), "g" ((x86_reg)copyAhead)
-                : "%"REG_a, "%"REG_d
-            );
-
-#elif TEMPLATE_PP_3DNOW
-//FIXME check if this is faster on an 3dnow chip or if it is faster without the prefetch or ...
-/*          prefetch(srcBlock + (((x>>3)&3) + 5)*srcStride + 32);
-            prefetch(srcBlock + (((x>>3)&3) + 9)*srcStride + 32);
-            prefetchw(dstBlock + (((x>>3)&3) + 5)*dstStride + 32);
-            prefetchw(dstBlock + (((x>>3)&3) + 9)*dstStride + 32);
-*/
-#endif
-
-            RENAME(blockCopy)(dstBlock + dstStride*copyAhead, dstStride,
-                              srcBlock + srcStride*copyAhead, srcStride, mode & LEVEL_FIX, &c.packedYOffset);
-
-            if(mode & LINEAR_IPOL_DEINT_FILTER)
-                RENAME(deInterlaceInterpolateLinear)(dstBlock, dstStride);
-            else if(mode & LINEAR_BLEND_DEINT_FILTER)
-                RENAME(deInterlaceBlendLinear)(dstBlock, dstStride, c.deintTemp + x);
-            else if(mode & MEDIAN_DEINT_FILTER)
-                RENAME(deInterlaceMedian)(dstBlock, dstStride);
-            else if(mode & CUBIC_IPOL_DEINT_FILTER)
-                RENAME(deInterlaceInterpolateCubic)(dstBlock, dstStride);
-            else if(mode & FFMPEG_DEINT_FILTER)
-                RENAME(deInterlaceFF)(dstBlock, dstStride, c.deintTemp + x);
-            else if(mode & LOWPASS5_DEINT_FILTER)
-                RENAME(deInterlaceL5)(dstBlock, dstStride, c.deintTemp + x, c.deintTemp + width + x);
-/*          else if(mode & CUBIC_BLEND_DEINT_FILTER)
-                RENAME(deInterlaceBlendCubic)(dstBlock, dstStride);
-*/
-
-            /* only deblock if we have 2 blocks */
-            if(y + 8 < height){
-                if(mode & V_X1_FILTER)
-                    RENAME(vertX1Filter)(dstBlock, stride, &c);
-                else if(mode & V_DEBLOCK){
-                    const int t= RENAME(vertClassify)(dstBlock, stride, &c);
-
-                    if(t==1)
-                        RENAME(doVertLowPass)(dstBlock, stride, &c);
-                    else if(t==2)
-                        RENAME(doVertDefFilter)(dstBlock, stride, &c);
-                }else if(mode & V_A_DEBLOCK){
-                    RENAME(do_a_deblock)(dstBlock, stride, 1, &c);
-                }
-            }
-
-#if TEMPLATE_PP_MMX
-            RENAME(transpose1)(tempBlock1, tempBlock2, dstBlock, dstStride);
-#endif
-            /* check if we have a previous block to deblock it with dstBlock */
-            if(x - 8 >= 0){
-#if TEMPLATE_PP_MMX
-                if(mode & H_X1_FILTER)
-                        RENAME(vertX1Filter)(tempBlock1, 16, &c);
-                else if(mode & H_DEBLOCK){
-//START_TIMER
-                    const int t= RENAME(vertClassify)(tempBlock1, 16, &c);
-//STOP_TIMER("dc & minmax")
-                    if(t==1)
-                        RENAME(doVertLowPass)(tempBlock1, 16, &c);
-                    else if(t==2)
-                        RENAME(doVertDefFilter)(tempBlock1, 16, &c);
-                }else if(mode & H_A_DEBLOCK){
-                        RENAME(do_a_deblock)(tempBlock1, 16, 1, &c);
-                }
-
-                RENAME(transpose2)(dstBlock-4, dstStride, tempBlock1 + 4*16);
-
-#else
-                if(mode & H_X1_FILTER)
-                    horizX1Filter(dstBlock-4, stride, QP);
-                else if(mode & H_DEBLOCK){
-#if TEMPLATE_PP_ALTIVEC
-                    DECLARE_ALIGNED(16, unsigned char, tempBlock)[272];
-                    int t;
-                    transpose_16x8_char_toPackedAlign_altivec(tempBlock, dstBlock - (4 + 1), stride);
-
-                    t = vertClassify_altivec(tempBlock-48, 16, &c);
-                    if(t==1) {
-                        doVertLowPass_altivec(tempBlock-48, 16, &c);
-                        transpose_8x16_char_fromPackedAlign_altivec(dstBlock - (4 + 1), tempBlock, stride);
-                    }
-                    else if(t==2) {
-                        doVertDefFilter_altivec(tempBlock-48, 16, &c);
-                        transpose_8x16_char_fromPackedAlign_altivec(dstBlock - (4 + 1), tempBlock, stride);
-                    }
-#else
-                    const int t= RENAME(horizClassify)(dstBlock-4, stride, &c);
-
-                    if(t==1)
-                        RENAME(doHorizLowPass)(dstBlock-4, stride, &c);
-                    else if(t==2)
-                        RENAME(doHorizDefFilter)(dstBlock-4, stride, &c);
-#endif
-                }else if(mode & H_A_DEBLOCK){
-                    RENAME(do_a_deblock)(dstBlock-8, 1, stride, &c);
-                }
-#endif //TEMPLATE_PP_MMX
-                if(mode & DERING){
-                //FIXME filter first line
-                    if(y>0) RENAME(dering)(dstBlock - stride - 8, stride, &c);
-                }
-
-                if(mode & TEMP_NOISE_FILTER)
-                {
-                    RENAME(tempNoiseReducer)(dstBlock-8, stride,
-                            c.tempBlurred[isColor] + y*dstStride + x,
-                            c.tempBlurredPast[isColor] + (y>>3)*256 + (x>>3) + 256,
-                            c.ppMode.maxTmpNoise);
-                }
-            }
-
-            dstBlock+=8;
-            srcBlock+=8;
-
-#if TEMPLATE_PP_MMX
-            tmpXchg= tempBlock1;
-            tempBlock1= tempBlock2;
-            tempBlock2 = tmpXchg;
-#endif
-        }
-
-        if(mode & DERING){
-            if(y > 0) RENAME(dering)(dstBlock - dstStride - 8, dstStride, &c);
-        }
-
-        if((mode & TEMP_NOISE_FILTER)){
-            RENAME(tempNoiseReducer)(dstBlock-8, dstStride,
-                    c.tempBlurred[isColor] + y*dstStride + x,
-                    c.tempBlurredPast[isColor] + (y>>3)*256 + (x>>3) + 256,
-                    c.ppMode.maxTmpNoise);
-        }
-
-        /* did we use a tmp buffer for the last lines*/
-        if(y+15 >= height){
-            uint8_t *dstBlock= &(dst[y*dstStride]);
-            if(width==FFABS(dstStride))
-                linecpy(dstBlock, tempDst + dstStride, height-y, dstStride);
-            else{
-                int i;
-                for(i=0; i<height-y; i++){
-                    memcpy(dstBlock + i*dstStride, tempDst + (i+1)*dstStride, width);
-                }
-            }
-        }
-/*
-        for(x=0; x<width; x+=32){
-            volatile int i;
-            i+=   dstBlock[x + 7*dstStride] + dstBlock[x + 8*dstStride]
-                + dstBlock[x + 9*dstStride] + dstBlock[x +10*dstStride]
-                + dstBlock[x +11*dstStride] + dstBlock[x +12*dstStride];
-                + dstBlock[x +13*dstStride]
-                + dstBlock[x +14*dstStride] + dstBlock[x +15*dstStride];
-        }*/
-    }
-#if   TEMPLATE_PP_3DNOW
-    __asm__ volatile("femms");
-#elif TEMPLATE_PP_MMX
-    __asm__ volatile("emms");
-#endif
-
-#ifdef DEBUG_BRIGHTNESS
-    if(!isColor){
-        int max=1;
-        int i;
-        for(i=0; i<256; i++)
-            if(yHistogram[i] > max) max=yHistogram[i];
-
-        for(i=1; i<256; i++){
-            int x;
-            int start=yHistogram[i-1]/(max/256+1);
-            int end=yHistogram[i]/(max/256+1);
-            int inc= end > start ? 1 : -1;
-            for(x=start; x!=end+inc; x+=inc)
-                dst[ i*dstStride + x]+=128;
-        }
-
-        for(i=0; i<100; i+=2){
-            dst[ (white)*dstStride + i]+=128;
-            dst[ (black)*dstStride + i]+=128;
-        }
-    }
-#endif
-
-    *c2= c; //copy local context back
-
-}
-
-#undef RENAME
-#undef TEMPLATE_PP_C
-#undef TEMPLATE_PP_ALTIVEC
-#undef TEMPLATE_PP_MMX
-#undef TEMPLATE_PP_MMXEXT
-#undef TEMPLATE_PP_3DNOW
-#undef TEMPLATE_PP_SSE2
diff --git a/libpostproc/postprocres.rc b/libpostproc/postprocres.rc
deleted file mode 100644
index e6104ac..0000000
--- a/libpostproc/postprocres.rc
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Windows resource file for libpostproc
- *
- * Copyright (C) 2012 James Almer
- * Copyright (C) 2013 Tiancheng "Timothy" Gu
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include <windows.h>
-#include "libpostproc/version.h"
-#include "libavutil/ffversion.h"
-#include "config.h"
-
-1 VERSIONINFO
-FILEVERSION     LIBPOSTPROC_VERSION_MAJOR, LIBPOSTPROC_VERSION_MINOR, LIBPOSTPROC_VERSION_MICRO, 0
-PRODUCTVERSION  LIBPOSTPROC_VERSION_MAJOR, LIBPOSTPROC_VERSION_MINOR, LIBPOSTPROC_VERSION_MICRO, 0
-FILEFLAGSMASK   VS_FFI_FILEFLAGSMASK
-FILEOS          VOS_NT_WINDOWS32
-FILETYPE        VFT_DLL
-{
-    BLOCK "StringFileInfo"
-    {
-        BLOCK "040904B0"
-        {
-            VALUE "CompanyName",      "FFmpeg Project"
-            VALUE "FileDescription",  "FFmpeg postprocessing library"
-            VALUE "FileVersion",      AV_STRINGIFY(LIBPOSTPROC_VERSION)
-            VALUE "InternalName",     "libpostproc"
-            VALUE "LegalCopyright",   "Copyright (C) 2000-" AV_STRINGIFY(CONFIG_THIS_YEAR) " FFmpeg Project"
-            VALUE "OriginalFilename", "postproc" BUILDSUF "-" AV_STRINGIFY(LIBPOSTPROC_VERSION_MAJOR) SLIBSUF
-            VALUE "ProductName",      "FFmpeg"
-            VALUE "ProductVersion",   FFMPEG_VERSION
-        }
-    }
-
-    BLOCK "VarFileInfo"
-    {
-        VALUE "Translation", 0x0409, 0x04B0
-    }
-}
diff --git a/libpostproc/version.h b/libpostproc/version.h
deleted file mode 100644
index 111db44..0000000
--- a/libpostproc/version.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Version macros.
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef POSTPROC_POSTPROCESS_VERSION_H
-#define POSTPROC_POSTPROCESS_VERSION_H
-
-/**
- * @file
- * Libpostproc version macros
- */
-
-#include "libavutil/avutil.h"
-
-#define LIBPOSTPROC_VERSION_MAJOR 52
-#define LIBPOSTPROC_VERSION_MINOR  3
-#define LIBPOSTPROC_VERSION_MICRO 100
-
-#define LIBPOSTPROC_VERSION_INT AV_VERSION_INT(LIBPOSTPROC_VERSION_MAJOR, \
-                                               LIBPOSTPROC_VERSION_MINOR, \
-                                               LIBPOSTPROC_VERSION_MICRO)
-#define LIBPOSTPROC_VERSION     AV_VERSION(LIBPOSTPROC_VERSION_MAJOR, \
-                                           LIBPOSTPROC_VERSION_MINOR, \
-                                           LIBPOSTPROC_VERSION_MICRO)
-#define LIBPOSTPROC_BUILD       LIBPOSTPROC_VERSION_INT
-
-#define LIBPOSTPROC_IDENT       "postproc" AV_STRINGIFY(LIBPOSTPROC_VERSION)
-
-#endif /* POSTPROC_POSTPROCESS_VERSION_H */
diff --git a/libswresample/swresample-test.c b/libswresample/swresample-test.c
deleted file mode 100644
index 379d385..0000000
--- a/libswresample/swresample-test.c
+++ /dev/null
@@ -1,414 +0,0 @@
-/*
- * Copyright (C) 2011-2012 Michael Niedermayer (michaelni@gmx.at)
- * Copyright (c) 2002 Fabrice Bellard
- *
- * This file is part of libswresample
- *
- * libswresample is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * libswresample is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with libswresample; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include "libavutil/avassert.h"
-#include "libavutil/channel_layout.h"
-#include "libavutil/common.h"
-#include "libavutil/opt.h"
-#include "swresample.h"
-
-#undef time
-#include "time.h"
-#undef fprintf
-
-#define SAMPLES 1000
-
-#define ASSERT_LEVEL 2
-
-static double get(uint8_t *a[], int ch, int index, int ch_count, enum AVSampleFormat f){
-    const uint8_t *p;
-    if(av_sample_fmt_is_planar(f)){
-        f= av_get_alt_sample_fmt(f, 0);
-        p= a[ch];
-    }else{
-        p= a[0];
-        index= ch + index*ch_count;
-    }
-
-    switch(f){
-    case AV_SAMPLE_FMT_U8 : return ((const uint8_t*)p)[index]/127.0-1.0;
-    case AV_SAMPLE_FMT_S16: return ((const int16_t*)p)[index]/32767.0;
-    case AV_SAMPLE_FMT_S32: return ((const int32_t*)p)[index]/2147483647.0;
-    case AV_SAMPLE_FMT_FLT: return ((const float  *)p)[index];
-    case AV_SAMPLE_FMT_DBL: return ((const double *)p)[index];
-    default: av_assert0(0);
-    }
-}
-
-static void  set(uint8_t *a[], int ch, int index, int ch_count, enum AVSampleFormat f, double v){
-    uint8_t *p;
-    if(av_sample_fmt_is_planar(f)){
-        f= av_get_alt_sample_fmt(f, 0);
-        p= a[ch];
-    }else{
-        p= a[0];
-        index= ch + index*ch_count;
-    }
-    switch(f){
-    case AV_SAMPLE_FMT_U8 : ((uint8_t*)p)[index]= av_clip_uint8 (lrint((v+1.0)*127));     break;
-    case AV_SAMPLE_FMT_S16: ((int16_t*)p)[index]= av_clip_int16 (lrint(v*32767));         break;
-    case AV_SAMPLE_FMT_S32: ((int32_t*)p)[index]= av_clipl_int32(llrint(v*2147483647));   break;
-    case AV_SAMPLE_FMT_FLT: ((float  *)p)[index]= v;                                      break;
-    case AV_SAMPLE_FMT_DBL: ((double *)p)[index]= v;                                      break;
-    default: av_assert2(0);
-    }
-}
-
-static void shift(uint8_t *a[], int index, int ch_count, enum AVSampleFormat f){
-    int ch;
-
-    if(av_sample_fmt_is_planar(f)){
-        f= av_get_alt_sample_fmt(f, 0);
-        for(ch= 0; ch<ch_count; ch++)
-            a[ch] += index*av_get_bytes_per_sample(f);
-    }else{
-        a[0] += index*ch_count*av_get_bytes_per_sample(f);
-    }
-}
-
-static const enum AVSampleFormat formats[] = {
-    AV_SAMPLE_FMT_S16,
-    AV_SAMPLE_FMT_FLTP,
-    AV_SAMPLE_FMT_S16P,
-    AV_SAMPLE_FMT_FLT,
-    AV_SAMPLE_FMT_S32P,
-    AV_SAMPLE_FMT_S32,
-    AV_SAMPLE_FMT_U8P,
-    AV_SAMPLE_FMT_U8,
-    AV_SAMPLE_FMT_DBLP,
-    AV_SAMPLE_FMT_DBL,
-};
-
-static const int rates[] = {
-    8000,
-    11025,
-    16000,
-    22050,
-    32000,
-    48000,
-};
-
-uint64_t layouts[]={
-    AV_CH_LAYOUT_MONO                    ,
-    AV_CH_LAYOUT_STEREO                  ,
-    AV_CH_LAYOUT_2_1                     ,
-    AV_CH_LAYOUT_SURROUND                ,
-    AV_CH_LAYOUT_4POINT0                 ,
-    AV_CH_LAYOUT_2_2                     ,
-    AV_CH_LAYOUT_QUAD                    ,
-    AV_CH_LAYOUT_5POINT0                 ,
-    AV_CH_LAYOUT_5POINT1                 ,
-    AV_CH_LAYOUT_5POINT0_BACK            ,
-    AV_CH_LAYOUT_5POINT1_BACK            ,
-    AV_CH_LAYOUT_7POINT0                 ,
-    AV_CH_LAYOUT_7POINT1                 ,
-    AV_CH_LAYOUT_7POINT1_WIDE            ,
-};
-
-static void setup_array(uint8_t *out[SWR_CH_MAX], uint8_t *in, enum AVSampleFormat format, int samples){
-    if(av_sample_fmt_is_planar(format)){
-        int i;
-        int plane_size= av_get_bytes_per_sample(format&0xFF)*samples;
-        format&=0xFF;
-        for(i=0; i<SWR_CH_MAX; i++){
-            out[i]= in + i*plane_size;
-        }
-    }else{
-        out[0]= in;
-    }
-}
-
-static int cmp(const int *a, const int *b){
-    return *a - *b;
-}
-
-static void audiogen(void *data, enum AVSampleFormat sample_fmt,
-                     int channels, int sample_rate, int nb_samples)
-{
-    int i, ch, k;
-    double v, f, a, ampa;
-    double tabf1[SWR_CH_MAX];
-    double tabf2[SWR_CH_MAX];
-    double taba[SWR_CH_MAX];
-    unsigned static rnd;
-
-#define PUT_SAMPLE set(data, ch, k, channels, sample_fmt, v);
-#define uint_rand(x) (x = x * 1664525 + 1013904223)
-#define dbl_rand(x) (uint_rand(x)*2.0 / (double)UINT_MAX - 1)
-    k = 0;
-
-    /* 1 second of single freq sinus at 1000 Hz */
-    a = 0;
-    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {
-        v = sin(a) * 0.30;
-        for (ch = 0; ch < channels; ch++)
-            PUT_SAMPLE
-        a += M_PI * 1000.0 * 2.0 / sample_rate;
-    }
-
-    /* 1 second of varing frequency between 100 and 10000 Hz */
-    a = 0;
-    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {
-        v = sin(a) * 0.30;
-        for (ch = 0; ch < channels; ch++)
-            PUT_SAMPLE
-        f  = 100.0 + (((10000.0 - 100.0) * i) / sample_rate);
-        a += M_PI * f * 2.0 / sample_rate;
-    }
-
-    /* 0.5 second of low amplitude white noise */
-    for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) {
-        v = dbl_rand(rnd) * 0.30;
-        for (ch = 0; ch < channels; ch++)
-            PUT_SAMPLE
-    }
-
-    /* 0.5 second of high amplitude white noise */
-    for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) {
-        v = dbl_rand(rnd);
-        for (ch = 0; ch < channels; ch++)
-            PUT_SAMPLE
-    }
-
-    /* 1 second of unrelated ramps for each channel */
-    for (ch = 0; ch < channels; ch++) {
-        taba[ch]  = 0;
-        tabf1[ch] = 100 + uint_rand(rnd) % 5000;
-        tabf2[ch] = 100 + uint_rand(rnd) % 5000;
-    }
-    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {
-        for (ch = 0; ch < channels; ch++) {
-            v = sin(taba[ch]) * 0.30;
-            PUT_SAMPLE
-            f = tabf1[ch] + (((tabf2[ch] - tabf1[ch]) * i) / sample_rate);
-            taba[ch] += M_PI * f * 2.0 / sample_rate;
-        }
-    }
-
-    /* 2 seconds of 500 Hz with varying volume */
-    a    = 0;
-    ampa = 0;
-    for (i = 0; i < 2 * sample_rate && k < nb_samples; i++, k++) {
-        for (ch = 0; ch < channels; ch++) {
-            double amp = (1.0 + sin(ampa)) * 0.15;
-            if (ch & 1)
-                amp = 0.30 - amp;
-            v = sin(a) * amp;
-            PUT_SAMPLE
-            a    += M_PI * 500.0 * 2.0 / sample_rate;
-            ampa += M_PI *  2.0 / sample_rate;
-        }
-    }
-}
-
-int main(int argc, char **argv){
-    int in_sample_rate, out_sample_rate, ch ,i, flush_count;
-    uint64_t in_ch_layout, out_ch_layout;
-    enum AVSampleFormat in_sample_fmt, out_sample_fmt;
-    uint8_t array_in[SAMPLES*8*8];
-    uint8_t array_mid[SAMPLES*8*8*3];
-    uint8_t array_out[SAMPLES*8*8+100];
-    uint8_t *ain[SWR_CH_MAX];
-    uint8_t *aout[SWR_CH_MAX];
-    uint8_t *amid[SWR_CH_MAX];
-    int flush_i=0;
-    int mode;
-    int num_tests = 10000;
-    uint32_t seed = 0;
-    uint32_t rand_seed = 0;
-    int remaining_tests[FF_ARRAY_ELEMS(rates) * FF_ARRAY_ELEMS(layouts) * FF_ARRAY_ELEMS(formats) * FF_ARRAY_ELEMS(layouts) * FF_ARRAY_ELEMS(formats)];
-    int max_tests = FF_ARRAY_ELEMS(remaining_tests);
-    int test;
-    int specific_test= -1;
-
-    struct SwrContext * forw_ctx= NULL;
-    struct SwrContext *backw_ctx= NULL;
-
-    if (argc > 1) {
-        if (!strcmp(argv[1], "-h") || !strcmp(argv[1], "--help")) {
-            av_log(NULL, AV_LOG_INFO, "Usage: swresample-test [<num_tests>[ <test>]]  \n"
-                   "num_tests           Default is %d\n", num_tests);
-            return 0;
-        }
-        num_tests = strtol(argv[1], NULL, 0);
-        if(num_tests < 0) {
-            num_tests = -num_tests;
-            rand_seed = time(0);
-        }
-        if(num_tests<= 0 || num_tests>max_tests)
-            num_tests = max_tests;
-        if(argc > 2) {
-            specific_test = strtol(argv[1], NULL, 0);
-        }
-    }
-
-    for(i=0; i<max_tests; i++)
-        remaining_tests[i] = i;
-
-    for(test=0; test<num_tests; test++){
-        unsigned r;
-        uint_rand(seed);
-        r = (seed * (uint64_t)(max_tests - test)) >>32;
-        FFSWAP(int, remaining_tests[r], remaining_tests[max_tests - test - 1]);
-    }
-    qsort(remaining_tests + max_tests - num_tests, num_tests, sizeof(remaining_tests[0]), (void*)cmp);
-    in_sample_rate=16000;
-    for(test=0; test<num_tests; test++){
-        char  in_layout_string[256];
-        char out_layout_string[256];
-        unsigned vector= remaining_tests[max_tests - test - 1];
-        int in_ch_count;
-        int out_count, mid_count, out_ch_count;
-
-        in_ch_layout    = layouts[vector % FF_ARRAY_ELEMS(layouts)]; vector /= FF_ARRAY_ELEMS(layouts);
-        out_ch_layout   = layouts[vector % FF_ARRAY_ELEMS(layouts)]; vector /= FF_ARRAY_ELEMS(layouts);
-        in_sample_fmt   = formats[vector % FF_ARRAY_ELEMS(formats)]; vector /= FF_ARRAY_ELEMS(formats);
-        out_sample_fmt  = formats[vector % FF_ARRAY_ELEMS(formats)]; vector /= FF_ARRAY_ELEMS(formats);
-        out_sample_rate = rates  [vector % FF_ARRAY_ELEMS(rates  )]; vector /= FF_ARRAY_ELEMS(rates);
-        av_assert0(!vector);
-
-        if(specific_test == 0){
-            if(out_sample_rate != in_sample_rate || in_ch_layout != out_ch_layout)
-                continue;
-        }
-
-        in_ch_count= av_get_channel_layout_nb_channels(in_ch_layout);
-        out_ch_count= av_get_channel_layout_nb_channels(out_ch_layout);
-        av_get_channel_layout_string( in_layout_string, sizeof( in_layout_string),  in_ch_count,  in_ch_layout);
-        av_get_channel_layout_string(out_layout_string, sizeof(out_layout_string), out_ch_count, out_ch_layout);
-        fprintf(stderr, "TEST: %s->%s, rate:%5d->%5d, fmt:%s->%s\n",
-                in_layout_string, out_layout_string,
-                in_sample_rate, out_sample_rate,
-                av_get_sample_fmt_name(in_sample_fmt), av_get_sample_fmt_name(out_sample_fmt));
-        forw_ctx  = swr_alloc_set_opts(forw_ctx, out_ch_layout, out_sample_fmt,  out_sample_rate,
-                                                    in_ch_layout,  in_sample_fmt,  in_sample_rate,
-                                        0, 0);
-        backw_ctx = swr_alloc_set_opts(backw_ctx, in_ch_layout,  in_sample_fmt,             in_sample_rate,
-                                                    out_ch_layout, out_sample_fmt, out_sample_rate,
-                                        0, 0);
-        if(!forw_ctx) {
-            fprintf(stderr, "Failed to init forw_cts\n");
-            return 1;
-        }
-        if(!backw_ctx) {
-            fprintf(stderr, "Failed to init backw_ctx\n");
-            return 1;
-        }
-        if(swr_init( forw_ctx) < 0)
-            fprintf(stderr, "swr_init(->) failed\n");
-        if(swr_init(backw_ctx) < 0)
-            fprintf(stderr, "swr_init(<-) failed\n");
-                //FIXME test planar
-        setup_array(ain , array_in ,  in_sample_fmt,   SAMPLES);
-        setup_array(amid, array_mid, out_sample_fmt, 3*SAMPLES);
-        setup_array(aout, array_out,  in_sample_fmt           ,   SAMPLES);
-#if 0
-        for(ch=0; ch<in_ch_count; ch++){
-            for(i=0; i<SAMPLES; i++)
-                set(ain, ch, i, in_ch_count, in_sample_fmt, sin(i*i*3/SAMPLES));
-        }
-#else
-        audiogen(ain, in_sample_fmt, in_ch_count, SAMPLES/6+1, SAMPLES);
-#endif
-        mode = uint_rand(rand_seed) % 3;
-        if(mode==0 /*|| out_sample_rate == in_sample_rate*/) {
-            mid_count= swr_convert(forw_ctx, amid, 3*SAMPLES, (const uint8_t **)ain, SAMPLES);
-        } else if(mode==1){
-            mid_count= swr_convert(forw_ctx, amid,         0, (const uint8_t **)ain, SAMPLES);
-            mid_count+=swr_convert(forw_ctx, amid, 3*SAMPLES, (const uint8_t **)ain,       0);
-        } else {
-            int tmp_count;
-            mid_count= swr_convert(forw_ctx, amid,         0, (const uint8_t **)ain,       1);
-            av_assert0(mid_count==0);
-            shift(ain,  1, in_ch_count, in_sample_fmt);
-            mid_count+=swr_convert(forw_ctx, amid, 3*SAMPLES, (const uint8_t **)ain,       0);
-            shift(amid,  mid_count, out_ch_count, out_sample_fmt); tmp_count = mid_count;
-            mid_count+=swr_convert(forw_ctx, amid,         2, (const uint8_t **)ain,       2);
-            shift(amid,  mid_count-tmp_count, out_ch_count, out_sample_fmt); tmp_count = mid_count;
-            shift(ain,  2, in_ch_count, in_sample_fmt);
-            mid_count+=swr_convert(forw_ctx, amid,         1, (const uint8_t **)ain, SAMPLES-3);
-            shift(amid,  mid_count-tmp_count, out_ch_count, out_sample_fmt); tmp_count = mid_count;
-            shift(ain, -3, in_ch_count, in_sample_fmt);
-            mid_count+=swr_convert(forw_ctx, amid, 3*SAMPLES, (const uint8_t **)ain,       0);
-            shift(amid,  -tmp_count, out_ch_count, out_sample_fmt);
-        }
-        out_count= swr_convert(backw_ctx,aout, SAMPLES, (const uint8_t **)amid, mid_count);
-
-        for(ch=0; ch<in_ch_count; ch++){
-            double sse, maxdiff=0;
-            double sum_a= 0;
-            double sum_b= 0;
-            double sum_aa= 0;
-            double sum_bb= 0;
-            double sum_ab= 0;
-            for(i=0; i<out_count; i++){
-                double a= get(ain , ch, i, in_ch_count, in_sample_fmt);
-                double b= get(aout, ch, i, in_ch_count, in_sample_fmt);
-                sum_a += a;
-                sum_b += b;
-                sum_aa+= a*a;
-                sum_bb+= b*b;
-                sum_ab+= a*b;
-                maxdiff= FFMAX(maxdiff, FFABS(a-b));
-            }
-            sse= sum_aa + sum_bb - 2*sum_ab;
-            if(sse < 0 && sse > -0.00001) sse=0; //fix rounding error
-
-            fprintf(stderr, "[e:%f c:%f max:%f] len:%5d\n", out_count ? sqrt(sse/out_count) : 0, sum_ab/(sqrt(sum_aa*sum_bb)), maxdiff, out_count);
-        }
-
-        flush_i++;
-        flush_i%=21;
-        flush_count = swr_convert(backw_ctx,aout, flush_i, 0, 0);
-        shift(aout,  flush_i, in_ch_count, in_sample_fmt);
-        flush_count+= swr_convert(backw_ctx,aout, SAMPLES-flush_i, 0, 0);
-        shift(aout, -flush_i, in_ch_count, in_sample_fmt);
-        if(flush_count){
-            for(ch=0; ch<in_ch_count; ch++){
-                double sse, maxdiff=0;
-                double sum_a= 0;
-                double sum_b= 0;
-                double sum_aa= 0;
-                double sum_bb= 0;
-                double sum_ab= 0;
-                for(i=0; i<flush_count; i++){
-                    double a= get(ain , ch, i+out_count, in_ch_count, in_sample_fmt);
-                    double b= get(aout, ch, i, in_ch_count, in_sample_fmt);
-                    sum_a += a;
-                    sum_b += b;
-                    sum_aa+= a*a;
-                    sum_bb+= b*b;
-                    sum_ab+= a*b;
-                    maxdiff= FFMAX(maxdiff, FFABS(a-b));
-                }
-                sse= sum_aa + sum_bb - 2*sum_ab;
-                if(sse < 0 && sse > -0.00001) sse=0; //fix rounding error
-
-                fprintf(stderr, "[e:%f c:%f max:%f] len:%5d F:%3d\n", sqrt(sse/flush_count), sum_ab/(sqrt(sum_aa*sum_bb)), maxdiff, flush_count, flush_i);
-            }
-        }
-
-
-        fprintf(stderr, "\n");
-    }
-
-    return 0;
-}
